report- ; 
sil=all; 
macro - ;
mxram 600 ; 
macro [ 500000 ; 
macro *20 5729000 ; 
macro = ;                                        
var - ; 
xwipe ; 
goto = %0 ; 
macreport = ; 
silent = all ; 

/*-------------------------------------------------------
TNT script:  PlaceMyFossils.run                                                           
Updated:     2024-09-05                                                                 
Author:      Santiago A. Catalano                                                        
Mantainer:   Santiago A. Catalano                              
Depends:     TNT version 1.6
             (Goloboff and Morales, 2023. doi: 10.1111/cla.12524)      
License:     GPL (3). Citation: Catalano et al. (2024)    
---------------------------------------------------------*/

var: 
taxsize
charsize
grusize
nucondis
nosize ; 

macfloat 7 ; 
set taxsize 1000 ; 
set charsize 1000 ; 
set grusize 50; 
set nucondis 30 ; 
set nosize 'taxsize' * 2 ; 
set + ;
lquote - ; 
lquote ] ; 
macreport - ; 
 
var:
addchar                 elesco   eltax          maxi_mult['nucondis']           ptos    van tokill 
alto[7]                 elmasi                  maxis['charsize']               px      van_lbl['nosize']
altotot                 elmini                  maxrange                py      violet
alturama                elsco                   minblue                 query   whichwt
ancho[7]                esco                    mini                    r       yacambN['nosize']
anchotot                eti[('taxsize'*2) 2]    mini_all                raiz    yacambP['nosize']
ause                    etiqueta                mini_err                rango   yes
bak_listchar ['charsize'] back_maxi['grusize']          false_neg['nosize']             mini_err_grp['grusize'] red     
back_mini['grusize']            falses_neg['nosize' 'grusize']  mini_mult['nucondis']   ref max_dist    
back_score['nosize' 'grusize']  falses_pos['nosize' 'grusize']  minis['charsize']               ref_tree
bescond                 false_pos['nosize']             mit                     ris     
besever                 green                   miti                    round   
besnod                  group_file[100]         miti_all                savempts        
bespos                  grpscore['nosize' 'grusize']  maxgrpscore['nosize' 'grusize'] 
miti_err        setting_file[300]       
best                    guichpiwe               mult_w_target           shift   
bestdis                 guichsensit             multiopt                shof    
mybestscore['grusize'] guichsp                  multisp                 shoft   
bl_name[300]            guichval                multree                 sizsq   
blue                    hayconts          myout[100]            son_uno son_cero        
bran    haylands        n                       sonamb  
bran_ref                haytax                  nconds                  sortedchars[4000]       
ccc                     innewick                nds                     span    
ces                     input_file[300]         nodo ['nosize']         span_all        
char_anal               input_treefile[100]     nodo_trans              span_err        
char_file[100]          iswith_k                nopiwe                  sszz    
charscore['nosize' 'charsize' ] k                       nosta['taxsize']        star_b  
kkval                   notarget                star_x  start_x [7]
check_grps ['charsize'] 
chg_dogrpchars          kmax                    nuabs                   star_y   start_y [7]
choan                   kmin                    numchrgrp               std     
chssp                   kpace                   nval                    stdlmks 
condic['nucondis']      larama                  onetocero['nosize']    cerotoone ['nosize' ]          str_settings[1000]      
coras                   last                    output_consense[50]     suma_x  
core[('taxsize'*2)]                       output_file[50]               suma_y  
core_mult['nucondis' 'nosize' ] limA                    output_mpts[50]         tadentro        
ctos                    tot_width               limB                    output_svg[50]   
output_sensit [50]    tancia  output_errbars[50]
ctos_sp                 limred                  output_svggrpchar[300]  taxnombre[300]  
cual                    lineas                  output_svggrperr[100]   taxtarg['taxsize']
output_svgchars [100] grp_scores_tabl [100]
dde                                           pace                    tgtname[300]    
dist                    listax['taxsize']       pace_x  bloque          tgtsp   
distri[100 ]             listchar['charsize']    pace_y                  tot_hig 
doerror_w_tgt           lolim                   pos_cero                trescua 
dogrpchars              losarboles              pos_one                 trescuar        
dogrptree               losod                   pos_x                   trescuar_all    
doing_grp_anal          man_trad                pos_y                   trescuar_err    
dolik                   mano                    opt_tree                poss['nosize']          negg['nosize']  uncu    
yacambN_out ['nosize']
negg_out ['nosize']
poss_out ['nosize']
yacambP_out ['nosize']
dolist                  MAXCONDS                posx                    uncua   
donewick                maxi                    posy                    uncuar  
doreadfile              maxi_all                primero                 uncuar_all      
dosensit                maxi_err                prop                    uncuar_err      
dostd                   maxi_err_grp['nosize']  prunne                  uplim
unlinked                doing_unlinked          multicrit
mk_charscores ['charsize'] rand_taxa ['taxsize' ]                       myprog
coloring                doing_piwe              doing_parsim           doing_mk
pars_frm_mult           piw_frm_mult            mk_frm_mult             doing_mk_frm_mult
doing_piwe_frm_mult      doing_pars_frm_mult done_mk done_piw   done_pars 
mk_space sensato reduced_mk_sens active docross_w_tgt space_sensit unlinked_sensit
doerror_w_grps
prefix [ 100] 
doprefix
min_dist
int_string [100] 
Los_errors[100]
cond_string[100]
toter_string[100] 
lodes[20] 
limmis 
limsp 
test_grp
tgt_miss [ 'charsize' ]
muymiss_sp[ 'taxsize' ] 
sp_char_miss[ 'charsize' ]
tgt_miss[ 'charsize' ] 
sps_inn 
ndo
sp_pos_grp ['nosize' 'grusize'] 
sp_neg_grp ['nosize' 'grusize'] 
sp_pos ['nosize' ] 
sp_neg ['nosize' ] 
noda
doing_EPA
sumLik
ladif
reds[30] 
greens[30] 
mini_bk 
laprob
nomeagrupes
output_conditions [1000] 
elagre 
resolved 
blues[30] 
redsiz
star_b  fin_y   ejeX_startX ejeX_finX x_span  ejeY_startY  ejeY_finY   ejeX_y ejeY_x  y_span 
error_global posx_graf separ anch altu posy_graf inter_y interrr mass    posx_nam posy_nam vta
distrib [('nosize' * 'taxsize') ] 
cuantas total observ rut nod prob['grusize' 3 ] 
calc_prob repls iteres
choram 
tiempo
pos_two  pos_tre pos_cua
opt_mk_brlen [  'nosize' ] 
mk_brlen [ 'nosize' ] 
largos [ 'nosize' ] 
red_mk_brlen [ 'nosize' ]  
tmp_brlen [ 'nosize' ] 
guichimini ['nosize' ]  listita[2]   full_tree red_tree ter vamos
offML_char_anal doandsense doandmult doandmusp  errandmult errndsense
bescuare['nosize' 6 ]
son
viridis [3 20 ]  
colim   [21] 
maxclr 
micore
do_palette
dientes [2] 
pavote pivote 
trescuarI  uncuarI  maxiI miniI mitiI shoftI shiftI
trad_nd['nosize'] ndtran
inv_trad_nd ['nosize'] 
dowpas ['nosize']  stri [20]  terr
docolor_w_grps desroot_noout toinv['nosize'] error 
magic['grusize'] erpo erne
outrut pivote_out pavote_out trad_nd_out ['nosize'] 
desroot_noout_out toinv_out ['nosize'] 
prevout
doamb hayigual outcross stricting cestros['nosize']  guicherr
guicherr_cross mean_dist
clade_anal score_poly[ 'nosize' 2 ] 
lis ['nosize']  domodif tochang tofork color_poly ['nosize' 3 ] luptre tricto
guerquery justerr muchos ogrup sisou brastri [100]  hermano queta[100] quita [100] 
did_colorquer 
;   


 


naked=;

col- ;  
subopt 0 ;
warn - ; 
taxname +200 ;
set + ; 
piwe - ; 

set input_treefile $NOTREEFILE ; 
set input_file $NOFILE ; 
set output_consense $Strict.tre ; 
set output_mpts $Opt_trees.tre ; 
set output_svg $Query_placement.svg ;
set output_sensit $Query_sensit.svg ;
set output_svggrpchar $Query_placement_partitions.svg ;
set output_svggrperr $Error_by_subtree.svg ; 
set char_file $Chars_score_table.out ; 
set output_svgchars $Chars_score_table.svg ; 
set group_file $Partitions_score_table.svg ; 
set grp_scores_tabl $Partitions_score_table.out ; 
set setting_file $settings.txt ; 
set Los_errors $Errors_by_subtree.out ;
set prefix $Prefix ; 
set toter_string $Error_by_partition.out ; 
set output_conditions $Running_conditions.out ; 
set output_errbars  $Errors_by_partition.svg
set ancho[0] 375 ; set ancho[4] 375 ;
set ancho[2] 375 ; set ancho[3] 375 ; 
set ancho[1] 375 ; 
set ancho[6] 375 ; 

set alto[2] 300 ; set alto[4] 178 ; 
set alto[1] 90 ; set alto[3] 125 ;

set alto [6 ] 100 ; 



set start_x[5] 390 ;
set start_y[5] 308 ;
set ancho[5] 375 ; 
set alto[5] 195;  

set start_x[0] 8 ; 
set start_x[2] 8 ; set start_x[4] 390 ;
set active 1 ; 
set start_x[1] 8 ; set start_x[3] 390 ;
 set start_y [4] 8 ; 
set start_y[2] 8 ; set start_y[3] 185 ; 
set start_y[1] 305 ; 

set start_x[6] 8 ;
set start_y[6] 130  ;


set start_y[0] 390 ;
set alto [0] 150 ;
set ancho[0] 375 ;
set start_x[0] 8 ;

set anchotot 780 ; 
set altotot 575;

set tgtsp  ( -9)   ; 
set chssp 1 ; 
set nopiwe 3 ;
set dostd 1 ; 
set std 1 ;
set addchar 1 ; 
set stdlmks 1 ;
set notarget 1 ; 
set dogrpchars 0 ; 
set mult_w_target 0 ;
set besever 0 ; 
set dolist 0 ; 
set kmin 3 ;
set kmax 30 ; 
set kpace 1 ; 
set nconds 10 ; 
set nval 10 ; 
set kkval 6 ; 
set dosensit 0 ;
set MAXCONDS 15 ;
set guichval 0 ;
set reduced_mk_sens 0 ; 
set dogrptree 1 ; 
set sensato 0 ; 
set chg_dogrpchars 0 ; 
set char_anal 0 ; 
set doing_grp_anal 0 ; 
set doerror_w_tgt 1 ;
set dolik 0 ; 
set docross_w_tgt 1 ; 
set doing_unlinked 0 ; 
set space_sensit 1 ; 
set unlinked_sensit 1 ; 
set doprefix 0 ; 
set limmis 0.75 ; 
set limsp 0.5 ; 
set muymiss_sp 0 ; 
set nopiwe 3 ; 
set doing_EPA 0 ; 
set nomeagrupes 0 ; 
set elagre 0 ;
set resolved 0 ;
set calc_prob 0 ; 
set repls 1000 ; 
set maxclr 20 ;
set do_palette 0 ; 
set doamb 1 ;
set guicherr 2 ; 
set guicherr_cross 2 ; 
set domodif  0 ; 
set did_colorquer 0 ; 

 SIL=All; 
 warn- ; 
 
 lquote = ; 
  lquote [ ; 
  getfname [*.tnt] input_file read .          CHOOSE DATAFILE ;   
  getfname [*.tre] input_treefile read .          CHOOSE REFERENCE TREE ;  
  lquote - ; 
  if (isinstring [ $input_file NOFILE ] )
   cls ; 
   sil-all; quote * Error. No datafile selected ; 
   report=; 
   proc/; 
  end
  if (isinstring [ $input_treefile NOTREEFILE ] ) 
    cls; 
          sil-all; quote * Error. No tree file selected ; 
          report=; 
         proc/; 
  end
  
  sil=all ;
  
  p $input_file ; 
  if (ntrees != -1 ) 
        ra 1 ; tplot [ ; sil-all; k0 ; cls; 
        sil-all ; errmsg Backbone topology cannot be included in the dataset file. It should be included in a separate file   ; 
        report=; 
        sil-all; 
     proc/; 
  end  
  
  
   if ( ntax > 999 ) 
     ra 1 ; tplot [ ; sil-all; k0 ; cls; report =; 
     errmsg This script version handles datasets with 1000 taxa or less. Please contact Santiago Catalano for a modified version. ;     
   end 
   if ( nchar > 999 ) 
       sil=all; report =; k0 ; cls; ra 1 ; tplot [ ; sil-all; 
       errmsg This script version handles datasets with 1000 characters or less. Please contact Santiago Catalano for a modified version. ;     
   end
   
  hold 10000/10000 ; 
  
    
    
  p $input_treefile ; 
   set stricting 0 ; 
    if (ntrees > 0 )
       cls; tplot [ ; 
       sil-all ; quote *  More than one tree read from tree file. The placement of the target species will be displayed on the strict consensus. If you want to run an analysis using scaffolds inclue a single topology in the tree file; 
       set stricting 1 ; 
       report=; 
  end
 
 
 
 
 loop 0 ntax
   set listax[#1] 0 ;
 stop 
 loop 0 nchar
   set listchar[#1] 1 ;               
 stop 

if (!'stricting')
     goto SCAFFOLD_MENU ; 
else
     goto STRICT_MENU ;
end 
if ('tokill' ) 
 sil-all; tv- ; k 0 ; 
 proc/; 
end
 

 


if ('nopiwe' == 1 ) 
   set output_sensit $Query_MultOpt.svg ; 
end

   
if ('doprefix') 
	 set - ; 
	 sil-all; 
	 set int_string $$prefix $output_svg ; 
	 set output_svg $$int_string ; 
	 set int_string $$prefix $output_consense ; 
	 set output_consense $$int_string ; 
	 set int_string $$prefix $output_mpts ; 
	 set output_mpts $$int_string ; 
	 set int_string $$prefix $output_svggrpchar ; 
	 set output_svggrpchar $$int_string ; 
	 set int_string $$prefix $output_svggrperr ; 
	 set output_svggrperr $$int_string ; 
	 set int_string $$prefix $char_file ; 
	 set char_file $$int_string ; 
	 set int_string $$prefix $group_file ; 
	 set group_file $$int_string ; 
	 set int_string $$prefix $Los_errors ; 
	 set Los_errors $$int_string ; 
	 set int_string $$prefix $toter_string ; 
	 set toter_string $$int_string ; 
	 set int_string $$prefix $output_svgchars ; 
	 set output_svgchars $$int_string ; 
	 set int_string $$prefix $grp_scores_tabl ; 
	 set grp_scores_tabl $$int_string ; 
	 set int_string $$prefix $output_conditions ; 
	 set output_conditions $$int_string ; 
	 set int_string $$prefix $output_sensit ;
	 set output_sensit $$int_string ;  
	 set int_string $$prefix $output_errbars ;
	 set output_errbars $$int_string ;
         set int_string $$prefix $output_conditions  ; 
         set output_conditions $$int_string ; 
end
goto TAX_SETS ;  
goto CHECK_STATUS ; 
goto CHAR_SETS ; 
goto SETTING_PALETTE ; 

sil=all; 
tabl/ 7 ; 
macfloat 7 ; 

if ('nopiwe' == 2 ) 
   set dolik 1 ; 
   lset display ; 
   if ('mk_space' )
      lset nogstatespace ; 
   end
end 


if ( ('sensato'== 1 ) && ('guichsensit' == 2) && ('nopiwe' != 2) )
 set nconds 0 ; 
 hifile open $setting_file ; 
 loop 0 100
   set str_settings hiftext; 
    if ( hifeof )
       endloop ; 
    end
   set nconds++ ; 
 stop
 hifile close ; 
 if ('nconds' > 'MAXCONDS' ) 
  ra1 ; sil-all; tplot [ ; k0 ; cls; 
  errmsg This script allows up to 'MAXCONDS' different conditions in sensitivity analysis ('nconds' lines in $setting_file); 
 end
end



 
set mini 0 ; 
naked =; 
set mini 9999999 ; 
set maxi 0 ; 


 if ('stricting')
   if ('domodif' )  
     goto PLACE_TARGET_WITH_MODIF_MULTREES ; 
   else
     goto COLORTREE_MULTREE ; 
    end
   goto GENERATE_OUTPUT_STRICT; 
   proc/; 
else 
  if ('domodif' ) 
      goto PLACE_TARGET_WITH_MODIF ;
      goto COLORTREE ; 
      goto  GENERATE_OUTPUT_STRICT ; 
      proc/; 
   end 
end 


if ('multisp') 
  if (('nopiwe' == 2 ) || (('nopiwe' == 1 ) && ('mk_frm_mult' == 1 )) )
     ra1 ; tplot [ ;  report=; cls; k0 ; 
     sil-all; errmsg Maximum Likelihood analysis cannot be run with multiple query species ;  
     proc/; 
  end 
end


if ('nopiwe' == 0 ) 
 if ('guichval' == 1) 
  goto CALCULATE_R ; 
 else
  if ('guichval' == 0)
  piwe = 'kkval' ;
  end 
 end 
end

if ( ('sensato' == 1) || ( ('sensato' == 0) && ('nopiwe' == 1 ))  ) 
  if ( ( 'guichsensit' == 0 ) && ('nopiwe' == 0 ) ) 
   set pace (('kmax' - 'kmin' )/ ('nconds'-1)) ; 
     loop 0 ('nconds'-1) 
       set condic [#1] ('pace' * #1 + 'kmin' ) ; 
     stop
  end 
end

 /* nopiwe 0 = IW , 1 = Multiple Optimality criterion   2= LIKELIHOOD    3 = PARSIMONIA  ; */ 
 /*sensato= 1 es cross o sensit */ 
 /* dosensit 0 = sensitivity ; 1= CV ; 2 CV y Sensit ; 3 compare optim criter */ 
 /* pars_frm_mult  piw_frm_mult mk_frm_mult */
 /* guichsensit 0 = k values ; 1= maximum Likelihood 2 = archivo settings */


 
/* ERROR CALCULATION */  
set doing_grp_anal 0 ;
set errndsense 0 ; 
set errandmult 0 ; 
if ('nopiwe' == 1 ) 
 set char_anal 0 ; 
 set dogrpchars 0 ; 
 set clade_anal 0 ; 
end 
if ( 'char_anal' || 'clade_anal'  )
    if ('sensato' && (('dosensit' == 0 )|| ('dosensit' == 2))  )
        set errndsense 1 ;
        set char_anal 0 ; 
        set clade_anal 0 ; 
    else
         if ('nopiwe' ==  1 ) 
           set errandmult 1 ;
           set char_anal 0 ; 
           set clade_anal 0 ; 
        else
             progress 0 100 Running Error Analysis ;    
             goto LAUNCH_ERROR_CALCULATION ;
             progress/; 
        end
    end  
end


 
macfloat 7 ; 
if ( ( ('dosensit' == 1) || ('dosensit' == 2 ) ) && ('sensato' == 1)  ) 
    progress 0 100 Running Leave-one-out Validation Analysis ;    
     goto CROSSVALIDATION ; 
   progress/;  
end

if ('sensato') 
     if (!'notarget') 
	  if (('dosensit' == 0) || ('dosensit' == 2 ) ) 
	       if ('multisp' )
		  progress 0 100 Running Sensitivity Analysis ;    
		   goto SENSIT_MULT_WITH_TARGET ;
		   progress/; 
	       else
		      progress 0 100 Running Sensitivity Analysis ;    
		 
		      goto COLOR_SENSITIVITY ; 
		     progress/; 
	       end 
	  end
     else
      /*  ddd */
    end
end


if ( 'nopiwe' == 1 ) 
 progress 0 100 Running Multiple Optimality Criteria Analysis;
   goto COLOR_SENSITIVITY ; 
 progress/; 
end 




if ( (('sensato' == 0) || ( ( 'sensato' == 1 ) && ('dosensit' == 1) ) ) && ('nopiwe' != 1) ) 
   if ( 'notarget' && ('ause' == 1) ) 
       goto SEARCHES ;
   end
   if ('multisp') 
      if (!'notarget')
          set mult_w_target 1 ;
          goto MULT_WITH_TARGET ;
          goto COLORTREE ;
          log/; 
          if ('dolist') 
             k 0 ; 
             tvault < . ;
             progress 0 100 Calculating Character/Partition Scores;
             sil=all; 
             goto DOCOLORTABLE ;
             if('dogrpchars') 
               goto COLOR_CHARGRPS;  
             end
             progress/; 
         end
      else
         goto SEARCHES ;
         if ('char_anal')
           progress 0 100 Calculating Character/Partition Scores;
           goto COLORTREE_ERROR ; 
           progress/; 
         end
      end  
   else 
      if ('notarget') 
        if ('clade_anal')
          goto COLORTREE_ERROR ;
        end
      else
         progress 0 100 Placing Query Species;
          goto COLORTREE ; 
         progress/; 
       if('dolist')
            k 0 ; 
            tvault < . ; /* los arboles generados en cada posicion por colortree son usado en char_scores para calcular los escores de docolortable solo si es un unico query. Sino se calculan en mult with target*/
            progress 0 100 Calculating Character/Partition Scores;
            goto CHAR_SCORES ; 
            goto DOCOLORTABLE ;
            if ('dogrpchars')
               goto COLOR_CHARGRPS;  
            end
            progress/; 
      end
     end  
   end 
 end
 
GOTO GENERATE_OUTPUT ; 
sil=all ; 
ra 1 ; 
tplot [ ; 
k0 ; 
lquote - ; 
ttag - ; 
tv- ; 
report=; 
sil-all;
proc/; 

label SCAFFOLD_MENU
        set resolved 0 ; 
        tv > 0 ; 
        k 0 ; 
        tv < 0 ;
        k 1 ;  
	ra * ; 
	tv < 0; 
	if (nnodes [0] != nnodes[1])
	     set resolved 1 ; 
	end
	tc 0 ; 
	tv- ; 
	tv > 0 ;
	set raiz root ; 
	tplot ] ; 
	k0 ; 
	set myout $$taxon outgroup ; 
  	opendlg 50 50 'anchotot' 'altotot' Place Species on Backbone... ;


	  showtxt ('start_x[2]'+8) ('start_y[2]'+8) 300 25 Species Settings ; 
	 

	   frame 'start_x[2]' 'start_y[2]' 'ancho[2]' 'alto[2]' ; 
           showtxt ('start_x[2]' + 18) ('start_y[2]'+ 30) 350 20 Target species;
	 
	   choose notarget ('start_x[2]' + 30) ('start_y[2]'+75) 300 20 Select a target species  
	    +   gettxt tgtname ('start_x[2]' + 50) ('start_y[2]'+ 100) 150 20   ;= 
	       ('start_x[2]' + 30) ('start_y[2]'+50) 300 20 Target species is absent in reference tree  
               ('start_x[2]' + 30) ('start_y[2]'+125) 300 20 No  target species ;
          
          
           showtxt ('start_x[2]' + 18) ('start_y[2]'+ 155) 350 20 Add species to query list;  
	   choose chssp ('start_x[2]' + 30) ('start_y[2]'+175) 300 20 Select additional query species
	            + taxsel listax ('start_x[2]' + 50) ('start_y[2]'+200) 150 20 ; = 
	                  ('start_x[2]' + 30) ('start_y[2]'+225) 300 20 Absent in reference tree 
	                  ('start_x[2]' + 30) ('start_y[2]'+250) 300 20 No additional query species ;  
	                                   
      	   check domodif ('start_x[2]' + 18) ('start_y[2]'+275) 300 20 Allow target species to modify relationships ; 

	   frame 'start_x[0]' 'start_y[0]' 'ancho[0]' 'alto[0]' ; 
            showtxt ('start_x[0]' + 8) ('start_y[0]'+ 8) 150 20 Output Settings ; 
	    check doprefix ('start_x[0]' + 8) ('start_y[0]'+ 28) 300 30 Define a prefix for output files ; 
	     +  gettxt prefix ('start_x[0]' + 15) ('start_y[0]'+ 57) 150 20     ;= 
	  showtxt ('start_x[0]'+8) ('start_y[0]'+ 85) 300 25 Palette for coloring ; 
	  choose do_palette ('start_x[0]' + 20) ('start_y[0]'+100) 300 20 Blue->Green->Red
			    ('start_x[0]' + 20) ('start_y[0]'+120) 300 20 Inferno (Yellow->Violet)  ;  

	  frame 'start_x[4]' 'start_y[4]' 'ancho[4]' 'alto[4]' ;
	    showtxt ('start_x[4]'+5) ('start_y[4]'+12) 250 25 Optimality Criterion ; 
	    choose nopiwe ('start_x[4]' + 12) ('start_y[4]'+ 55) 150 20 Implied Weighting 
		    + subdlg ('start_x[4]' + 180) ('start_y[4]'+ 55) 120 20 Define settings ;
		     290 255 350 190 Implied Weighting Settings ; 
		     showtxt 7 7 290 15 Strength weighting against homoplasy ; 
		    choose guichval 11 38 11 11 . 
									+ spin 1 99 kkval 37 35 200 20 Defined by K value ;=
								  11 73 11 11 . ;
								  + spin 2 99 nval 37 70 200 20 Defined by N value ;=
							  closedlg ; =

					('start_x[4]' + 12) ('start_y[4]'+ 105) 160 20 Multiple Optimality Criteria
							 + subdlg ('start_x[4]' + 180) ('start_y[4]'+ 105) 120 20 Define Settings ;
							 290 255 360 230 Settings ; 
							 check pars_frm_mult 5 8 200 21 Maximum Parsimony ;
							 check piw_frm_mult 5 38 120 21 Implied Weighting ;
							 + spin 1 99 kkval 180 38 80 20 K value ;=
							 check mk_frm_mult 5 68 180 21 Maximum Likelihood ; 
							 + check unlinked 11 88 200 21 Use unlinked model ; 
							  check mk_space 11 110 280 21 Use a different state space for each character ;  =
							       
		     closedlg ; =

					('start_x[4]' + 12) ('start_y[4]'+ 80) 150 20 Maximum Likelihood (MK) 
		      + subdlg ('start_x[4]' + 180) ('start_y[4]'+ 80) 120 20 Define settings ;
								      290 255 360 220 Maximum Likelihood Settings ; 
								      check unlinked 11 20 200 21 Use unlinked model ; 
								      check mk_space 11 50 280 21 Use a different state space for each character ;
								      check doing_EPA 11 80 330 21 Show relative probabilities instead of diff. in logL (EPA approach) ;
							  closedlg ; =


		('start_x[4]' + 12) ('start_y[4]'+ 30) 150 20 Maximum Parsimony ; 
	     check sensato ('start_x[4]' + 12) ('start_y[4]'+ 130) 350 20 Run Sensitivity/Leave-one-out validation analyses ;          
	      + subdlg ('start_x[4]' + 25) ('start_y[4]'+ 150) 120 20 Define Settings ;
				   290 330 550 400 Sensitivity/Leave-one-out validation ;


							 choose guichsensit 11 230 400 25 Evaluate different K values ( Implied Weighting only )
										 + spin 1 50 kmax 205 255 60 20 To 
										 spin 1 50 kmin 35 255 60 20 From 
										 spin 2 15 nconds 350 255 100 20 N? of k values ;
										 =
								    11 280 400 25 Choose parameters (Maximum Likelihood only)    
								     + check space_sensit  20  310 140 20 Global state space ;
								     check unlinked_sensit 180 310 200 20 Linked model ; = 
									  11 160 400 25 Read conditions from file ; 
										 + gettxt setting_file 40 185 320 20 ;=

							 choose dosensit 11 10 300 20 Run Sensitivity analysis 
							 11 35 300 20 Run Leave-one-out validation analysis
							 11 60 300 20 Run Sensitivity and Leave-one-out validation  analyses ;
							 check docross_w_tgt 11 90 400 20 Use char. sampling of target species (If selected) in Leave-one-out validation ;
							 showtxt 11 120 400 20 Select D value for Leave-one-out validation  analysis ;
                                                            choose guicherr_cross 30 140 60 20 Min.
					                                       90 140 60 20 Mean 
			                                                       150 140 60 20 Max. ;	 
 
	      closedlg ; =


	  frame 'start_x[1]' 'start_y[1]' 'ancho[1]' 'alto[1]' ; 
	  
	    showtxt ('start_x[1]' + 8) ('start_y[1]'+ 10) 150 20 Character Settings;
	    
	    choose active ('start_x[1]' + 12) ('start_y[1]'+ 30) 200 20 Define active characters
	     + charsel listchar ('start_x[1]' + 190) ('start_y[1]'+ 30) 150 20 ;=
	       ('start_x[1]' + 12) ('start_y[1]'+ 60) 230 20 Use activity defined in dataset file;  
	 frame 'start_x[3]' 'start_y[3]' 'ancho[3]' 'alto[3]' ; 
			     showtxt ('start_x[3]' + 8) ('start_y[3]'+ 10) 150 20 Character Analysis 
			     check dolist  ('start_x[3]' + 18) ('start_y[3]' + 22 ) 355 30 Display character scores for each placement of target species ; 
			      +  choose besever ('start_x[3]' + 30) ('start_y[3]' + 47 ) 320 30 Colors representing the largest score range  
				   ('start_x[3]' + 30) ('start_y[3]' + 70) 320 30 Colors representing the score range for each char./grp. of chars. ;
			      check dogrpchars ('start_x[3]' + 30) ('start_y[3]' + 93 ) 300 30 Repeat the analysis for each character partition  ;     

				   =  
	 frame 'start_x[5]' 'start_y[5]' 'ancho[5]' 'alto[5]' ; 
	     showtxt ('start_x[3]' + 8) ('start_y[3]'+ 133) 150 20 Error Analyses
	     check char_anal  ('start_x[3]' + 18) ('start_y[3]' + 150 ) 350 30 Calculate Error in Placement (EP) for the query dataset  ; 
	       + subdlg ('start_x[3]' + 30) ('start_y[3]'+ 180) 150 20 Define Settings ;
		      290 255 550 120 Dataset error settings  ;
	                check calc_prob   11  11 300 25 Calculate probabilities ;
	                showtxt 11 41 300 25 Select nodal distance to use calculate EP  ; 
	                    choose guicherr 50 61 60 20 Min.
			                    110 61 60 20 Mean 
			                    170 61 60 20 Max. ;	        
	         closedlg ; =
	     check clade_anal  ('start_x[3]' + 18) ('start_y[3]' + 205 ) 350 30 Calculate Errors for subtrees (ISE/OSE) ; 
	       +  subdlg ('start_x[3]' + 30) ('start_y[3]'+ 235) 150 20 Define Settings ;
	      		      290 255 550 80 Subtree error settings  ;
	     		      check doamb          11 14 300 25 Consider ambiguity in placement as error  ; 
	      	 closedlg ; =
	     check doerror_w_tgt  ('start_x[3]' + 18) ('start_y[3]' + 260 ) 350 30  Use char. sampling of target species ( if selected ) ;   
	     check doerror_w_grps ('start_x[3]' + 18) ('start_y[3]' + 285 ) 350 30  Repeat the analysis for each character partition  ;
	   
	   closedlg ; 
  set tokill 0 ; 
  if (!exstatus)
    set tokill  1; 
    silent - all ; quote Procedure cancelled ; silent = all;
    procedure / ;
  end 
 

resettime; 
proc/; 

label STRICT_MENU
  goto CHECK_POLYTOMY  ;
  /*tv > . ; 
  k 0 ;*/ 
  cls; 
  tplot ] ; 
  set alto[2] 'alto[2]' - 150  ;
  set start_y[0] 'start_y[0]' - 235  ; 
  set start_y[1] 'start_y[1]' - 180 ; 
  set start_x[1] 'start_x[4]' ; 
  set alto[4]  'alto[4]' - 60 ; 
  set altotot 'altotot' - 230 ; 
  set nopiwe 2  ;
 opendlg 50 50 'anchotot' 'altotot' Running analysis with multiple reference trees  ;
 	
 	 frame 'start_x[2]' 'start_y[2]' 'ancho[2]' 'alto[2]' ; 
 	 showtxt ('start_x[2]'+8) ('start_y[2]'+8) 300 25 Species Settings ; 
         	 showtxt ('start_x[2]' + 20) ('start_y[2]'+ 30) 350 20 Target species;
 	 choose notarget ('start_x[2]' + 30) ('start_y[2]'+ 50) 300 20 Select a target species  
	 	    +    taxsel listax ('start_x[2]' + 50) ('start_y[2]'+70) 150 20 ; = 
	                               ('start_x[2]' + 30) ('start_y[2]'+95) 300 20 Target species is absent in reference tree ;   
 	 check domodif ('start_x[2]' + 20) ('start_y[2]'+120) 300 20 Allow target species to modify relationships ; 

 	 frame 'start_x[0]' 'start_y[0]' 'ancho[0]' 'alto[0]' ; 
	 showtxt ('start_x[0]' + 8) ('start_y[0]'+ 8) 150 20 Output Settings ; 
	 check doprefix ('start_x[0]' + 20) ('start_y[0]'+ 28) 300 30 Define a prefix for output files ; 
	     +  gettxt prefix ('start_x[0]' + 30) ('start_y[0]'+ 57) 150 20     ;= 
	 showtxt ('start_x[0]'+20) ('start_y[0]'+ 85) 300 25 Palette for coloring ; 
	 choose do_palette ('start_x[0]' + 30) ('start_y[0]'+100) 300 20 Blue->Green->Red
	                   ('start_x[0]' + 30) ('start_y[0]'+120) 300 20 Inferno (Yellow->Violet)  ;  

 	  frame 'start_x[4]' 'start_y[4]' 'ancho[4]' 'alto[4]' ;
	 	    showtxt ('start_x[4]'+5) ('start_y[4]'+12) 250 25 Optimality Criterion ; 
	    choose nopiwe ('start_x[4]' + 12) ('start_y[4]'+ 55) 150 20 Implied Weighting
                    + subdlg ('start_x[4]' + 180) ('start_y[4]'+ 55) 120 20 Define settings ;
		     290 255 350 190 Implied Weighting Settings ; 
		     showtxt 7 7 290 15 Strength weighting against homoplasy ; 
		      choose guichval 11 38 11 11 . 
	                                     + spin 1 99 kkval 37 35 200 20 Defined by K value ;=
								  11 73 11 11 . ;
								  + spin 2 99 nval 37 70 200 20 Defined by N value ;=
							  closedlg ; = 
		('start_x[4]' + 12) ('start_y[4]'+ 80) 150 20 Maximum Likelihood (MK) 				  
		  	      + subdlg ('start_x[4]' + 180) ('start_y[4]'+ 80) 120 20 Define settings ;
								      290 255 360 220 Maximum Likelihood Settings ; 
								      check unlinked 11 20 200 21 Use unlinked model ; 
								      check mk_space 11 50 280 21 Use a different state space for each character ;
								      check doing_EPA 11 80 330 21 Show relative probabilities instead of diff. in logL (EPA approach) ;
							  closedlg ; =
		('start_x[4]' + 12) ('start_y[4]'+ 30) 150 20 Maximum Parsimony ;
		
		 frame 'start_x[1]' 'start_y[1]' 'ancho[1]' 'alto[1]' ; 
			  
			    showtxt ('start_x[1]' + 8) ('start_y[1]'+ 10) 150 20 Character Settings;
			    
			    choose active ('start_x[1]' + 12) ('start_y[1]'+ 30) 200 20 Define active characters
			     + charsel listchar ('start_x[1]' + 190) ('start_y[1]'+ 30) 150 20 ;=
			       ('start_x[1]' + 12) ('start_y[1]'+ 60) 230 20 Use activity defined in dataset file;  
	
		
		
		
closedlg ;
sil=all; 
if ('nopiwe' == 0 ) 
 if ('guichval' == 1) 
  goto CALCULATE_R ; 
 else
  if ('guichval' == 0)
  piwe = 'kkval' ;
  end 
 end 
end
if ('nopiwe' == 2 ) 
 set nopiwe  3 ;  
end
if ('nopiwe' == 1 ) 
 set nopiwe 2  ;
end

  set vamos 0 ; 
   /* nopiwe 0 = IW , 1 = Multiple Optimality criterion   2= LIKELIHOOD    3 = PARSIMONIA  ; */ 
 resettime ;
 set tokill 0 ; 
 if (!exstatus)
    cls ; clb ; tv- ; k0 ; 
    silent - all ; quote Procedure cancelled ;  
    set tokill 1 ; 
    proc / ;
 end 

 resettime; 
PROC/; 

label CHECK_POLYTOMY
 
 set resolved 0 ; 
 set ctos ntrees ; 
 tv > . ; 
 k 0 ; 
 loop=pp 0 'ctos'
        tv < #pp ;
        ra * ; 
	tv < #pp; 
	if (nnodes [0] != nnodes[1])
	     set resolved 1 ; 
	end
	k0  ;
 stop 	
 if ('resolved') 
    tv < . ;
    ra *; 
    tv- ; 
    tv > . ; 
    k 0; 
 end

proc/ ;





 
label COLOR_SENSITIVITY

report- ;
k 0 ; 
tvault < 0 ; 





if ('guichsensit' == 2 )
   hifile open $setting_file ; 
end
sil=all;

if ('nopiwe' == 1 ) 
  set nconds 0 ; 
  if ('piw_frm_mult' == 1 ) 
     set nconds ++ ; 
  end
  if ('pars_frm_mult' == 1 ) 
    set nconds ++ ; 
  end
  if ('mk_frm_mult' == 1 ) 
     lset speed 0.05 ldelta 0.01 bdelta 0.01 passes 40 40 ;
    set nconds ++ ; 
  end
  if ('nconds' == 0 ) 
     ra1 ; sil-all; tplot [ ; k0 ;  cls; 
     errmsg Multiple optimality option was selected but no optimality criterion is chosen ; 
    end
end
if ('dolik')
    set blue 0 ; set red 0 ; 
    lset speed 0.05 ldelta 0.01 bdelta 0.01 passes 40 40 ;
    if ( 'unlinked_sensit' ) 
      set blue 1 ;   
    end
     if ( 'space_sensit' ) 
       set red 1 ;  
     end
    if ( 'unlinked_sensit'  && 'space_sensit') 
        set nconds 4 ;
        set reduced_mk_sens 0 ;
    else
        set nconds 2 ;
        set reduced_mk_sens 1 ;
    end
end

/*sil-all; quote entro con nconds = 'nconds' ; sil=all; */



if ('nconds'<= 3) 
  set sizsq 30 ;
  set alturama 70 ; 
else
  set sizsq 24 ;
end
set larama 110 ;
if ( ('nconds' > 3) && ('nconds' < 9) ) 
   set alturama 100 ; 
end   
if ('nconds' >= 9 ) 
  set alturama 130 ; 
end 
if ( 'nconds' > 12 ) 
  set ccc ( 'nconds' / 3 ) ; 
  if ('ccc' * 3 < 'nconds' ) 
      set ccc ++ ; 
      macfloat 0 ;
      set ccc 'ccc' ; 
      macfloat 4 ; 
  end 
  set larama 'larama' + ( ('ccc' - 4 ) * 'sizsq') + 10 ; 
 
  macfloat 0 ; 
  set larama 'larama' ; 
  macfloat 4 ; 
end

 


set elmini 99999999 ;
set elmasi 0 ; 

loop=yy 0 nchar 
 set bak_listchar [#yy] 'listchar [#yy]' ; 
stop 

 
loop=cd 0 ('nconds'-1)
   sil=all ; 
   cc [ . ; 
         loop=jj 0 nchar 
         if ( 'listchar[#jj]' == 0 )
          cc ] #jj ;
         end  
   stop 
   if ( 'nopiwe' == 1 )  
     set doing_pars_frm_mult 0 ;
     set doing_mk_frm_mult 0 ;
     set doing_piwe_frm_mult 0 ;
     if ('pars_frm_mult' && !'done_pars' )
         set doing_pars_frm_mult 1 ;
         set done_pars 1 ;    
     else
      if ('piw_frm_mult' && !'done_piw' )
           set doing_piwe_frm_mult 1 ;
           set done_piw 1 ;
      else
        if ('mk_frm_mult' && !'done_mk' )
           set doing_mk_frm_mult 1 ;
           set done_mk 1 ;
       end   
    end
   end
   if ('doing_mk_frm_mult') 
        set dolik 1 ; 
   end
   if ('doing_pars_frm_mult') 
          set dolik 0 ; 
   end 
   if ('doing_piwe_frm_mult') 
          set dolik 0 ; 
          piwe = 'kkval' ; 
         end
   else
	      if ( !'dolik' )
			if ('guichsensit' == 2 )
			     set str_settings hiftext ; 
			     quote ncond 'nconds' ; 
			      quote condicion #cd string $str_settings ; 
			     $str_settings ; 
			 else
			    piwe = 'condic[#cd]' ; 
			end
	      else     /* sensit en ML */ 
		 if ('reduced_mk_sens' )
			     if ('space_sensit')
			       if (#cd == 0 ) 
				 lset nogstatespace ; 
			       else
				 lset gstatespace ; 
			       end
			    end 
			    if ('unlinked_sensit')
				if (#cd == 0 ) 
				    set doing_unlinked 0 ;
				 else
				   set doing_unlinked 1 ; 
				end
			    end 
		 else   /* las cuatro condiciones */ 
			    if (#cd < 2 ) 
				 lset nogstatespace ; 
			    else
				 lset gstatespace ; 
			    end
			    if ( (#cd == 0) || (#cd == 2) ) 
			         
				 set doing_unlinked 0 ; 
			    else
			        
			       set doing_unlinked 1 ; 
			    end
		 end 
	     end 
      end
      k 0 ; 
      tvault < 0 ;      
      force/&0; 
      constrain=; 
      col none ; 
      cc ] . ;
      mu 1 = ho 1 ;
      bb = fillonly ;
      if (ntrees >= 999 )
       tch 0.998 ; 
      end 
      cc [ . ; 
      loop=jj 0 nchar 
        if ( 'listchar[#jj]' == 0 )
       	  cc ] #jj ;
        end
      stop 
      if ('guichsensit' == 2 )
         $str_settings ; 
      end
      tvault>. ; 
      k0 ; 
      tvault<. ;
      constrain- ; 
      set mini_mult[#cd] 9999999 ; 
      set maxi_mult[#cd] 0 ; 
      if ('dolik' )
        goto CALCULATE_ML_REF ; 
     end
    loop=tr 1 ntrees 
      set opt_tree #tr ; 
      set bran sister [#tr 'tgtsp'] ; 
      if ( 'bran' > root )
            set bran_ref simgroup [ #tr 'bran' 0 ] ;
            if ( !'dolik' )
                     set  core_mult[#cd 'bran_ref'] score [#tr] ;
           else
               set core_mult[#cd 'bran_ref'] 0 ; 
               if ('doing_unlinked' )
              
                   loop=po 0 ('numchrgrp'-1)
                      cc ] . ; cc [ {#po} ; 
                      loop=er 0 nchar
                        if ( isinxgroup[#po #er] && 'listchar[#er]' == 0 ) 
                          cc ] #er ; 
                        end
                      stop
                      piwe-; 
                      set blue mklik [#tr] ; 
                      set core_mult[#cd 'bran_ref'] 'core_mult[#cd 'bran_ref']' + 'blue' ; ;
                  stop
                  cc [ . ; 
                  loop=jj 0 nchar 
                    if ( 'listchar[#jj]' == 0 )
                      cc ] #jj ;
                    end
                 stop 
              else
                 goto CALCULATE_ML ; 
                 set core_mult[#cd 'bran_ref'] 'elesco' ;
              end
         end
      else
        set bran_ref 'bran' ;
        if (!'dolik')
            set core_mult[#cd 'bran_ref'] score [#tr] ; 
       else
         set core_mult[#cd 'bran_ref'] 0 ;
          if ('doing_unlinked' ) 
                  loop=po 0 ('numchrgrp'-1)
			   maketable - ; 
			   cc ] . ; cc [ {#po} ; 
			   loop=er 0 nchar
				 if ( isinxgroup[#po #er] && 'listchar[#er]' == 0 ) 
				   cc ] #er ; 
				 end
			   stop
			   report- ; 
			   sil=all; 
			   rseed ; macseed ; 
			   piwe-; 
			   set blue mklik [ #tr ] ; 
			    sil=all; quote score condicion #cd de arbol #tr nodo 'bran_ref' grupo #po = 'blue'; sil=all; 
			    set core_mult[#cd 'bran_ref'] 'core_mult[#cd 'bran_ref']' + 'blue' ; 
		  stop 
                  cc [ . ; 
                  loop=jj 0 nchar 
                     if ( 'listchar[#jj]' == 0 )
                        cc ] #jj ;
                     end
                 stop 
                 sil=all; quote score condicion #cd total de arbol nodo 'bran_ref' 'core_mult[#cd 'bran_ref']' ; sil=all; 
         else
               goto CALCULATE_ML ; 
               set core_mult[#cd 'bran_ref'] 'elesco' ;
          end
      end
   end 
   if ('core_mult[#cd 'bran_ref']' < 'mini_mult[#cd]') 
            set mini_mult[#cd] 'core_mult[#cd 'bran_ref']' ; 
            set best #tr ; 
            set besnod 'bran_ref' ; 
   end
   if ('core_mult[#cd 'bran_ref']' > 'maxi_mult[#cd]') 
      set maxi_mult[#cd]  'core_mult[#cd 'bran_ref']' ; 
   end
 stop
 if ('maxi_mult[#cd]' > 'elmasi' )
       set elmasi 'maxi_mult[#cd]' ; 
 end
 if ('mini_mult[#cd]' < 'elmini' )
      set elmini 'mini_mult[#cd]' ; 
 end
   if ( 'nopiwe' == 1 ) 
        if ('doing_piwe_frm_mult') 
            if('doprefix')
                  set cond_string $_Opt_trees_IW.tre ; 
                  set int_string $$prefix $cond_string ; 
                 ts *$int_string ;
           else
                ts * Opt_trees_IW.tre ; 
           end
       else 
         if('doing_pars_frm_mult') 
            if('doprefix')
                set cond_string $_Opt_trees_MP.tre ; 
                set int_string $$prefix $cond_string ; 
                ts *$int_string ;
            else
               ts * Opt_trees_MP.tre ; 
           end
              else
                   if('doing_mk_frm_mult') 
                      if('doprefix')
		             set cond_string $_Opt_trees_ML.tre ; 
		             set int_string $$prefix $cond_string ; 
		             ts *$int_string ;
                        else
		          ts * Opt_trees_ML.tre ; 
                        end
                    end
                end
             end
         else   
           if('doprefix')
             set cond_string $_Opt_trees_condic#cd..tre ; 
             set int_string $$prefix $cond_string ; 
             ts *$int_string ;
           else
              ts *Opt_trees_cond#cd.tre ; 
           end
         end   
         set van 0 ; 
         loop=tr 1 ntrees 
           set bran sister [#tr 'tgtsp'] ; 
           if ('bran' > root)
              set bran_ref simgroup [ #tr 'bran' 0 ] ;
            else
               set bran_ref 'bran' ;
            end
            if ('core_mult[#cd 'bran_ref']' == 'mini_mult[#cd]')
             set van ++ ; 
             tch #tr ; 
              save ; 
           end
           k0 ;
           tvault<. ;
        stop 
       ts/; 
       tch 0 ; tvault - ; tvault>. ; 
       set blue sister [0 outgroup] ; /*New* para colorear el out */
       set core_mult [ #cd outgroup] 'core_mult[ #cd 'blue']'    ;  /*New*/
stop        
 
 
 
 
 
  set pivote sister[0 outgroup] ; /* esta es la rama que queda sin tag */ /*New*/
 
    
/* hasta aca cargue todos los scores minimos y maximos.. Ahora tengo que reenraizar y printear */ 

 reroot  * = 'pavote' ; /* pongo el enraizado original */ /*New*/
nak= ; 
tt- ; 

ttag * 0 ; 

loop=nd 0 'nds' 
  ttag < #nd ; 
stop 
set nds nnodes [0] ; 
loop=nd 0 'nds' 
 if ( (#nd == root) || (#nd == 'tgtsp') || (!isintree [0 #nd]) ) 
  continue ; 
 end
 if ( ('listax[#nd]' == 1) && (#nd < root) )
  continue ; 
 end 
 tt <#nd ; 
 ttag +#nd N#nd ; 
stop 


ttag & $output_sensit xysave eti bheight 'alturama' legup 15 txtsep 20 bfontsize 20 thickness 4  tfontsize 35 blength 'larama'  ; 
 

 loop=nd 0 'nds' 
     set ndtran 'trad_nd[#nd]' ; 
     if ('ndtran' == (-1) ) 
        set hermano sister [ 0 #nd] ;   
        continue ;
    end
 stop         
        
    
       
loop=cd 0 ('nconds'-1)     
         
        set coras ntrees ; 
        if ('nconds' < 7) 
                set limB 5 ;
                set limA 2 ; 
                set sizsq 30 ;
        else
            set sizsq 24 ;
            if ( 'nconds' < 13)
              set limB 7 ;
              set limA 3 ;         
           else
              set ccc ( 'nconds' / 3 ) ; 
                if ('ccc' * 3 < 'nconds' ) 
                    set ccc ++ ; 
                    macfloat 0 ;
                    set ccc 'ccc' ; 
                    macfloat 4 ; 
              end 
              set limA 'ccc' - 1 ; 
              set limB ('ccc' *2 ) - 1 ; 
            end 
       end 
       if (#cd > 'limB' ) 
            set suma_y 'sizsq' * 2 ;
            set suma_x 'sizsq' * (#cd - ('limB' + 1 )) ;
       else 
          if (#cd > 'limA' )
                    set suma_y 'sizsq' ;
                    set suma_x 'sizsq' * (#cd - ('limA' + 1 )) ; 
          else
                  set suma_x 'sizsq' * #cd ; 
                   set suma_y 0 ; 
          end
       end 
      
       set span 'maxi_mult[#cd]' - 'mini_mult[#cd]' ; 
       set miti 'mini_mult[#cd]' + ('span'/2) ; 
       set uncuar 'mini_mult[#cd]'+ ( 'span' / 4 ) ;
       set trescuar 'mini_mult[#cd]' + ( (3 * 'span') / 4 );
       
       set trescuarI 'maxi_mult[#cd]'+ ('maxi_mult[#cd]'-'uncuar' )  ; 
       set mitiI   'maxi_mult[#cd]' + ('maxi_mult[#cd]'-'miti' )  ; 
       set uncuarI   'maxi_mult[#cd]' + ('maxi_mult[#cd]'-'trescuar' )  ;
       set maxiI    'maxi_mult[#cd]' + ('maxi_mult[#cd]'- 'mini_mult[#cd]' )  ;
       
       if ('do_palette')
       	    set pace ('span' / 20 );  
       	     set mini 'mini_mult[#cd]' ; 
            goto FILL_COLIM ; 
        end 
       loop=nd 0 'nds' 
          set ndtran 'trad_nd[#nd]' ; 
          if ('ndtran' == (-1) ) 
               continue ;
          end
          if ( (#nd == root) || (#nd == 'tgtsp') || (!isintree [0 #nd]) ) 
             continue ; 
          end
          if ( ('listax[#nd]' == 1) && (#nd < root) )
             continue ; 
          end 
         if ( 'maxi_mult[#cd]' == 'mini_mult[#cd]') 
             set blue 130 ; set green 130 ; set red 130 ; 
         else
             if (!'do_palette')
                 set elsco   'maxi_mult[#cd]' + ( 'maxi_mult[#cd]' - 'core_mult[#cd 'ndtran']' ) ;  
                 if ('elsco' < ( 'uncuarI') ) ; /*240,5,5 a  254,240,1 */ 
		      set red   (254 - ( (254-240)  *  (( 'uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
		      set green (240 - ( (240-5)  *   (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
		      set blue  (1 +   ( (5-1)  *     (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )))    ;   ;   
		  else
			     if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) ) 
				set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
				set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
				set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
			     else
				     if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )  
					set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
					set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
					set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
				     else   /*18,232,232 a 55,55,148*/
					set red    ( 55  - ( (55-18)  *    (( 'maxiI' - 'elsco' ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
					set green  ( 55  + ( (232-55)  *   (( 'maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
					set blue   ( 148 + ( (232-148)  *  (( 'maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
				      end
			      end
		  end
	     else
	        set micore 'core_mult[#cd 'ndtran']' ; 
	        goto SETTING_COLORS ; 
           end
	  end	  
          set pos_x ('eti[#nd 0]' - 'eti[anc[0 #nd] 0]')/ 12 + 'eti[anc[0 #nd] 0]' + 'suma_x' ; 
          set pos_y 'eti[#nd 1]' + 4 + 'suma_y'; 
          sil=all  ; quote micore 'micore' blue 'blue' red 'red' green 'green' span 'span' ; sil=all;  
          if (('dosensit' == 1 ) || ('dosensit' == 2 ))
                 set redsiz 'sizsq' -2 ; 
                 if (#cd == 'bespos') 
                    ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'redsiz'&34&32height=&34 'redsiz'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:black&34 /> &10 ;sil=all; 
                    set bescuare [#nd 0 ] 'red' ; set bescuare[#nd 1] 'green' ; set bescuare[#nd 2] 'blue'; set bescuare [#nd 3] 'pos_x' ;  set bescuare [#nd 4] 'pos_y' ;  
                 else
                    ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'redsiz'&34&32height=&34 'redsiz'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:none&34 /> &10 ;sil=all; 
                 end
           else
              ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:none&34 /> &10 ;sil=all; 
           end
          set pos_y 'pos_y' + 22 ; 
	  set pos_x 'pos_x' + 11 ; 
	  set bescuare [#nd 5 ] 0 ; 
          if (('core_mult[#cd 'ndtran']'== 'mini_mult[#cd]') &&   ('maxi_mult[#cd]' != 'mini_mult[#cd]')  ) 
	            ttag &+ write <text x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32 font-size=&34 14&34&32 > * </text> &10 ; 
	            set bescuare[#nd 5] 1 ; 
          end 
          if (#nd == 'hermano' ) 
                set nod sister [ 0 'hermano'] ; 
                sil-all; quote nd #nd  nod 'nod' hermano 'hermano' red 'red' green 'green' blue 'blue' ndtran 'ndtran'; sil=all;  
          	     set pos_x ('eti['nod' 0]' - 'eti[anc[0 'nod'] 0]')/ 12 + 'eti[anc[0 'nod'] 0]' + 'suma_x' ; 
		     set pos_y 'eti['nod' 1]' + 4 + 'suma_y'; 
		     if (('dosensit' == 1 ) || ('dosensit' == 2 ))
			 set redsiz 'sizsq' -2 ; 
			 if (#cd == 'bespos') 
			    ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'redsiz'&34&32height=&34 'redsiz'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:black&34 /> &10 ;sil=all; 
			    set bescuare ['nod' 0 ] 'red' ; set bescuare['nod' 1] 'green' ; set bescuare['nod' 2] 'blue'; set bescuare ['nod' 3] 'pos_x' ;  set bescuare ['nod' 4] 'pos_y' ;  
			 else
			    ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'redsiz'&34&32height=&34 'redsiz'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:none&34 /> &10 ;sil=all; 
			 end
		     else
		      ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:none&34 /> &10 ;sil=all; 
		     end  
                     set bescuare ['nod' 5 ] 0 ; 
          end
          set pos_y 'pos_y' + 22 ; 
          set pos_x 'pos_x' + 11 ; 
          set bescuare [#nd 5 ] 0 ; 
          if (#nd == 'nod' ) 
            set  bescuare['nod' 5] 0 ; 
            if ('core_mult[#cd 'ndtran']'== 'mini_mult[#cd]') 
               set  bescuare['nod' 5] 1 ; 
               ttag &+ write <text x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32 font-size=&34 14&34&32 > * </text> &10 ; 
            end
         end 
  stop
  loop=yy 0 nchar 
     set listchar [#yy] 'bak_listchar [#yy]' ; 
  stop 
stop
 

 
 









log/; 


progress/; 

set dist 0 ; 

loop 0 (nnodes [0]) 
  if ('eti [#1 1]' > 'dist')
    set dist 'eti [#1 1]' ; 
  end
stop 


set posx 'dist' +120 ; 
lquote [ ; 
ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 24&34 >Optimal</text>&10 ; 
ttag&+ write <text&32x=&34 500 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 24&34 >Sub-optimal</text>&10 ; 
  
  set span 'elmasi' - 'elmini' ; 
  set shift 'elmini' ; 
  set shoft 'elmasi' ; 
  set mit ('span'/2) ; 
  set uncua ( 'span' / 4 ) ;
  set trescua ( (3 * 'span') / 4 ) ;
  macfloat 2 ; 
  macfloat 10; 
 
 set dist 'posx' + 10 ; 

if (!'do_palette')     

	 ttag&+ write <defs>&10<linearGradient&32id=&34graa&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(240,5,5).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 460&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35graa)&34 />&10 ;

	 ttag&+ write <defs>&10<linearGradient&32id=&34grab&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 310&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grab)&34 />&10 ;

	 ttag&+ write <defs>&10<linearGradient&32id=&34grac&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(18,232,232) .,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 160&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grac)&34 />&10 ;

	 ttag&+ write <defs>&10<linearGradient&32id=&34grad&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(55,55,148).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(18,232,232).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 10&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grad)&34 />&10 ;
else
     set tancia 10 ; 
       loop=uup 0 19
         ttag&+ write <rect x=&34 'tancia'&34 &32y=&34 'dist'&34 &32width=&34 30&34&32 height=&34 30&34&32 style=&34fill:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]')&59 stroke:none&34 />&10 ;
         
         set tancia 'tancia' + 30 ; 
   stop   

end


set pos_x ('dist' + 70) ; 
set tgtname $$taxon 'tgtsp' ; 
ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'pos_x' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 >Target Species=&32 $tgtname </text>&10 ; 


set pos_x ('dist' + 110) ; 
ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'pos_x' &34 &32stroke-width=&34 1&34&32 font-size=&34 22&34 > * </text>&10 ; 
set pos_x ('dist' + 105) ; 
if('nopiwe' == 1 ) 
  ttag&+ write <text&32x=&34 30 &34 &32 y=&34 'pos_x' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Optimal placement for the criterion </text>&10 ; 
else
   ttag&+ write <text&32x=&34 30 &34 &32 y=&34 'pos_x' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Optimal placement for the condition </text>&10 ; 
end

set posx 'pos_x' + 30 ;
if('nopiwe' == 1 ) 
    ttag &+ write <text&32x=&34 10 &34 &32 y=&34 'posx'&34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Criteria </text>&10 ; 
else
    ttag &+ write <text&32x=&34 10 &34 &32 y=&34 'posx'&34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Conditions </text>&10 ; 
end
set posx 'posx' +20 ; 
loop=cd 0 ('nconds'-1)
 if ('nconds' < 7) 
  set limB 5 ;
  set limA 2 ; 
 else
  if ( 'nconds' < 13)
   set limB 7 ;
   set limA 3 ;          
  else
   set ccc ( 'nconds' / 3 ) ; 
         if ('ccc' * 3 < 'nconds' ) 
           set ccc ++ ; 
           macfloat 0 ;
           set ccc 'ccc' ; 
           macfloat 4 ; 
    end 
    set limA 'ccc' - 1 ; 
    set limB ('ccc' *2 ) - 1 ; 
  end 
 end 
 if (#cd > 'limB' ) 
                 set suma_y 23 * 2 ;
                 set suma_x 23 * (#cd - ('limB' + 1 )) ;
         else 
         if (#cd > 'limA' )
                set suma_y 23 ;
                set suma_x 23 * (#cd - ('limA' + 1 )) ; 
         else
                set suma_x 23 * #cd ; 
          set suma_y 0 ; 
         end
         end 
 set pos_x 'suma_x' + 5 ;
 set pos_y 'suma_y' + 'posx' ;
 ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 22&34&32height=&34 22&34&32style=&34fill:white&59 stroke:black&34 &32stroke-width=&34 0.1&34 /> &10 ;sil=all ; 

 set dde #cd ;
 set pos_x 'pos_x' + 5 ; set pos_y 'pos_y' + 14 ; 
 ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > 'dde' </text>&10 ; 
stop

if (('dosensit' == 1 ) || ('dosensit' == 2 ))
 set pos_y ('pos_y' + 20) ; 
 ttag &+ write <rect x=&34 5&34&32y=&34 'pos_y' &34&32width=&34 16&34&32height=&34 16&34&32style=&34fill:white&59 stroke:black&34 /> &10 ;sil=all; 
 set pos_y ('pos_y' + 13) ; 
 ttag&+ write <text&32x=&34 30 &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 >Condition selected by Leave-one-out validation approach</text>&10 ; 
end
set dde 0 ; 
if ('nopiwe' == 1 ) 
 if ('pars_frm_mult') 
  set pos_y ('pos_y' + 25) ; 
  ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Condition 0 = Maximum Parsimony </text>&10 ; 
  set dde 1 ; 
 end
 if ('piw_frm_mult') 
 if ('dde' == 0 )
  set pos_y ('pos_y' + 20) ; 
  ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Condition 0 = Implied Weighting </text>&10 ; 
  set dde 1 ; 
 else
  set pos_y ('pos_y' + 20) ; 
  ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Condition 1 = Implied Weighting </text>&10 ; 
  set dde 2 ; 
 end
 end
 if ('mk_frm_mult') 
  if ('dde' == 0 ) 
  set pos_y ('pos_y' + 20) ; 
  ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Condition 0 = Maximum Likelihood </text>&10 ; 
  set dde 1 ; 
  else
  if ('dde' == 1 )
   set pos_y ('pos_y' + 20) ; 
   ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Condition 1 = Maximum Likelihood </text>&10 ; 
  else
   set pos_y ('pos_y' + 20) ; 
   ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Condition 2 = Maximum Likelihood </text>&10 ; 
  end 
  end
 end
end 
if ('guichsensit' == 2 )
 hifile close ;
end
ttag & ; 
k 0 ; 
proc/; 






label TAX_SETS 
k 0 ; 
tv < . ; 
tv- ; 
set ause 0 ; 
set nuabs 0 ; 


set red ((ntax * 125 )+ 300);  
tplot = <2 /30  >1000 \'red'  ; 




if (ntrees == 0 )
	loop 0 ntax     /* chequea cuantos ausentes hay en el arbol */ 
	     if (!isintree [0 #1 ])  
		 set ause ++ ;
		 set nosta['nuabs'] #1 ; 
		 set guichsp #1 ; 
		 set nuabs ++ ;
	     end
	stop 
	/*if ('notarget' != 2 ) 
	    set nosta['nuabs'] 'tgtsp' ;
            set nuabs++ ; 
	end*/
	
	if ('ause' > 1 ) /* si hay mas de un ausente en el arbol ya es multisp */ 
	   set multisp 1 ; 
	end
	
	if ( ('chssp' == 2 ) &&  ('nuabs' > 1 )  ) 
	   ra1; sil-all; tplot [ ; k 0; tv - ;  cls; 
	   errmsg The option /No additional query species/ was selected but several species are missing from the tree. Please select the option / Absent in reference tree / or include these species in the reference tree  ;
	end
	
	
	
	/* si no eligio ni target ni aditional query */ 
	if ( ( ('notarget' == 2)  && ('chssp' == 2 ) ) &&  (!'clade_anal') && (!'char_anal') ) 
		ra1; sil-all; tplot [ ; k 0; tv - ;  cls; 
		errmsg Neither target nor additional query species were selected. Only EP and Subtree Error analyses can be conducted  ;
	end
	
	/* si indico que los queries no estan en el arbol y el arbol esta completo*/ 
	if ( ( 'chssp' == 1 ) && ('ause' ==  0 ) && ( 'notarget' == 2 )  )
		   ra1; sil-all; tplot [ ; k 0; tv - ;  cls; 
		   errmsg The reference tree is complete. Please select target/query species    ;
	end


       /* si eligio tgt como ausente del arbol y el arbol tenia mas de una ausente o cero ausente. Si hay un solo ause la defino como tgtsp */ 
	if ( ( 'notarget' == 1 ) )  
	    if ('ause' > 1 ) 
		   ra1; sil-all; tplot [ ; k 0; tv - ; cls ;   
		   errmsg More than one species absent from reference tree. The target species cannot be defined  ;
	    end
	    if ('ause' == 0 ) 
		       ra1; sil-all; tplot [ ; k 0; tv - ;  cls; 
		       errmsg The reference tree is complete. Please select a species as target  ;
	    end
	    if ('ause' == 1 ) 
	       set tgtsp  'guichsp' ;
	       set listax['guichsp'] 1 ; 
	    end
	end 
	
       /* Define la tgt desde el nombre introducido o da un error si no aparece. Prunea la especie del arbol */ 
	set mini 0 ; 
	if ( 'notarget'  == 0 ) 
		    loop 0 ntax
		       if (eqstring [ $taxon #1 $tgtname ] ) 
			  set tgtsp #1 ; 
			  set mini 1;
			  if (isintree [ 0 #1])  
			      prunt 0/#1 ;
			   end
			   set listax[#1] 1 ;
		       end
		    stop
		    if (!'mini')
			ra1  ; tplot [ ; k 0 ; report= ; cls; tv- ; 
			sil-all; errmsg Target species ($tgtname) is not in dataset.  ; 
		    end 
	end
	
	/* agrego a lista las especies ausentes del arbol  */ 
	 loop 0 ntax    /* se fija del arbol cuales no estan */ 
	    if (!isintree [0 #1 ]) 
	       set listax[#1] 1  ; 
	    end
	stop 
	
	
	/* PRUNEO LAS ESPECIES DEL ARBOL  y me fijo si son mas de 1 especie pruneada. ademas le sumo la tgtsp  */ 
	if ('chssp' == 0 )  /* si selecciono especies adicionales para ubicar */ 
	  loop 0 ntax     
		 sil=all; quote #1 'listax[#1]' ;  
		 if ( ('listax[#1]' ==  1)  && (isintree [0 #1 ])) 
		   prunt 0/#1;
		 end
	  stop 
	  set ause 0 ; 
	  loop=ww 0 ntax     
	      if ( 'listax[#ww]' ==  1) 
	        set ause ++ ; 
	      end  
	  stop
	end
	if ('ause' > 1 )
	   set multisp 1 ; 
	end
	 if (!isintree [ 0 outgroup ] ) 
		      ra1; sil-all; tplot [ ; k 0; tv - ;  cls; 
		      errmsg Outgroup species should be part of the backbone topology ; 
	end
	if ('domodif' && 'multisp' )
	     ra1; sil-all; tplot [ ; k 0; tv - ;  cls; 
	     errmsg Analysis with multiple query species cannot be run considering the option: / Allow target species to modify relationships / ; 
	end
	set blue 0 ; 
	loop=zz 0 ntax 
	   if  ( 'listax[#zz]' == 1 ) 
	      set blue ++ ; 
	   end
	stop 
	if ('blue' > 1) 
	  set multisp 1 ; 
	end

 
end 





if (ntrees > 0 )
              
              set vamos 0 ;
                    set blue ntax ; 
                    set red nnodes [0] ; 
                    set green nnodes [1] ;
                     sil-all ; quote notarget 'notarget' blue 'blue' green 'green' red 'red'; sil=all;  
                     if ('notarget' ) 
                         loop=lr 0 ntrees
	         	     if (  nnodes [#lr]  == (2 * ntax)  )
	         	         ra1; sil-all; tplot [ ; k 0; tv - ;  cls; 
	                     	 errms  Tree #lr is complete select a target species from the menu  ; 
		             end 	       
		             set blue  (( 2 * ntax)) - 1  ;
		             set red nnodes [#lr]  ; 
		             sil-all ; quote #lr blue 'blue'   red 'red'; sil=all; 
		             if (  ( nnodes [#lr] )  <  (( 2 * ntax) - 1 )     )
	                         ra1; sil-all; tplot [ ; k 0; tv - ;  cls; 
			     	 errms  Tree #lr has more than one species absent. A single query species can be placed with multiple reference trees  ; 
		             end
		             if (#lr == 0 )  
		               loop=pp 0 ntax
	                         if (!isintree [#lr #pp] )
	                           set tgtsp #pp ; 
	                         end
	                       stop
	                     else
	                        if (isintree [#lr 'tgtsp'] ) 
	                          ra1; sil-all; tplot [ ; k 0; tv - ;  cls; 
	                          errms  Trees have different composition. Imposible to define the target species  ; 
	                        end  
	                     end
	                     
	                 stop
	             else
			     loop 0 ntax 
				    if ( 'listax[#1]' == 1 ) 
				      set tgtsp #1 ;  
				      set vamos ++ ; 
				    end  
			      stop
			      if ( ( 'vamos' == 0)  && ( 'notarget' == 0 ) ) 
				   ra1; sil-all; tplot [ ; k 0; tv - ;  cls ; 
				  errms  No target species was selected  ; 
			      end
			      if ('vamos' > 1) 
				  ra1; sil-all; tplot [ ; k 0; tv - ;  cls ; 
				  errms  A single species can be chosen as query (target) when having multiple reference trees ('vamos' spp. were selected)   ; 
			      end 
			      loop 0 ntrees 
					if ( isintree [#1 'tgtsp'] ) 	
					   prunt #1/'tgtsp' ; 
					   set notarget 0  ; 
					end
			      stop
			     set dde 0 ; 
			     loop 0 ntrees  
				  set dde tsize [#1] ;  /* no es menos uno */ 
				  set blue ntax ;  /* es menos uno */ 
				  if ( ( ('dde'-1) ==  ntax )  && ( 'vamos' == 0 ) ) 
				     ra1; sil-all; tplot [ ; k 0; tv - ;  cls ; clb ; 
				     errmsg At least one reference tree (#1) is complete and no target species was seleted. Please select a target species in the menu ; 
				  end 
				  set blue ntax ; 
				  sil-all ; quote dde 'dde' vamos 'vamos' ntax 'blue' ;
				  if ('vamos' == 1 ) /* si habia tgt en la lista y la corte */  
				    if ( 'dde' <   ntax  ) 
					cls ; clb ; ra1; sil-all; tplot [ ; k 0; tv - ;  
					errmsg Reference tree (#1) lacks one or more species besides the target species. When dealing with multiple trees a single query species can be selected ; 
				    end
				 else  
				      if ( 'dde' <  ntax ) 
					 ra1; sil-all; tplot [ ; k 0; tv - ;  
					 errmsg Reference tree (#1) lacks two or more species  ; 
				     end
				 end
			    stop
			    if ('vamos' ==  0 ) 
				    loop=pp 0 ntax
				      if (! isintree [0 #pp ] )
					  set tgtsp #pp ; 
				       endloop 
				      end
				    stop  
				    loop=re 0 ntrees 
				      if ( isintree [#re 'tgtsp' ] )
					ra1; sil-all; tplot [ ; k 0; tv - ; cls;  
					errmsg Reference trees has different taxon composition. Target species cannot be defined  ; 
				      end
				    stop 
			     end  
                    end

		    loop 0 ntrees 
			if (!isintree [ #1 outgroup ] ) 
			    ra1; sil-all; tplot [ ; k 0; tv - ; cls ;  
			    errmsg Outgroup species should be part of the backbone topology ; 
			end
		   stop   
		   if ('dolik')
			     lset speed 0.05 ldelta 0.01 bdelta 0.01 passes 40 40 ;
			     if ('mk_space' )
			       lset nogstatespace ; 
			     end
			      if ('unlinked' ) 
			       set doing_unlinked 1 ; 
			     end
		   end
	 end 	   
		   
end
	

if ('notarget' == 1 ) 
  set notarget 0 ; 
end
if ('notarget' == 2 ) 
  set notarget 1 ; 
end
if ('chssp' == 0 ) 
  set chssp 1 ; 
end
if ( 'notarget' && 'domodif') 
     errmsg The option /Allow target species to modify relationships/ is only available when selecting a target species  ;
end


	

if (!'stricting') 
    goto CHECK_ROOTING ; 
    tv > 0 ;  /* ACA SE MANDA A VAULT EL ARBOL Q SE USAR DE ACA EN MAS   */ 
    k 0 ; 
else
   tv > . ; 
   k0 ;  
end

tv < 0 ; 
set justerr 0 ; 
if ( tsize [0] == ('ntax' + 1 ))
  if ('clade_anal' || 'char_anal' ) 
    set justerr 1 ; 
  else
      ra1; sil-all; tplot [ ; k 0; tv - ; cls ;  
    errmsg Reference tree is complete, no target species is selected. Only EP and Subtree Error analyses can be conducted  ;
  end
end
k0 ; 



proc/; 



label CHECK_ROOTING

/* aca defino cual es el nodo del arbol enraizado en out que corresponde al nodo raiz del original lo pongo en pivote
ademas lo ruteo en el out */

set raiz root ; 
set dientes deslist [ 0 'raiz'] ; 
set sszz listsize ; 
set van 0 ; 
set ogrup 999999 ; 
loop=sz 0 1  /* si uno de los dos es un terminal entonces va a ser el pivote */ 
  if ( 'dientes[#sz]' < root )
    set pivote 'dientes[#sz]' ;
    set ogrup 'dientes[#sz]' ; 
  else
    set van ++ ;  
 end 
stop
 
set blue 1 ; 
sil=all ; quote dientes[0]  'dientes[0]' dientes[1]  'dientes[1]' ; sil=all ; 
set green 0 ; 
sil=all; quote van 'van' ; sil=all; 
travtree + ; 
if ('van' == 2 )  /* si ninguno de los dos es terminal entonce pivote es el que tiene el out  */ 
   travtree  below 0 outgroup red 
       if ( 'dientes[0]' == 'red' ) 
          set pivote 'dientes[0]' ;
	  set blue 123456 ; 
    	  killtrav ;
       end
       set green++ ; 
    endtrav
    if ( 'blue' == 1)
       set pivote 'dientes[1]' ;   
    end
end

/*set desroot_noout 'pivote' ;  originalmente estaba solo esto */ 

set desroot_noout sister [ 0 'pivote' ] ;  

/*
if ('van' == 1 ) 
  set desroot_noout sister [ 0 'pivote' ] ;   
end
sil-all ; quote van 'van' pivote 'pivote' ; 
if ('van' == 1 ) 
  set desroot_noout sister [ 0 'dientes[0]' ] ;  esto lo agregue el 15/1 
else
  set desroot_noout 'pivote' ;
end
*/

set nod sister[ 0 'desroot_noout']  ;  /* TOCHANG INDICA EL NODO QUE DESAPARECE AL REENRAIZARLO CON LO CUAL ESTA BIEN QUE LO USE PARA INDICAR EL NODO QUE TENGO QUE CORREGIR CON SU HERMANO */ 
if ( 'trad_nd['desroot_noout']'  == (-1) ) 
   set tochang 'desroot_noout' ; 
else
   set tochang 'nod' ; 
end


copytree 0 ; 
reroot 1 ; /* RERUTEO EL ARBOL 1 CON EL OUTGROUP DE LA MATRIZ NO DEL ARBOL */ 

sil-all; 

/*set toinv grptogrp  1 0 ;   NO LO USO XQ NO ANDA CUANDO ESTA RUTEADO EN EL MEDIO en ndo #1 del arbol 1 se corresponde con el nodo toinv[#1] del arbol 0 */  
sil=all; quote nosize 'nosize' ; 


/* esto viene a reemplazar el grptogrp q no anda cdo hay root con mulitples outs */ 
loop 0 (nnodes [0]) 
  set toinv[#1] eqgroup [ 0 #1 1 ] ;
stop

/*
if ('ogrup' < 999999 )  
    set  toinv['ogrup']  (-1)  ;    agregado el 13/8/2024 para corregir cdo el out de la matriz es el mismo que el out en el arbol unica condicion q debe ser inv   
end*/


loop 0 (nnodes[0])
 sil=all; quote NEW toinv[#1] 'toinv[#1]' ; 
stop


 
set pavote eqgroup [ 0 'pivote' 1 ] ; /*a donde deberia reenraizar el arbol para que quede como el original */ 

sil=all; quote ANTES pivote 'pivote' pavote 'pavote' ; 
if ('pavote' == (-1) ) 
 set pavote eqgroup [ 0 sister[ 0 'pivote'] 1 ] ;
end


sil=all; quote pivote 'pivote' pavote 'pavote' ; 
 
/* el cero es el original , el uno ruteado en outgroup */ 

ttag= ; 
nak- ; 
tp 1 ; /* sobre el arbol enraizado en out le imprimo sus nodos */ 
sil=all ; quote 'pavote' ;  
 tt; 
 


if ('pavote' != outgroup ) 
 rer  * =  'pavote' ;    /*      enraizo el arbol 1 en el nodo del original   */
end

tt; 


loop 0 (nnodes [0]) 
    if ( eqstring[ X$ttag #1 X ] ) 
       set trad_nd[ #1 ] (-1) ; 
    else 
      set trad_nd[#1]  ( $ttag #1 ) ;   
    end
   sil=all; quote nodo #1 'trad_nd[#1]' ; sil=all;  
stop  
 
 

k1 ; 



rer ; /*      enraizo en out   */
sil=all; quote pavote 'pavote' pivote 'pivote' ; 

tt- ; 
if ('char_anal' || 'clade_anal')
 		set prevout outgroup ; 
		loop 0 ntax 
				   if ( ( #1 != 'prevout') && ( isintree [ 0 #1] ))
					   set outrut #1 ; 
		                           endloop
				   end
		stop
		copytree 0 ; 
                outgroup 'outrut' ;  
		reroot 1 ;  
		/*set toinv_out grptogrp  1 0 ;  */
		loop 0 (nnodes [0]) 
		  set toinv[#1] eqgroup [ 0 #1 1 ] ;
                stop
		tt- ; 	
		ttag= ; 
		nak- ; 
		tp 1 ; 
		
		rer  * =  'prevout' ;    
				 
		loop 0 (nnodes [0]) 
		    if ( eqstring[ X$ttag #1 X ] ) 
		       set trad_nd_out[ #1 ] (-1) ; 
		    else 
		      set trad_nd_out[#1]  ( $ttag #1 ) ;   
		    end
		   sil=all; quote nodo #1 'trad_nd_out[#1]' ; sil=all;   
		stop  
		k1 ; 
	 
	k 1 ; 
        outgroup 'prevout' ; 
        rer ; 	
end
 

 

proc/; 





label CHAR_SETS

set hayconts 0 ;
loop 0 nchar
 if ( iscont[#1] )
 set hayconts 1 ; 
 endloop;
 end 
stop  

loop 0 nchar 
 set tgt_miss [#1] 0 ; 
stop 

set haylands 0 ; 

loop 0 nchar
 if ( islmark [#1] ) 
  lm rescale = * ; 
  lm f= 1 ; 
  lm term + ; 
  lm cel 6 nes 1 1 ; 
  set haylands ++ ; 
  endloop ; 
 end
stop 
set numchrgrp 0 ; 
loop 0 nchar  
 if ( charsingp[#1] == 0 ) 
  endloop ;
 else
  set numchrgrp++ ;
 end
stop 
 
 
   
    /* nopiwe 0 = IW , 1 = Multiple Optimality criterion   2= LIKELIHOOD    3 = PARSIMONIA  ; */ 
    /*sensato= 1 es cross o sensit */ 
    /* dosensit 0 = sensitivity ; 1= CV ; 2 CV y Sensit ; 3 compare optim criter */ 
    /* pars_frm_mult  piw_frm_mult mk_frm_mult */
    /* guichsensit 0 = k values ; 1= maximum Likelihood 2 = archivo settings */
  
 
 if  ( ( 'nopiwe' == 2 || ('mk_frm_mult' == 1 ) )  && ('haylands' ) ) 
      sil-all; ra1 ; tplot [ ; k0 ; report=; cls; 
      errmsg Maximum Likelihood analysis is not available for landmark data  ; 
 end
 if  ( ( 'nopiwe' == 2 || ('mk_frm_mult' == 1 ) )  && ('hayconts' ) ) 
       sil-all; ra1 ; tplot [ ; k0 ; cls; 
       errmsg  Maximum Likelihood analysis is not available for continuos characters ;  
 end
 
 
if  (( 'dogrpchars'  &&  'dolist' )  &&  ( 'numchrgrp' <= 1 ))
       sil-all; ra1 ; tplot [ ; k0 ; cls; 
       errmsg No partitions (character groups) defined in dataset. Scores for character partitions cannot be calculated ; 
end
 
 
if ( 'numchrgrp' <= 1 )
  if ( 'nopiwe' == 2 )
      if ( 'unlinked' || ('unlinked_sensit' && 'guichsensit' == 1) ) 
          sil-all; ra1 ; tplot [ ; k0 ; cls; 
          errmsg No partitions (character groups) defined in dataset. Unlinked ML score cannot be calculated ; 
      end
      set dogrpchars 0 ; set chg_dogrpchars 1 ; 
 end 
end
loop 0 nchar
 set check_grps[#1] 0 ; 
stop 

if ( (('numchrgrp' < 1) &&  'doerror_w_grps') ||  (('numchrgrp' < 1) &&  'dogrpchars')  )
     sil-all; ra1 ;  
     tplot [ ; k0 ; cls ; 
     errmsg Option to analyze partitions selected but no partitions (character groups) defined in dataset  ; 
end 


 
if ('dogrpchars' || 'doerror_w_grps' || (( 'unlinked' ) && ('nopiwe' == 2)) || ( 'unlinked_sensit' && 'guichsensit' == 1 ) )
 loop=te 0 nchar 
  loop=po 0 'numchrgrp' 
  if ( isinxgroup[ #po #te ] ) 
   set check_grps[#te]++ ; 
  end
  stop 
 stop  
 loop 0 nchar 
 if ( 'check_grps[#1]' == 0 ) 
   if ( ( ('nopiwe' == 2 ) && 'unlinked' ) || (( 'unlinked_sensit' && 'guichsensit' == 1 ) && ('nopiwe' == 2 )  ) ) 
   sil-all; ra1 ; tplot [ ; k0 ; cls; 
      errmsg Character #1 is not part of any character group. Unlinked model cannot be used ;
  else
   set nomeagrupes 1 ; 
  end
 end 
 if ('check_grps[#1]' > 1 ) 
  if (( ('nopiwe' == 2 ) && 'unlinked' ) || ( 'unlinked_sensit' && 'guichsensit' == 1 ) ) 
  sil-all; ra1 ; tplot [ ; k0 ; cls; 
   errmsg Character #1 is part of 2 or more character group. Unlinked model cannot be used ;
  else
   set nomeagrupes 1 ; 
  end
 end 
 stop 
end
if ( 'numchrgrp' < 1 ) 
  set nomeagrupes 1 ; 
end





set blue 0 ; 

if (!'active') 
 loop 0 nchar
 cc ] . ; 
 if ( 'listchar [#1]' != 0 ) 
  cc [ #1 ; 
 end
 stop
else
 loop 0 nchar
 if ( isact[#1] ) 
  set listchar [#1] 1 ; 
 else
  set listchar [#1] 0 ; 
 end
 stop
end
proc/; 


label COLORTREE
report- ;
sil=all; 
taxc + . ; 
if ('dolik')
    lset speed 0.05 ldelta 0.01 bdelta 0.01 passes 40 40 ;
   if ('mk_space' )
      lset nogstatespace ; 
    end
    if ('unlinked' ) 
      set doing_unlinked 1 ; 
    end
end



if ( (!'mult_w_target') && (!'domodif')  ) 
	   sil=all; 
	   k0 ; 
	   tvault < 0 ; 
	   rer ; 
	   force/&0; 
	
	   constrain=; 
	   col none ; 
	   cc ] . ;
	   mu 1 = ho 1 ;
	   bb = fillonly ; 
	   if (ntrees > 998 )
              tch 0.998 ; 
	   end
	
	   loop=ps 0 nchar 
	     if ('listchar[#ps]' == 1 ) 
	       cc [ #ps ; 
	     end 
	   stop 
	   tvault>. ;
	   k0 ; 
	   tvault<. ;
	   constrain- ; 
	   macfloat 10 ;
	   set mini 999999 ; 
	   set maxi 0 ; 
	   set dde ntrees + 1 ;
	   report- ; 
	   set sumLik 0 ;
	   if ('dolik') 
	     goto CALCULATE_ML_REF ; 
	   end
	    loop=rr 1 ntrees
		     set bran sister [#1 'tgtsp'] ; 
		      if (!'dolik' )  
				set elesco score [#rr] ;
			
		      else
			     set elesco 0 ; 
			     if ( 'doing_unlinked' )
				 loop=po 0 ( 'numchrgrp' - 1 )
				    cc ] . ; cc [ { #po } ;
				     loop=er 0 nchar
					   if ( isinxgroup[#po #er] && 'listchar[#er]' == 0 ) 
						   cc ] #er ; 
						 end
					   stop
					   piwe- ; 

					   set dde mklik [#rr] ; 
					   set elesco 'elesco' + 'dde' ;
					stop
					cc ] . ; 
					loop=ps 0 nchar 
					  if ('listchar[#ps]' == 1 ) 
					    cc [ #ps ; 
					  end 
				       stop 
			      else
				   set opt_tree #1 ; 
				   goto CALCULATE_ML ; 
			      end
		       end 	   
		    if ('bran' > root)
			     set bran_ref simgroup [ #1 'bran' 0 ] ;
			     set core['bran_ref'] 'elesco' ;
			     set coras 'elesco' ;
		    else
			   set bran_ref 'bran' ;
			   set core['bran_ref'] 'elesco' ; 
			   set coras 'elesco' ;
		    end 
		    if ('core['bran_ref']' < 'mini') 
			  set mini 'core['bran_ref']' ; 
			  set best #1 ; 
			  set besnod 'bran_ref' ; 
		    end
		    if ('core['bran_ref']' > 'maxi') 
			 set maxi 'core['bran_ref']' ; 
		    end
	   stop
	   if ('doing_EPA')
		 set maxi 0 ; 
		 macfloat 40 ; 
		 table /10 ; 
		 set sumLik 0 ; 
		 set mini_bk 'mini' ; 
		 set mini 1 ; 
		 set shift 'mini_bk' - 'mini' ; 
		 loop=lor 0 nnodes [0] 
		   if ((#lor == outgroup) || (#lor == root) || (#1 == 'tgtsp' ) || (!isintree [0 #lor]) )
		     continue ; 
		   end
		   set ladif ('core[#lor]' - 'shift') *(-1) ; 
		   set core[#lor] (power [ 2.7182818 'ladif' ] * 1000000 ); 
		   set sumLik 'sumLik' + 'core[#lor]' ; 
		 stop
		 loop=lor 0 nnodes [0] 
			  if ((#lor == outgroup) || (#lor == root) || (#1 == 'tgtsp' ) || (!isintree [0 #lor]) )
			   continue ; 
			  end
			  set core[#lor] (1 - ('core[#lor]' / 'sumLik')) ; 
			  if ('core[#lor]' > 'maxi' ) 
			   set maxi 'core[#lor]' ; 
			  end
		 stop
		 set mini 'core['besnod']' ; 
		 macfloat 10 ; 
	   end 
	   ts/; ts *$output_mpts ; 
	   set van 0 ; 
	   loop 1 ntrees 
		set bran sister [#1 'tgtsp'] ; 
		if ('bran' > root)
		 set bran_ref simgroup [ #1 'bran' 0 ] ;
	       else
		 set bran_ref 'bran' ;
	       end
	       if ('core['bran_ref']' == 'mini')
		   set van ++ ; 
		   tch #1 ; 
		   save ; 
	       end
	       k0 ; 
	       tvault<. ;
	    stop 
	    log/ ; 
	    ts/; 
	    k0 ; 
 
end

k0 ; 
tvault < 0 ;




set nds nnodes [ 0 ] ; 
ttag * 0 ;


set dde 0 ; 
set maxi_all 'maxi' ; set mini_all 'mini' ; 
sil=all; quote minia 'mini' maxi 'maxi' ; sil=all; 

set span 'maxi' - 'mini' ; set span_all 'span' ; 
set miti 'mini' + ('span'/2) ; set miti_all 'miti' ; 
set uncuar 'mini' + ( 'span' / 4 ) ; set uncuar_all 'uncuar' ; 
set trescuar 'mini' + ( (3 * 'span') / 4 ); set trescuar_all 'trescuar' ; 
set coras ntrees ; 

set trescuarI 'maxi' + ('maxi'-'uncuar' )  ; 
set mitiI   'maxi' + ('maxi'-'miti' )  ; 
set uncuarI   'maxi' + ('maxi'-'trescuar' )  ;
set maxiI    'maxi' + ('maxi - 'mini' )  ;


macfloat 10 ;
set violet 0 ;


if ('do_palette')
  set pace ('span' / 20 );  
  goto FILL_COLIM ; 
end  



set blue sister [0 outgroup] ;  
set core [outgroup] 'core['blue']'    ;
sil=all; quote core ['blue'] 'core ['blue']' ;   
set blue outgroup ;
sil=all; quote core [outgroup] 'core [outgroup]' ;   
 
 

loop=no 0 'nds'
  ttag <#no ; 
  if ( (#no == root)  ||  (#no == 'tgtsp')  ||  (!isintree [0 #no])  ) 
      continue ; 
  end 
  if ('mini' == 'maxi') 
      ttag +#1(0,0,0); 
      continue ; 
  end 
  set ccc 'core[#1]' - 'mini' ; 
  if ('ccc' == 0 )
	    set micore 'mini' ;
	    if ('do_palette')
	            goto SETTING_COLORS ; 
	    else
	            set red 55 ; 
	            set green 55 ;  
	            set blue  148 ;  
	     end  
	     macfloat 2 ; 
	     if (!'doing_EPA')
	       ttag +#1('red','green','blue');
	    else
	       macfloat 4 ;
	       ttag +#1('red','green','blue');
	    end
	    macfloat 10 ; 
  else
      if ('do_palette')
          set micore 'core[#no]' ; 
          goto SETTING_COLORS ; 
      else  
              set elsco   'maxi' + ('maxi' -'core[#no]' ) ; 
              sil=all; quote nodo #no elsco 'elsco' 'maxi'   'core[#no]'  ; 
    	      if ('elsco' < ( 'uncuarI') ) ; /*240,5,5 a  254,240,1 */ 
		      set red   (254 - ( (254-240)  *  (( 'uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
		      set green (240 - ( (240-5)  *   (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
		      set blue  (1 +   ( (5-1)  *     (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )))    ;   ;   
	      else
		     if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) ) /* 254,240,1  a 46,182,44) */ 
			set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
			set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
			set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
		    else
			 if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )  /*46,182,44 a 18,232,232*/
				set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
				set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
				set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
			 else   /*18,232,232 a 55,55,148*/
				set red    ( 55  - ( (55-18)  *    (( 'maxiI' - 'elsco' ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
				set green  ( 55  + ( (232-55)  *   (( 'maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
				set blue   ( 148 + ( (232-148)  *  (('maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;

			  end
		    end
	     end
	 
     end	     
     macfloat 2 ; 
     if (!'doing_EPA') 
         ttag +#1('red','green','blue'); 
     else
        macfloat 4 ; 
        set posy 1 - 'core[#1]' ; 
        ttag +#1('red','green','blue');
      end
      macfloat 10 ; 
  end
  
  macfloat 10 ;
stop
 

ttag & ;
 

if (root   > 50 )
   set larama 160 ; 
else
   set larama 140 ; 
end 
if ('clade_anal')
  set choram 100 ; 
else
  set choram 50 ; 
end


/* besnod esta definido como nodo ruteado con el out. Entonces tengo que traducirlo para poner el circulo */


/* voy a colorear los nodos de la base */ 

set pivote sister[0 outgroup] ; /* esta es la rama que queda sin tag */ /*New*/

 

reroot  * = 'pavote' ; /* pongo el enraizado original */ /*New*/
 
 
 
 
/*CODIGO PARA VOLVER A PONER EL COLOR EN LA RAMA QUE SE PIERDE AL REENRAIZAR */

sil=all; 
set dientes deslist[0 root ]  ; 
set queta $$ttag'dientes[0]';
quote $queta ; 
set - ;  
ttag +'dientes[0]'W; 

if (! eqstring [ $ttag'dientes[0]'  W  ]  )  /* el que tiene la info es 0 */ 
    set blue sister [0 'dientes[0]'] ;  /* el hermano del que tiene la etiqueta */ 
    set stri  $$queta  ;  /* La info que estaba en el tag de dientes[0]  */ 
    ttag < 'blue'  ;
       
    ttag +'blue' $stri; 
    ttag < 'dientes[0]'  ;
    ttag +'dientes[0]' $stri  ; 
else
    set blue 'dientes[0]' ;  
    ttag < 'blue'  ;
    set stri  $$ttag 'dientes[1]';
    ttag +'blue' $stri;
end
set sisou 'blue' ; 


/* SISOU ES EL NODO QUE PIERDE LA ETIQUETA */ 
 

if ('doing_EPA')
  set larama 140 ;
end

 /*ttag & $output_svg xysave eti bheight 70 legup 15 thickness 4 tfontsize 35 txtsep 20 bfontsize 28 blength 80 colors ; */
/*ttag & $output_svg xysave eti bheight 70 legup 15 thickness 4 tfontsize 35 txtsep 20 bfontsize 28 blength 80 colors ; */

 

ttag & $output_svg  xysave eti bheight 'choram' legup 15 txtsep 20 bfontsize 20  tfontsize 35 blength 'larama' thickness 4  colors ; /* bheight 120 */

  
 
set dist -99999 ; 

 

loop=no 0 'nds'
  set ndtran 'trad_nd[#no]' ; 
  ttag <#no ; 
  set nod #no ; 
  if ('sisou' == #no )/*SKIPPEO EL NODO QUE PIERDE EL TTAG XQ CREO QUE ES EL QUE NO TIENE CALCULADO EL SCORE */ 
      continue ;
  end  
  if ((#no == root)  || (#no == 'tgtsp') || (!isintree [0 #no]) ) /* saque q no haga el out */
     continue ; 
  end 
  set pos_x ('eti[#no 0]' - 'eti[anc[0 #no] 0]')/ 12 + 'eti[anc[0 #no] 0]' - 5  ; 
  set pos_y 'eti[#no 1]' - 8  ; 
  if ('mini' == 'maxi') 
    ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> Nd'nod'0 </text> &10 ; 
    continue ; 
  end
  set ccc 'core[ 'ndtran' ]'-'mini' ;   /* set ccc 'core[ #no ]'-'mini' ; */
  if ('ccc' < 0.00001 )
	     macfloat 2 ; 
	     set pos_y 'pos_y' - 10 ; 
	     if (!'doing_EPA')
	        /*ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'nod' &32 'mini' </text> &10 ;*/ 
	        ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'nod' &32 'mini' </text> &10 ;
	     else
	        macfloat 4  ;
	        set blue 1 - 'mini' ; 
	        ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'nod' 'blue' </text> &10 ;
	    end
	    macfloat 10 ; 
  else
     macfloat 2 ; 
     if (!'doing_EPA') 
         ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'nod'+'ccc' </text> &10 ;
         /*ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> +'ccc' </text> &10 ;*/ /*cambiar */ 
     else
       macfloat 4  ;
       set posy 1 - 'core[ 'ndtran']' ; 
       ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'nod' 'posy'  </text> &10 ;
      end
      macfloat 10 ; 
  end
  
  macfloat 10 ;
stop


/* ACA COPIO EL SCORE DE LA RAMA DESC DEL ROOT QUE TIENE UN VALOR Y LA COPIO A SU HERAMANA ASUMIENDO QUE EL NODO QUE PIERDE EL TTAG ES EL MISMO AL QUE NO LE CALCULO EL SCORE */ 
set red sister[ 0 'sisou' ]    ; 
if (!'doing_EPA) 
    set ccc 'core[ 'trad_nd['red']'  ]'-'mini' ; 
else
    set ccc 'core[ 'trad_nd['red']'  ]' ;
end
ttag <'sisou' ; 
set pos_x ('eti['sisou' 0]' - 'eti[anc[0 'sisou'] 0]')/ 12 + 'eti[anc[0 'sisou'] 0]' - 5  ; 
set pos_y 'eti['sisou' 1]' - 8  ; 
   if ('mini' == 'maxi') 
     ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> Nd'sisou'0 </text> &10 ; 
   end
  if ('ccc' < 0.00001 )
 	     macfloat 2 ; 
 	     set pos_y 'pos_y' - 10 ; 
 	     if (!'doing_EPA')
 	         ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'sisou' &32 'mini' </text> &10 ;
 	     else
 	        macfloat 4  ;
 	        set blue 1 - 'mini' ; 
 	        ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'sisou' 'blue' </text> &10 ;
 	     end
 	     macfloat 10 ; 
  else
       macfloat 2 ; 
       if (!'doing_EPA') 
          ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'sisou'+'ccc' </text> &10 ;
       else
          macfloat 4  ;
          set posy 1 - 'ccc' ; 
          ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'sisou' 'posy'  </text> &10 ;
       end
       macfloat 10 ; 
  end 

 


/* ACA EMPIEZA EL PRINTEO DE LAS REFERENCIAS */ 		

loop 0 nnodes [ 0] 
 if ('eti [#1 1]' > 'dist')
   set dist 'eti [#1 1]' ; 
 end
stop 
set dist 'dist' + 120 ; 
set posx 'dist' - 40 ; 
lquote [ ; 
ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Optimal</text>&10 ; 
ttag&+ write <text&32x=&34 500 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Suboptimal</text>&10 ; 

set posx 'dist' -15 ; 
 
  set span 'maxi' - 'mini' ; 
  set shift 'mini' ; 
  set shoft 'maxi' ; 
  set mit ('span'/2) ; 
  set uncua ( 'span' / 4 ) ;
  set trescua ( (3 * 'span') / 4 ) ;

if ('doing_EPA') 
  macfloat 4 ;
else
  macfloat 2 ; 
end
ttag&+ write<text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > 0 </text>&10 ; 
  if (!'doing_EPA') 
    ttag&+ write<text&32x=&34 160 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+'uncua' </text> &10 ; 
  else
    
    ttag&+ write<text&32x=&34 160 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>-'uncua' </text> &10 ; 
  end
  ttag&+ write<rect x=&34 158&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
  if (!'doing_EPA') 
    ttag&+ write<text&32x=&34 310 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+'mit' </text> &10 ; 
  else
    ttag&+ write<text&32x=&34 310 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>-'mit' </text> &10 ; 
  end
  ttag&+ write<rect x=&34 308&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
  if (!'doing_EPA') 
   ttag&+ write<text&32x=&34 460 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+'trescua' </text> &10 ; 
  else
   ttag&+ write<text&32x=&34 460 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>-'trescua' </text> &10 ; 
  end
 ttag&+ write<rect x=&34 458&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
 if (!'doing_EPA') 
    ttag&+ write<text&32x=&34 610 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+'span' </text> &10 ; 
  else
    ttag&+ write<text&32x=&34 610 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>-'span' </text> &10 ; 
  end  
  ttag&+ write<rect x=&34 608&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
if ('doing_EPA') 
  macfloat 10 ;
end
 
 set dist 'posx' + 10 ; 



if (!'do_palette') 
	 ttag&+ write <defs>&10<linearGradient&32id=&34graa&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(240,5,5).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 460&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35graa)&34 />&10 ;

	 ttag&+ write <defs>&10<linearGradient&32id=&34grab&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 310&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grab)&34 />&10 ;

	 ttag&+ write <defs>&10<linearGradient&32id=&34grac&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(18,232,232) .,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 160&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grac)&34 />&10 ;

	 ttag&+ write <defs>&10<linearGradient&32id=&34grad&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(55,55,148).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(18,232,232).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 10&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grad)&34 />&10 ;
else
   set tancia 10 ; 
   loop=uup 0 19
     ttag&+ write <rect x=&34 'tancia'&34 &32y=&34 'dist'&34 &32width=&34 30&34&32 height=&34 30&34&32 style=&34fill:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]')&59stroke:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]') &34 />&10 ;
     set tancia 'tancia' + 30 ; 
   stop   
   
end


set primero 0 ; 


set span_err 100 ; 
set miti_err ('span_err'/2) ; 
set uncuar_err ( 'span_err' / 4 ) ;
set trescuar_err ( (3 * 'span_err') / 4 );


/* ACA SE IMPRIMEN LOS CIRCULOS Y SI CORRESPONDE, EL ERROR */

loop=nd 0 nnodes[0] 
	 if ( (#1 == root) || (#1 == 'tgtsp') || (!isintree [0 #nd]) ) 
	   continue ; 
	 end 
	 if ( ( #1 < root) && ( 'listax [#nd]' == 1 ) ) 
	  continue ; 
	 end
	 set tancia ('eti [#1 0]' - 'eti [anc[0 #1] 0]' ) / 4 ; 
	 set posx 'eti [anc[0 #1] 0]' + ('tancia' * 3 )  ;
	 if ('clade_anal')
		  set posy 'eti[#1 1]' + 10 ; 
		  set tancia ('eti [#1 0]' - 'eti [anc[0 #1] 0]' ) ;
		  set miti 'eti [anc[0 #1] 0]' + ('tancia'/2) ; 
		  set dde 'tancia' /8 ; 
		  set px 'tancia' - ('dde' * 2) ; 
		  set limA 'eti [anc[0 #1] 0]' + 'dde' ;
		  set uncu 'px' / 8 ; 
		  set pos_y 'posy' + 30 ; 
		  set ref 'miti' + 'uncu' ; 
		  macfloat 7 ;
		  ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(255,255,255)&59 stroke:black&59&32 stroke-width:2&34 /> &10 ;

		  set blue 'posy' + 16 ; 
		  set red 'limA'    ; 
		  set elmasi 'red' - 2 ; 
		  set green 'blue' + 9 ; 
		  set dde 'green'  + 12 ; 
		  ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;
		  ttag&+ write <text&32x=&34 'elmasi' &34 &32 y=&34 'dde' &34 &32stroke-width=&34 1&34&32 font-size=&34 12&34 > 0 </text>&10 ;
		  set red 'limA' + ('px' / 4 )  ;
		  set limB 'red' - 2 ; 
		  set elmasi 'red' - 8 ; 
		  ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;


		  set red 'limA' + ('px' / 2 )  ;
		  set elmasi 'red' - 8 ; 
		  ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;
		  ttag&+ write <text&32x=&34 'elmasi' &34 &32 y=&34 'dde' &34 &32stroke-width=&34 1&34&32 font-size=&34 12&34 > .10 </text>&10 ;

		  set red 'limA' +  ('px'  * (3 / 4 ))  ;
		  set elmasi 'red' - 10 ; 
		  ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;


		  set red 'limA' +  'px'    ;
		  set elmasi 'red' - 14 ; 
		  ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;
		  ttag&+ write <text&32x=&34 'elmasi' &34 &32 y=&34 'dde' &34 &32stroke-width=&34 1&34&32 font-size=&34 12&34 > &62 .20 </text>&10 ;
                  /* 	ESTOY ASUMIENDO QUE PUEDO USAR desroot_noout PARA VER CUAL DE LOS NODOS DESCENDIENTES DEL ROOT DEBEN SER MODIFICADOS XQ NO ESTAN EN EL NUEVO RUTEADO
                  ES LO MISMO QUE USO AL IMPRIMIR LOS ERRORES EN EL ARCHIVO DE TEXTO*/   
                  if (#nd == 'desroot_noout' )
		   	set ndtran 'trad_nd[sister [ 0 'desroot_noout']]'   ;
		        set error   'false_neg['ndtran']' ;
		  else 
		       set ndtran 'trad_nd[#nd]' ; 
		       if ( 'toinv[#nd]' == ( -1 ) ) 
		           set error 'false_neg['ndtran']' ;
		       else
		           set error 'false_pos['ndtran']'  ; 
		      end
		 end  
                 if ('error' != 7777777 ) 
			     if ('error' > 20 ) 
				  ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(130,130,130)&59 stroke:black&59&32 stroke-width:2&34 /> &10 ;
			     else
			       set px 'px' * ( 'error' / 20 ) ;  
			       ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(130,130,130)&59 stroke:black&59&32 stroke-width:2&34 /> &10 ;
			     end 
		  else
		     ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(130,130,130)&59 stroke:black&59&32 stroke-width:2&34  /> &10 ;
		  end   
    	          set posy 'posy' - 2 ; 
	 end
	 if ( ('core['trad_nd[#nd]']' == 'mini') && ('mini' != 'maxi')) /*New*/
			   if ('trad_nd[#1]' == 'besnod' ) /*New*/
			          ttag &+ write <circle cx=&34 'posx'&34 &32cy=&34 'eti [#1 1]'&34 &32r=&34 18&34&32 fill=&34black&34&32 stroke=&34black&34&32 /> &10 ;
			   else
			         ttag &+ write <circle cx=&34 'posx'&34 &32cy=&34 'eti [#1 1]'&34 &32r=&34 14&34&32 fill=&34white&34&32 stroke=&34black&34&32 /> &10 ;
			   end
		           set primero ++ ; 
	 end
stop 
/* esto no deberia ir creo que ya lo solucione dentro del loop anterior  
if ('clade_anal')
	
	set nod sister[ 0 'desroot_noout']  ; 
	if ( 'trad_nd['desroot_noout']'  == (-1) ) 
	      set error 'false_neg[ 'trad_nd['nod']']' ;
	else
	      set error  'false_neg[ 'trad_nd['desroot_noout']'  ]' ; 
	end
	if ('error' != 7777777 ) 
	     if ('error' > 20 ) 
		  ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(130,130,130)&59 stroke:black&59&32 stroke-width:2&34 /> &10 ;
	     else
	       set px 'px' * ( 'error' / 20 ) ;  
	       ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(130,130,130)&59 stroke:black&59&32 stroke-width:2&34 /> &10 ;
	     end 
	else
	     ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(130,130,130)&59 stroke:black&59&32 stroke-width:2&34  /> &10 ;
	end 
end 
*/


 
set posx 'dist' +70 ; 
set tgtname $$taxon 'tgtsp'; 
ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Target Species=&32 $tgtname </text> &10 ; 

if ('primero' > 1 ) 
 set posx 'dist' +100 ; 
 ttag &+ write <circle cx=&34 20&34 &32cy=&34 'posx' &34 &32r=&34 9&34&32 fill=&34black&34&32 stroke=&34black&34&32 /> &10 ;
 set posx 'dist' +105 ;
 ttag&+ write <text&32x=&34 50 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Optimal placement used as reference for score calculation in character/partition chart </text>&10 ;
 set posx 'dist' +130 ; 
 ttag &+ write <circle cx=&34 20&34 &32cy=&34 'posx' &34 &32r=&34 9&34&32 fill=&34white&34&32 stroke=&34black&34&32 /> &10;
 set posx 'dist' +140 ;
 ttag&+ write <text&32x=&34 50 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Other optimal placements </text>&10 ;
else
 set posx 'dist' +97 ;
 ttag &+ write <circle cx=&34 25&34 &32cy=&34 'posx' &34 &32r=&34 9&34&32 fill=&34black&34&32 stroke=&34black&34&32 /> &10 ;
 set posx 'dist' +105 ;
 ttag&+ write <text&32x=&34 50 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Optimal placement </text>&10 ;
end
set posx 'dist' +135 ;
if ( ( 'nopiwe' == 1 ) && ( 'dosensit' == 1 ) ) 
 ttag&+ write <text&32x=&34 20 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Running conditions selected by Leave-one-out validation approach </text>&10 ;
end
if ('clade_anal')
 set posx 'dist' +170 ;
 ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Bars below branches represent In-Subtree-Error (ISE) </text>&10 ;
end 

ttag & ;



 
proc/; 

 


label CALCULATE_ML
 set ref_tree 0 ; 
 set onetocero grptogrp 'ref_tree' 'opt_tree' /'tgtsp' ;
 loop=dd 0 nnodes['opt_tree']
     set opt_mk_brlen[#dd]  'mk_brlen [ 'onetocero[#dd]']' ; 
 stop
 nak- ; 

/* sil-all; quote 'opt_tree' 'tgtsp' ; */ 
 set pos_one anc ['opt_tree' 'tgtsp'] ;
 set pos_cero sister['opt_tree' 'tgtsp'] ; 
 set opt_mk_brlen ['pos_one'] (-1) ;
 set opt_mk_brlen ['pos_cero'] (-1) ;
 set opt_mk_brlen ['tgtsp'] (-1) ;
 set pos_two anc ['opt_tree' 'pos_one']; 
 if ( 'pos_two' != root  )
  set opt_mk_brlen ['pos_two'] (-1) ;
 end
 report=; 
 lset display brlen ; 
 piwe- ; 
 set elesco fixlik [ 'opt_tree' opt_mk_brlen ] ; 
 report- ; 

proc/; 


label CALCULATE_ML_REF
         report=; 
	 lset display brlen ; 
	 maketable + mk_brlen ; 
	 piwe- ; 
	 set green mklik [0] ; 
	 maketable - ;
	 report-; 
	 lset display lik ; 
proc/; 



label SEARCHES
 
tvaul < 0 ; 

force/&0; 
k0 ; 
constrain =; 
nak=;  

if ('dolik')
 /* lset speed 0.5 ;*/
 lset speed 0.1 ldelta 0.08 bdelta 0.08 passes 10 10   ;    
 if ('mk_space' )
    lset nogstatespace ; 
 end
 if ('unlinked' ) 
    set doing_unlinked 1 ; 
 end
end
tt- ; 

if ( ('sensato' == 1 ) )
          if ('guichsensit' == 2)  
            hifile open $str_settings ; 
          end
          if ('dolik')
            set nconds 2 ; 
          end
	 loop 0 ('nconds'-1) 
	   if ('guichsensit' == 2 )
	      set ra hiftext; 
	      $ ; 
	   else 
	       piwe = 'condic[#1]' ;
	   end 
	   if (!'dolik')
		 mu 1 = ho 1 ; 
		 bb = fillonly ; 
		 if (ntrees >= 999 )
		  tch 0.998 ; 
		 end 
	   else
		set coloring 0 ; 
		goto SPR_LIK_CONSTRAIN ; 
	   end
	   reroot  * = 'pavote' ;
	   if ('guichsensit' == 2 )
	        if ('doprefix')
		  set cond_string $_Mpts_condic#1..tre ; 
		  set int_string $$prefix $cond_string ; 
		  ts *$int_string ; s ; ts/ 
	       else 
		  ts *Mpts_condic_#1.tre ; s ; ts/ ;
	       end 
	  else
	     if ('doprefix')
		  set cond_string $_Mpts_condic ; 
		  set int_string $$prefix $cond_string ; 
		  ts *$int_string ; s ; ts/ 
	     else
		  ts *Mpts_condic'condic[#1]'.tre ; s ; ts/ ;
		  
	       end 
	    end
	   k0 ;
	 stop 
         if ('guichsensit' == 2 )
            hifile close ; 
         end
else
    if (!'dolik')
         mu 10 = ho 3 ; 
         bb = fillonly ;
         if (ntrees >= 999 )
          tch 0.998 ; 
         end 
     else
         set coloring 0 ; 
         goto SPR_LIK_CONSTRAIN ; 
     end 
     if (ntrees == 0 ) 
       ttag * 0 ; 
       loop 0 nnodes [0]
           set yes 0 ; 
	   loop 0 ('nuabs'-1 ) 
	      if ('nosta[#2]' == #1) 
	           tt < #1 ; 
	           ttag +#1 (255,0,0);
	           set yes 1 ;
	           endloop ; 
	      end
	   stop
	   if ('yes') 
	     continue ; 
 	   end
 	   tt < #1 ; 
  	   ttag +#1  (0,0,0); 
       stop
    
      reroot  * = 'pavote' ; 
      ttag & $output_svg bheight 40 legup 10 txtsep 20 fontsize 20 blength 80 color ; 
      ttag & ;
  end
  reroot  * = 'pavote' ; 
  ts *$output_mpts ; s ; ts/ ; 
end
tt- ;
proc/; 

label CALCULATE_R
report- ;
 set round 0 ; 
 if ('nval' < 1.5)
   ra1 ; tplot [ ; sil-all; k0 ; 
   errms Error! N val = 'nval', give a weighing range value (N) larger than 1 ; 
 end 
 piwe < 'nval' ; 
 set kkval kval ; 
proc / ;

 

label CHAR_SCORES
 

report- ;

if ('dolik')
  /*lset speed 0.2 ldelta 0.01  bdelta 0.01 passes 30 30  ;  */
  lset speed 0.1 ldelta 0.08 bdelta 0.08 passes 10 10   ;   
 /* lset speed 0.1 ldelta 0.1  bdelta 0.1 passes 3 3  ;  */
 if ('mk_space' )
  lset nogstatespace ; 
 end
 if ('unlinked' ) 
   set doing_unlinked 1 ; 
 end
end

cc ] . ; 
loop=ps 0 nchar 
  if ('listchar[#ps]' == 1 ) 
  cc [ #ps ; 
  end 
stop 
lset display lik; 

loop=tr 1 ntrees
  set bran sister [#tr 'tgtsp'] ; 
  if ('bran' > root)
    set bran_ref simgroup [#1 'bran' 0 ] ; 
  else
    set bran_ref 'bran' ;
  end
  report= ; 
  if ('dolik')
    if (!'doing_unlinked') 
       report = ; 
      /* piwe- ; */
       maketable + mk_charscores ; 
       piwe-  ;
       set dde mklik [#tr] ; 
       maketable - ;
       loop=ch 0 nchar
         set charscore ['bran_ref' #ch] 'mk_charscores [#ch]' ;
         sil=all ; quote score #ch  'mk_charscores [#ch]' ; sil=all ;    
       stop 
          report- ;
    else
      loop=po 0 ('numchrgrp'-1)
          cc ] . ; cc [ {#po} ; 
          loop=er 0 nchar
             if ( isinxgroup[#po #er] && 'listchar[#er]' == 0 ) 
              cc ] #er ; 
             end
          stop
          report=; 
          piwe-; 
          maketable + mk_charscores ; 
          piwe -  ;
           set dde mklik [#tr] ; 
          maketable - ;
          report- ; 
          loop=ch 0 nchar
           if (isinxgroup[#po #ch])
             set charscore ['bran_ref' #ch] 'mk_charscores [#ch]' ; 
           end 
         stop 
       stop 
       cc ] . ; 
       loop=ps 0 nchar 
            if ('listchar[#ps]' == 1 ) 
             cc [ #ps ; 
            end 
      stop 
    end
  else
       loop=ch 0 nchar
         set charscore ['bran_ref' #ch] score [#tr #ch] ; 
       stop 
  end
 report-; 
stop 

macfloat 10 ; 
cc ] . ; 
loop=ps 0 nchar 
  if ('listchar[#ps]' == 1 ) 
     cc [ #ps ; 
  end 
  set charscore [outgroup #ps] 'charscore [sister[0 outgroup] #ps]' ; 
stop 


proc/; 
 
 
 
 

 label NODE_DISTANCE 

 set max_dist 0 ; 
 set min_dist 999999 ;
 set mean_dist 0 ; 
 set vamos 0  ;
 loop=rrr 0 ( ntrees-1 )
          set opt_tree #rrr ; 
 	  if (eqtrees [ 'opt_tree' 'ref_tree' ]) 
		  set pos_y 0 ; 
	  end
	  /*
	  agarro el arbol original y me fijo quien es su hermano.
	  agarro el arbol dde cayo y me fijo quien es su hermano
	  traduzco este hermano al nodo q corresponde en el original 
	  calculo los ancestros de ambos
	  calculo las distancias 
	  */
	
	   
	  
	  set red  sister  ['ref_tree' 'eltax'] ;
	  set pos_cero  anc ['ref_tree' 'red'] ; 
	  
	  set blue  sister ['opt_tree' 'eltax'] ;
	  set onetocero grptogrp 'ref_tree' 'opt_tree'  ;
	 /* loop=ee 0 nnodes [ 0] ; 
	    sil-all; quote #ee 'onetocero[#ee]'; 
	  stop */
	  sil=all; quote blue='blue' ;   
	  set nodo_trans 'onetocero['blue']' ; 
	  
	  if ('nodo_trans' != (-1) )
	    set pos_one anc ['ref_tree' 'nodo_trans'] ; 
	    set pos_y distnode [ 'ref_tree' 'pos_cero' 'pos_one' ] ;
          else
           set red  sister   ['opt_tree' 'eltax'] ;
 	   set pos_cero  anc ['opt_tree' 'red'] ; 
	   set blue  sister  ['ref_tree' 'eltax'] ;
	   set onetocero grptogrp  'opt_tree' 'ref_tree' ;
           set nodo_trans 'onetocero['blue']' ; 
           set pos_one anc ['opt_tree' 'nodo_trans'] ; 
	   set pos_y distnode [ 'opt_tree' 'pos_cero' 'pos_one' ] ;
        end
          
          /*quote: opt_tree 'opt_tree' ref_tree 'ref_tree' red='red' blue='blue' pos_one='pos_one'  pos_cero='pos_cero' nodo_trans 'nodo_trans' eltax 'eltax';  
	  quote: distancia 'pos_y' ; */
	  if ('pos_y' < 'min_dist') 
	    set min_dist 'pos_y' ; 
	  end
	  if ('pos_y' > 'max_dist') 
	    set max_dist 'pos_y' ; 
	  end
	   set mean_dist 'mean_dist'+ 'pos_y' ; 
	   set vamos ++ ; 
  stop
  set mean_dist 'mean_dist' / 'vamos' ;  

 proc/; 

 



 
label MULT_WITH_TARGET 

/* scores calculated using the tree rooted with the outgroup */ 

set mini 9999999999 ; 
set maxi 0 ; 
k 0 ; 
tt- ; 

tvault<0 ;
set nds nnodes [0] ;
if ('dolik')
   lset speed 0.1 ldelta 0.08 bdelta 0.08 passes 10 10   ;    
   if ('mk_space' )
       lset nogstatespace ; 
   end
end
set van 0 ; 



 
loop=nd 0 (nnodes[0]) 
        
         k 0 ; 
         tvault<0 ; 
         rer ; 

         if ((#nd == root) ||  (#nd == 'tgtsp') || (!isintree [0 #nd]) || (#nd == outgroup))
             continue ; 
         end
         set blue root ; 
         sil=all; edit 0 'blue' 'tgtsp' #nd ; 
         if (!'dolik')
                  force/&0; 
           
                  k 0 ; 
                  constrain=;
                  mu 100 = ho 1 ;
                  bb = fillonly ; 
                  if (ntrees >= 999 )
                   tch 0.998 ; 
                  end
                  set esco score[0] ; 
                  force ;
         else
                  set coloring 1 ; 
                  goto SPR_LIK_CONSTRAIN ; 
         end
      
         set core[#nd] 'esco' ;
         if ('esco' <= 'mini')
                  if ('esco' == 'mini')
                      save ; 
                      set van 'van' + (ntrees + 1) ; 
                  else 
                      set van (ntrees + 1) ; 
                      ts/; ts *$output_mpts ; save; 
                  end 
                  set mini 'esco' ; 
                  set besnod #nd ;
         end 
         if ('esco' > 'maxi' ) 
            set maxi 'esco' ; 
         end 
         tc 0 ; 
         if ('dolist') 
             if ('dolik')
                 report=; 
                 piwe- ; 
                 maketable + mk_charscores ; 
                 piwe- ; 
                 set dde mklik [0] ; 
                 maketable - ;
                 report-; 
            end
           report-; 
           loop=ch 0 nchar
                 if (!'dolik') 
                    set charscore [#nd #ch] score [0 #ch] ; 
                 else 
                    set charscore [#nd #ch] 'mk_charscores [#ch]' ; 
                 end
           stop
        end
stop

ts/; 
k0 ; 
if ('van' > 1 ) 
  set multree 1 ; 
else
 set multree 0 ; 
end
; 

naked=; 
k 0 ; 
tvault<0 ; 
rer ; 
loop=ps 0 nchar 
   set charscore [outgroup #ps] 'charscore [sister[0 outgroup] #ps]' ; 
stop 
k 0 ;
 
if ('multree' == 0 ) 
	  p $output_mpts ; 
	  ttag- ; 
	  ttag =; 
	  ttag *0 ; 
	  loop 0 nnodes [0]
		  set posy #1 ; 
		   if (#1 == outgroup )
		     ttags +'posy' (0,0,0) ; 
		      continue 
		   end 
		   set yes 0 ; 
		     
		  
		   loop 0 ('nuabs'-1 ) 
			   if ('nosta[#2]' == #1) 
				    ttag < #1 ; 
				    ttags +'posy' (255,0,0) ;
				    set yes 1 ;
				    endloop ; 
			   end
		   stop
		  if ('yes') 
		     continue ; 
		  end
		  ttag < #1 ; 
		  ttags +'posy' (0,0,0) ; 
		  if (#1 == 'tgtsp') 
		     ttag < #1 ; 
		     ttags +'posy' (255,0,0) ;
		  end 
	  stop

	  ttag &color_query.svg bheight 40 legup 10 fontsize 20 txtsep 20 blength 80 colors ; 
	  
	  ttag & ;
	  set did_colorquer 1 ; 
	  
	  
	  
end
k 0 ; 
proc/; 
 
 
 
 

label CROSSVALIDATION
k0 ; 
report- ;
tvault <0 ;
set dde nnodes [0] ;
 k0 ; 
lquote - ; 
set bestdis 999999999 ;

 if ('guichsensit' == 2 )
    sil-all; quote $setting_file  ;  
    hifile open $setting_file ; 
 end
 
set blue 0 ; set red 0 ; 

loop=cnd 0 ( 'nconds'-1 )
	  cc ] . ; 
	  loop=ps 0 nchar 
	     if ('listchar[#ps]' == 1 ) 
	        cc [ #ps ; 
	    end 
	  stop 
	  loop=yy 0 nchar 
	     set bak_listchar [#yy] 'listchar [#yy]' ; 
	  stop 
	  if (('docross_w_tgt') && (!'notarget') )
	    ra 1 ;
	    set guichsp 'tgtsp' ; 
	    goto MY_MISSING ; 
	    k0 ;  
	  end
	  if ( 'guichsensit' == 2 )
	    set str_settings hiftext ; 
	    sil=all ; quote ncond 'nconds' ; sil=all; 
	    $str_settings ; 
	 else
	     if (!'dolik')
	       set distri [#cnd ] 0 ; 
	       set k 'condic[#cnd]' ; 
	       piwe = 'k' ; sil=all; quote usando una concavidad de 'k' ; piwe; sil=all; 
	     end 
	 end 
	 ra 1 ;
	 loop=nn 0 nnodes [0] 
	  set van_lbl[#nn] 0 ; 
	 stop 
	 k 0 ; 
	 loop=ll 0 ntax 
	  if ( 'listax[#ll]' == 1 && ( #ll != outgroup) )
	    taxc - #ll ; 
	   end 
	stop
	set son 0 ; 
	/*nuevo*/ 
	tvault < 0 ;
	if (('doerror_w_tgt') && (!'notarget') ) 
	  set guichsp 'tgtsp' ; 
	  goto MY_MISSING ; 
	end 
        set test_grp 9999 ; 
	loop=hj 0 ntax 
	    set guichsp #hj ;
	     if ( ( 'guichsp' == 'tgtsp' ) || (!isintree [0 'guichsp']) )  /* saque de aca lo de outgroup ('guichsp' == outgroup) || */
	           continue ; 
	     end
	     set noda 0 ; 
	     goto MY_MISSING ; 
	     goto TEST_SPECIES_CHARSAMPLING ; 
        stop
	k0 ; 
 	loop=tx 0 ntax 
		  set prunne #tx ; 
		  tvault < 0 ; 
		  if ((#tx == root) || ( #tx == 'tgtsp' ) || (!isintree [0 #tx] ) ) /* saque de aca lo de outgroup  (#tx == outgroup) ||  */
		     continue ; 
		  end
		  if (#tx == outgroup ) 
		     loop=xx 0 ntax 
		       if ( (#xx != outgroup) && (isintree [0 #xx]))   
		          set outcross outgroup ;  
		          outgroup #xx ; 
		          rer ; 
		          endloop ; 
		        end
		    stop 
		  end 
		  if ('muymiss_sp[#tx ]' == 1 )
		  	   set nodo $$taxon #tx ; 
		  	   sil-file; quote $nodo(#tx)= Not analyzed (Missing data > 'limmis' ) &10; sil=all; 
		  	   continue ; 
	          end 
		  prunt 0/#tx ;
		  force /&0 ;
		  constrain = ; 
		  mu 1 = h 1 ;
		  bb ; 
		  tvault < 0 ;
		  rer ; 
		  set max_dist 0 ;
	          set eltax #tx ; 
	          set ref_tree ntrees ; 
	          goto NODE_DISTANCE ; 
	          set son ++ ; 
	          set nodo $$taxon #tx ; 
	          if ('guicherr_cross' ==  0 ) 
	            set distri[ #cnd ] 'distri[ #cnd ]' + 'min_dist' ;
	          end
	          if ('guicherr_cross' ==  1 ) 
		    set distri[ #cnd ] 'distri[ #cnd ]' + 'mean_dist' ;
	          end
	          if ('guicherr_cross' ==  2 ) 
		    set distri[ #cnd ] 'distri[ #cnd ]' + 'max_dist' ;
	          end
	          k 0 ;
	          loop=yy 0 nchar 
   	     	    set listchar [#yy] 'bak_listchar [#yy]' ; 
	          stop  
	          if (#tx == outgroup ) 
	           outgroup 'outcross' ; 
	           rer ; 
	          end
         stop
         
	 tv < 0 ; 
	 k0 ; 
	 report- ; 
	 set distri[#cnd  ] 'distri[#cnd  ]'/ 'son' ;
	if ('distri[#cnd  ]' < 'bestdis')
	    set bestdis 'distri[#cnd  ]' ;
	    set bespos #cnd ; 
	    set bescond 'condic[#cnd]' ; 
	 end 
	 
stop 
 
if ('guichsensit' == 2 )
  hifile close ; 
end
 

set multiopt 0 ; 
loop=cc 0 ('nconds'-1)
  if ('distri[#cc]' == 'distri['bespos']')
    set multiopt ++ ; 
  end
stop
if ('multiopt' > 1 )
 set multiopt 1 ;
else
 set multiopt 0 ; 
end

 
 if ('guichsensit' == 0 )
    piwe = 'bescond'; 
 else
   hifile open $setting_file ; 
   loop=ln 0 100
      set str_settings hiftext ; 
         if (#ln == 'bespos' ) 
           $str_settings ; 
      end
  stop 
  hifile close ; 
 end

sil=all; 
taxc + . ; 
proc/; 
 
 
 
 
label SENSIT_MULT_WITH_TARGET
k 0 ; 
report- ;
tt- ; 
tvault<0 ; 
set nds nnodes [0] ;

if ('guichsensit' == 2 )
 hifile open $setting_file ; 
end
loop=yy 0 nchar 
  set bak_listchar [#yy] 'listchar [#yy]' ; 
stop 

loop=cd 0 ('nconds'-1)
         cc [ . ; 
         loop=jj 0 nchar 
            if ( 'listchar[#jj]' == 0 )
               cc ] #jj ;
            end
         stop 
         set mini_mult[#cd] 9999999999 ; 
	set maxi_mult[#cd] 0 ; 
	if ('guichsensit' == 2 )
		set str_settings hiftext ; 
		quote ncond 'nconds' ; 
		quote condicion #cd string $str_settings ; 
		$str_settings ; 
	else
	   piwe = 'condic[#cd]' ; 
	end
	loop=nd 0 (ntax * 2 ) 
		  k 0 ; 
		  tvault<0 ; 
		  reroot ; 
		  if ((#nd == root) || (#nd == 'tgtsp') || (!isintree [0 #nd]) || (#nd == outgroup)  )
			continue ; 
		  end
		 sil=all; edit 0 'raiz' 'tgtsp' #nd ; 
		   
		 force/&0; 
		 k 0 ; 
		 constrain=; 
		 mu 1 = ho 1 ;
		 bb = fillonly ; 
		 if (ntrees >= 999 )
		    tch 0.998 ; 
		  end 
		   set esco score[0] ; 
		if ('esco' <= 'mini_mult[#cd]')
		      if ('esco' == 'mini_mult[#cd]')
			    save ; 
		      else 
			 ts/; ts *Mpts_cond#cd.tre ; save; 
		     end 
		     set mini_mult[#cd] 'esco' ; 
		     set besnod #nd ;
	       end 
	       if ('esco' > 'maxi_mult[#cd]' ) 
		   set maxi_mult[#cd] 'esco' ; 
	       end 
	       tc 0 ; 
	       tvault<0 ; 
	       loop=tx 0 ntax
		  if (#tx == 'tgtsp')
		      continue ;
		  end 
		  if ('chssp' == 1 ) 
			 if ('listax[#tx]' == 1)
			    prunt 0/#tx ;  
			 end
		  end
	      stop ;
	      set core_mult[#cd #nd] 'esco' ;
	stop
	set blue sister [0 outgroup] ; /*New* para colorear el out */
        set core_mult [ #cd outgroup] 'core_mult[ #cd 'blue']'    ;  /*New*/
	ts/; 
	loop=yy 0 nchar 
	    set listchar [#yy] 'bak_listchar [#yy]' ; 
	stop 
       
stop

sil-all; quote No salio  ; sil=all; 
; 
k0 ; 
tvault<0 ; 
ttag-;
ttag =; 
ttag * 0 ;
loop 0 nnodes [0]
 tt < #1 ; 
stop 


set alturama 100 ; 
if ('nconds'<= 3) 
  set sizsq 30 ;
  set alturama 70 ; 
else
  set sizsq 24 ;
end
set larama 110 ;
if ( ('nconds' > 3) && ('nconds' < 9) ) 
   set alturama 100 ; 
end   
if ('nconds' >= 9 ) 
  set alturama 130 ; 
end 
if ( 'nconds' > 12 ) 
  set ccc ( 'nconds' / 3 ) ; 
  if ('ccc' * 3 < 'nconds' ) 
      set ccc ++ ; 
      macfloat 0 ;
      set ccc 'ccc' ; 
      macfloat 4 ; 
  end 
  set larama 'larama' + ( ('ccc' - 4 ) * 'sizsq') + 10 ; 
 
  macfloat 0 ; 
  set larama 'larama' ; 
  macfloat 4 ; 
end





reroot * = 'pavote' ; 
nak= ; 
tt- ; 

ttag * 0 ; 


loop=nd 0 'nds' 
   if ( (#nd == root) ||  (#nd == 'tgtsp') || (!isintree [0 #nd]) ) 
     continue ; 
   end
   if ( ('listax[#nd]' == 1) && (#nd < root) )
     continue ; 
    end 
    TT <#nd ; 
    ttag +#nd /N#nd; 
stop 
 
ttag & $output_sensit xysave eti bheight 'alturama' legup 15 txtsep 20 bfontsize 20 thickness 4  tfontsize 35 blength 'larama' colors ; 




 
set nds nnodes [0] ; 
loop=cd 0 ('nconds'-1)
   sil=all; quote  condition #cd  ; sil=all; 
   if ('nconds' < 7) 
                   set limB 5 ;
                         set limA 2 ; 
                         set sizsq 30 ;
                   else
                    set sizsq 24 ;
                    if ( 'nconds' < 13)
                    set limB 7 ;
                    set limA 3 ;         
                         else
                    set ccc ( 'nconds' / 3 ) ; 
                          if ('ccc' * 3 < 'nconds' ) 
                           set ccc ++ ; 
                           macfloat 0 ;
                           set ccc 'ccc' ; 
                           macfloat 4 ; 
                    end 
                    set limA 'ccc' - 1 ; 
                    set limB ('ccc' *2 ) - 1 ; 
                    
                    
                    end 
                         end 
                         if (#cd > 'limB' ) 
                                 set suma_y 'sizsq' * 2 ;
                                 set suma_x 'sizsq' * (#cd - ('limB' + 1 )) ;
                         else 
                         if (#cd > 'limA' )
                                set suma_y 'sizsq' ;
                                set suma_x 'sizsq' * (#cd - ('limA' + 1 )) ; 
                         else
                                set suma_x 'sizsq' * #cd ; 
                          set suma_y 0 ; 
                         end
         end 
         set span 'maxi_mult[#cd]' - 'mini_mult[#cd]' ; 
         set miti 'mini_mult[#cd]' + ('span'/2) ; 
         set uncuar 'mini_mult[#cd]' + ( 'span' / 4 ) ;
         set trescuar 'mini_mult[#cd]' + ( (3 * 'span') / 4 );
         set mini 'mini_mult[#cd]' ; 
         set maxi 'maxi_mult[#cd]' ; 
	 if ('do_palette')
  	            set pace ('span' / 20 );  
	   	    goto FILL_COLIM ; 
        end
        set trescuarI 'maxi' + ('maxi'-'uncuar' )  ; 
	set mitiI   'maxi' + ('maxi'-'miti' )  ; 
	set uncuarI   'maxi' + ('maxi'-'trescuar' )  ;
	set maxiI    'maxi' + ('maxi - 'mini' )  ;


         loop=nd 0 'nds' 
              if ( #nd == 'tochang' )
	            continue
              end
              if ( (#nd == root) ||   (#nd == 'tgtsp') || (!isintree [0 #nd]) )
                    continue ; 
               end
              if (#nd < root) 
                 if ('listax[#nd]' == 1 ) 
                  continue ; 
                 end
              end 
              set ndtran 'trad_nd[#nd]' ; 
          if ('mini_mult[#cd]' == 'maxi_mult[#cd]') 
              set red 130 ; set blue 130 ;set green 130 ; 
          else 
  	      set elesco 'core_mult[#cd 'ndtran' ]'  ;
    	  end  
          if (!'do_palette')
                       set elsco   'maxi' + ('maxi' -'core_mult[#cd 'ndtran' ]' ) ; 
  		       if ('elsco' < ( 'uncuarI') ) ; /*240,5,5 a  254,240,1 */ 
		 		      set red   (254 - ( (254-240)  *  (( 'uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
		 		      set green (240 - ( (240-5)  *   (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
		 		      set blue  (1 +   ( (5-1)  *     (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )))    ;   ;   
		 	      else
		 		     if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) ) /* 254,240,1  a 46,182,44) */ 
		 			set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
		 			set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
		 			set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
		 		    else
		 			 if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )  /*46,182,44 a 18,232,232*/
		 				set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
		 				set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
		 				set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
		 			 else   /*18,232,232 a 55,55,148*/
		 				set red    ( 55  - ( (55-18)  *    (( 'maxiI' - 'elsco' ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
		 				set green  ( 55  + ( (232-55)  *   (( 'maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
		 				set blue   ( 148 + ( (232-148)  *  (('maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
		 
		 			     end
		 		    end
	     end
	  else
		set micore 'elesco' ; 
		goto SETTING_COLORS ; 
	  end
          macfloat 4 ; 
          set pos_x ('eti[#nd 0]' - 'eti[anc[0 #nd] 0]')/ 12 + 'eti[anc[0 #nd] 0]' + 'suma_x' ; 
          set pos_y 'eti[#nd 1]' + 4 + 'suma_y'; 
          if (('dosensit' == 1 ) || ('dosensit' == 2 ) ) 
                 if (#cd == 'bescond') 
                    set redsiz 'sizsq' - 2 ; 
                    ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'redsiz'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ;sil=all; 
                 else
                  ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:none&34 /> &10 ;sil=all; 
                 end
         else
           ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:none&34 /> &10 ;sil=all; 
         end
         set pos_y 'pos_y' + 22 ;   /*set pos_y 'pos_y' + 15 ; */
         set pos_x 'pos_x' + 15 ;    /*set pos_x 'pos_x' + 3 ; */
         if ('core_mult[#cd 'ndtran']' == 'mini_mult[#cd]') 
           ttag &+ write <text x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32 font-size=&34 12&34&32 > * </text> &10 ; 
         end 
         set nod sister [0 'tochang' ] ; 
         if (#nd == 'nod' )
              set pos_x ('eti['tochang' 0]' - 'eti[anc[0 'tochang'] 0]')/ 12 + 'eti[anc[0 'tochang'] 0]' + 'suma_x' ; 
              set pos_y 'eti['tochang' 1]' + 4 + 'suma_y'; 
             if (('dosensit' == 1 ) || ('dosensit' == 2 ) ) 
	        if (#cd == 'bescond') 
	            set redsiz 'sizsq' - 2 ; 
	            ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'redsiz'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ;sil=all; 
	        else
	           ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:none&34 /> &10 ;sil=all; 
	        end
	    else
	          ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:none&34 /> &10 ;sil=all; 
            end
            set pos_y 'pos_y' + 22 ;   /*set pos_y 'pos_y' + 15 ; */
            set pos_x 'pos_x' + 15 ;    /*set pos_x 'pos_x' + 3 ; */
            if ('core_mult[#cd 'ndtran']' == 'mini_mult[#cd]') 
	         ttag &+ write <text x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32 font-size=&34 12&34&32 > * </text> &10 ; 
            end 
        end 
    stop
stop


set dist 0 ; 
loop 0 (nnodes [0]) 
 if ('eti [#1 1]' > 'dist')
 set dist 'eti [#1 1]' ; 
 end
stop 

set dist 'dist' + 80 ; 
set posx 'dist' - 30 ; 
lquote [ ; 
ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 18&34 > Optimal</text>&10 ; 
set posx 'dist' -15 ; 


 
  
  set span 'maxi' - 'mini' ; 
  set shift 'mini' ; 
  set shoft 'maxi' ; 
  set mit ('span'/2) ; 
  set uncua ( 'span' / 4 ) ;
  set trescua ( (3 * 'span') / 4 ) ;
  macfloat 2 ; 
  ttag&+ write<text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 18&34 > 0 </text>&10 ; 
  ttag&+ write<text&32x=&34 160 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 18&34>+ 'uncua' </text> &10 ; 
  ttag&+ write<rect x=&34 158&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
  ttag&+ write<text&32x=&34 310 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 18&34>+ 'mit' </text> &10 ; 
  ttag&+ write<rect x=&34 308&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
  ttag&+ write<text&32x=&34 460 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 18&34>+ 'trescua' </text> &10 ; 
  ttag&+ write<rect x=&34 458&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
  ttag&+ write<text&32x=&34 610 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 18&34>+ 'span' </text> &10 ; 
  ttag&+ write<rect x=&34 608&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
  macfloat 10; 
 
if(!'do_palette')
	 set dist 'posx' + 10 ; 
	 	 ttag&+ write <defs>&10<linearGradient&32id=&34graa&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(240,5,5).,stop-opacity:1&34></stop>&10; 
	 	 ttag&+ write </linearGradient>&10; 
	 	 ttag&+ write </defs>&10;
	 	 ttag&+ write <rect x=&34 460&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35graa)&34 />&10 ;
	 
	 	 ttag&+ write <defs>&10<linearGradient&32id=&34grab&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 	 ttag&+ write </linearGradient>&10; 
	 	 ttag&+ write </defs>&10;
	 	 ttag&+ write <rect x=&34 310&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grab)&34 />&10 ;
	 
	 	 ttag&+ write <defs>&10<linearGradient&32id=&34grac&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(18,232,232) .,stop-opacity:1&34></stop>&10; 
	 	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 	 ttag&+ write </linearGradient>&10; 
	 	 ttag&+ write </defs>&10;
	 	 ttag&+ write <rect x=&34 160&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grac)&34 />&10 ;
	 
	 	 ttag&+ write <defs>&10<linearGradient&32id=&34grad&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(55,55,148).,stop-opacity:1&34></stop>&10; 
	 	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(18,232,232).,stop-opacity:1&34></stop>&10; 
	 	 ttag&+ write </linearGradient>&10; 
	 	 ttag&+ write </defs>&10;
	 	 ttag&+ write <rect x=&34 10&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grad)&34 />&10 ;

else
   set tancia 10 ; 
      loop=uup 0 19
        ttag&+ write <rect x=&34 'tancia'&34 &32y=&34 'dist'&34 &32width=&34 30&34&32 height=&34 30&34&32 style=&34fill:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]')&34 />&10 ;
        set tancia 'tancia' + 30 ; 
      stop   
end


set posx ('posx' + 70) ; 
set tgtname $$taxon 'tgtsp' ; 
ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 >Target Species=&32 $tgtname </text>&10 ; 
if ( ('dosensit' == 1 ) || ('dosensit' == 2 ))
 set posx 'posx' + 25 ; 
 ttag &+ write <rect x=&34 5&34&32y=&34 'posx' &34&32width=&34 16&34&32height=&34 16&34&32style=&34fill:white&59 stroke:black&34 /> &10 ;sil=all; 
 set posx 'posx' + 20 ; 
 ttag&+ write <text&32x=&34 30 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 >Condition selected by Leave-one-out validation approach</text>&10 ; 
end
set posx 'posx' + 25 ; 
ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 16&34 > * </text>&10 ; 
set posx 'posx' + 5 ; 
ttag&+ write <text&32x=&34 30 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Optimal placement for that setting </text>&10 ; 
set posx 'posx' + 50 ;
ttag &+ write <text&32x=&34 10 &34 &32 y=&34 'posx'&34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Settings </text>&10 ; 

set posx 'posx' +10 ; 
loop=cd 0 ('nconds'-1)
 if ('nconds' < 7) 
  set limB 5 ;
  set limA 2 ; 
 else
  if ( 'nconds' < 13)
   set limB 7 ;
   set limA 3 ;          
  else
   set ccc ( 'nconds' / 3 ) ; 
         if ('ccc' * 3 < 'nconds' ) 
           set ccc ++ ; 
           macfloat 0 ;
           set ccc 'ccc' ; 
           macfloat 4 ; 
    end 
    set limA 'ccc' - 1 ; 
    set limB ('ccc' *2 ) - 1 ; 
  end 
 end 
 if (#cd > 'limB' ) 
                 set suma_y 23 * 2 ;
                 set suma_x 23 * (#cd - ('limB' + 1 )) ;
         else 
         if (#cd > 'limA' )
                set suma_y 23 ;
                set suma_x 23 * (#cd - ('limA' + 1 )) ; 
         else
                set suma_x 23 * #cd ; 
          set suma_y 0 ; 
         end
         end 
 set pos_x 'suma_x' + 5 ;
 set pos_y 'suma_y' + 'posx' ;
 ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 22&34&32height=&34 22&34&32style=&34fill:white&59 stroke:black&34 /> &10 ;sil=all ; 
 set dde #cd ;
 set pos_x 'pos_x' + 5 ; set pos_y 'pos_y' + 14 ; 
 ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > 'dde' </text>&10 ; 
stop
 
if ('guichsensit' == 2 )
 hifile close ;
end

ttag & ; 
naked=; 
 
 

k 0 ; 
proc/; 

 

label DOCOLORTABLE
report- ;
k 0 ; 
tvault < . ; 
tc 0 ; 





set star_x 220 ; set star_y 200 ; set pace_x 16 ; set pace_y 17 ; 
set tot_width (nchar + 1 ) * ('pace_x'+2) + 'star_x' + 250 ; 
set tot_hig (2 * (ntax + 1) ) * 'pace_y' + 'star_y' + 250 ; 

lquote = ; 
lquote [ ; 
silent = all ; 
report- ; 
log $output_svgchars ; 
silent - file ; quote <svg width=&34 'tot_width'&34  height=&34 'tot_hig'&34  xmlns=&34 http://www.w3.org/2000/svg&34> &10 ;sil=all; 

set ctos 0 ; 


set pos_y 'star_y' - 2 ; 

 
if (!'dogrpchars' || 'nomeagrupes')
 loop 0 nchar 
        set bl_name $$character #1 ;
        set pos_x 'star_x' + ('pace_x' * 'ctos' ) ; 
        sil-file; quote <text x=&34 'pos_x'&34 &32y=&34 'pos_y'&34&32 font-size=&34 12&34&32 transform=&34 rotate (-60,'pos_x','pos_y')&34 > #1_$bl_name:30 &32 </text> &10 ; sil=all;
        macfloat 7 ; 
        set ctos ++ ; 
 stop
else
 loop=grp 0 ('numchrgrp'-1)
   loop=car 0 nchar
     if (isinxgroup[#grp #car])
      set bl_name $$character #car ;
      set pos_x 'star_x' + ('pace_x' * 'ctos' ) ; 
    sil-file; quote <text x=&34 'pos_x'&34 &32y=&34 'pos_y'&34&32 font-size=&34 12&34&32 transform=&34 rotate (-60,'pos_x','pos_y')&34 > Gr #grp Ch #car $bl_name:30 &32 </text> &10 ; sil=all;
  macfloat 7 ; 
  set ctos ++ ;
  end 
 stop
 stop 
end

set ctos_sp 0 ;
set star_b 'star_x' - 10 ; 
set maxrange 0 ;
silent = all ;



 loop 0 nchar 
   set maxis[#1] 0 ; 
   set minis[#1] 9999999 ;
 stop 
 set maxrange 0 ; 
 loop 0 nchar 
     loop 0 nnodes [0]
      if (  (#2 == root ) || (#2 == 'tgtsp') || (!isintree [0 #2]) )
         continue ; 
      end 
      if ('charscore[#2 #1]' < 'minis[#1]' ) 
       set minis[#1] 'charscore[#2 #1]' ; 
      else
       if ('charscore[#2 #1]' > 'maxis[#1]' ) 
        set maxis[#1] 'charscore[#2 #1]' ; 
       end
     end
   stop
   if (('maxis[#1]'-'minis[#1]') > 'maxrange')
     set maxrange 'maxis[#1]'-'minis[#1]' ; 
     set shift 'minis[#1]' ; 
     set shoft 'maxis[#1]' ; 
   end 
 stop 
 
if (!'besever')
 set span 'maxrange' ; 
 set miti 'shift' + ('span'/2) ; 
 set uncuar 'shift' + ( 'span' / 4 ) ;
 set trescuar 'shift' + ( (3 * 'span') / 4 );
 
 set trescuarI 'shoft' + ('shoft'-'uncuar' )  ; 
 set mitiI   'shoft' + ('shoft'-'miti' )  ; 
 set uncuarI   'shoft' + ('shoft'-'trescuar' )  ;
 set shiftI 'shoft' ;
 set shoftI  'shoft' + ('shoft' - 'shift' )   ;
 
 set mini 'shift' ; 
 set maxi 'shoft' ;  
 
 if ('do_palette')
        sil=all; 
        
        set pace ('span' / 20 );  
        goto FILL_COLIM ; 
    end 
end 
 
 
set dde 0 ;              

set pivote sister[0 outgroup] ; /* esta es la rama que queda sin tag */ /*New*/
reroot  * = 'pavote' ; /* pongo el enraizado original */ /*New*/
nak= ; 
tt- ; 

ttag * 0 ; 


 loop=nd 0 'nds' 
     set ndtran 'trad_nd[#nd]' ; 
     /*quote: #nd ndtran 'ndtran' hermano 'hermano'  ; */
     if ('ndtran' == (-1) ) 
        set hermano sister [ 0 #nd] ;   
        continue ;
    end
 stop         
    
 

 
/* SVG DE SCORES DE CARACTERES */ 

if (!'dogrpchars' || 'nomeagrupes') 
 loop=tar 0 nchar 
  set bloque #1 ; 
  set pos_x 'star_b' + ('pace_x' * 'dde') ;
  set ctos_sp 0 ; 
  loop=ods 0 nnodes [0] 
        set ndtran 'trad_nd[#ods]' ; 
        if ('ndtran' == (-1) )
          continue ;  
        end
        if ( ('nod' == root ) ||  ('nod' == 'tgtsp') || (!isintree [0 'nod']) ) 
         continue ; 
        end 
        set pos_y 'star_y' + ('pace_y' * 'ctos_sp') ; 
        if ('besever')
           set shift 'minis[#1]' ; 
           set shoft 'maxis[#1]' ; 
           set span 'maxis[#1]' - 'minis[#1]' ; 
           set miti 'shift' + ('span'/2) ; 
           set uncuar 'shift' + ( 'span' / 4 ) ;
           set trescuar 'shift' + ( (3 * 'span') / 4 ); 
 	   set mini 'minis[#1]' ; 
	   set maxi 'maxis[#1]' ;
	   
	   set trescuarI 'maxi' + ('maxi'-'uncuar' )  ; 
	   set mitiI   'maxi' + ('maxi'-'miti' )  ; 
	   set uncuarI   'maxi' + ('maxi'-'trescuar' )  ;
	   set shiftI 'maxi' ;
           set shoftI  'maxi' + ('maxi' - 'mini' )   ;
	   
           if ('do_palette')
                set pace ('span' / 20 ); 
                sil=all; 
    	       goto FILL_COLIM ; 
           end
        end     
        
        if (('maxis[#1]'-'minis[#1]')== 0 )
          set blue 130 ; 
          set red 130 ; 
          set green 130 ; 
        else
           if ('minis [#1]' < 'shift' ) 
             set elsco 'charscore['ndtran' #1]' + ('shift' - 'minis [#1]') ;
           else
             set elsco 'charscore['ndtran' #1]' - ('minis [#1]' - 'shift' ) ; 
           end
                if (!'do_palette')
                    set elsco 'shoft' + ('shoft' - 'elsco')  ;     
                     if ('elsco' < ( 'uncuarI') )   
	     	        set red   (254 - ( (254-240)  *  (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI'  ) )) )   ; 
	     	        set green (240 - ( (240-5)  *    (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI' ) )) )   ; 
	     	        set blue  (1 + ( (5-1)  *        (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI' ) )))    ;   ;   
	         
	            else
	     	        if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) )   
	     		   set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
	     		   set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
	     	     	   set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
	     	        else
	     		   if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )   
	     			set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
	     			set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
	     			set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
	     		    else   /*18,232,232 a 55,55,148*/
	     		        set red    ( 55  - ( (55-18)  *    (( 'shoftI' - 'elsco' ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
	     			set green  ( 55  + ( (232-55)  *   (( 'shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
	     			set blue   ( 148 + ( (232-148)  *  (( 'shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
	     		    end
	     	       end
                   end
                   sil=all; quote uncuarI 'uncuarI' shiftI 'shiftI' shoft 'shoft' elsco 'elsco' mitiI 'mitiI' trescuarI 'trescuarI' red 'red' green 'green' blue 'blue' ; sil=all; 
                   
               else
                 set micore 'elsco' ; 
                 sil=all; 
	         goto SETTING_COLORS ; 
               end
               lquote- ; 
	  end 
          sil-file; quote <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 15&34&32height=&34 15&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ;sil=all;
          if (( 'charscore['ndtran'  #1]' == 'minis[#1]') && (('maxis[#1]'-'minis[#1]') != 0 )) 
            set px 'pos_x' + 2 ; set py 'pos_y' + 16 ; 
             sil-file; quote <text x=&34 'px'&34&32y=&34 'py'&34&32 font-size=&34 16&34&32 > &32* </text> &10 ; sil=all;
          end
          set ctos_sp ++ ;
         
          if (#ods == 'hermano' ) 
	    set pos_y 'star_y' + ('pace_y' * 'ctos_sp') ; 
            sil-file; quote <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 15&34&32height=&34 15&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ;sil=all;
            if ( ('charscore['ndtran' #1]' == 'minis[#1]') && ('maxis [#1]' != 'minis[#1]') ) 
	            set px 'pos_x' + 2 ; set py 'pos_y' + 16 ; 
	            
	            sil-file; quote <text x=&34 'px'&34&32y=&34 'py'&34&32 font-size=&34 16&34&32 > &32* </text> &10 ; sil=all;
            end
            set ctos_sp ++ ;
          end        
      stop
     set dde ++ ; 
 stop
 
else
 loop=grp 0 ('numchrgrp'-1)
    loop=car 0 nchar
        if (!isinxgroup[#grp #car])
          continue ; 
        end 
        set bloque #car ; 
        set pos_x 'star_b' + ('pace_x' * 'dde') ;
        set ctos_sp 0 ; 
        if ('besever')
               set shift 'minis[#car]' ; set shoft 'maxis[#car]' ; 
               set span 'maxis[#car]' - 'minis[#car]' ; 
               set miti 'shift' + ('span'/2) ; 
               set uncuar 'shift' + ( 'span' / 4 ) ;
               set trescuar 'shift' + ( (3 * 'span') / 4 ); 
               set mini 'minis[#car]' ; 
	       set maxi 'maxis[#car]' ;
	       	   
	       set trescuarI 'maxi' + ('maxi'-'uncuar' )  ; 
	       set mitiI   'maxi' + ('maxi'-'miti' )  ; 
	       set uncuarI   'maxi' + ('maxi'-'trescuar' )  ;
	       set shiftI 'maxi' ;
	       set shoftI  'maxi' + ('maxi' - 'mini' )   ;
	       if ('do_palette')
	          set pace ('span' / 20 ); 
	          sil=all; 
	         goto FILL_COLIM ; 
              end
         end
         loop=nd 0 nnodes [0] 
           set ndtran 'trad_nd[#nd]' ; 
	   if ('ndtran' == (-1) )
	       continue ;  
           end
           set nod #nd ;
           if (('nod' == root ) ||   ('nod' == 'tgtsp') || (!isintree [0 'nod']) ) 
             continue ; 
           end 
           set pos_y 'star_y' + ('pace_y' * 'ctos_sp') ;
          
          if (('maxis[#car]'-'minis[#car]')== 0 )
                  set blue 130 ; 
                  set red 130 ; 
                  set green 130 ; 
          else
              if ('minis [#car]' < 'shift' ) 
                   set elsco 'charscore['ndtran' #car]' + ('shift' - 'minis [#car]') ;
              else
                   set elsco 'charscore['ndtran' #car]' - ('minis [#car]' - 'shift' ) ; 
              end 
              if (!'do_palette')
                      set elsco 'shoft' + ('shoft' - 'elsco')  ;     
                    
		      if ('elsco' < ( 'uncuarI') )  /*240,5,5 a  254,240,1 */ 
					set red   (254 - ( (254-240)  *  (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI'  ) )) )   ; 
					set green (240 - ( (240-5)  *    (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI' ) )) )   ; 
					set blue  (1 + ( (5-1)  *        (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI' ) )))    ;   ;   

		      else
					if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) ) /* 254,240,1  a 46,182,44) */ 
					   set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
					   set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
					   set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
					else
					   if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )  /*46,182,44 a 18,232,232*/
						set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
						set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
						set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
					    else   /*18,232,232 a 55,55,148*/
						set red    ( 55  - ( (55-18)  *    (( 'shoftI' - 'elsco' ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
						set green  ( 55  + ( (232-55)  *   (( 'shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
						set blue   ( 148 + ( (232-148)  *  (( 'shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
					    end
				       end
		     end
	     else
	         set micore 'elsco' ; 
	         sil=all; 
	         goto SETTING_COLORS ; 
	     end 
	  end 
          sil-file; quote <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 15&34&32height=&34 15&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ; sil=file; 
          if ( ('charscore['ndtran' #car]' == 'minis[#car]') && ('maxis [#car]' != 'minis[#car]') ) 
               set px 'pos_x' + 2 ; set py 'pos_y' + 16 ; 
               sil-file; quote <text x=&34 'px'&34&32y=&34 'py'&34&32 font-size=&34 16&34&32 > &32* </text> &10 ; sil=all;
          end
          set ctos_sp ++ ;
   
          if (#nd == 'hermano' ) 
	    set pos_y 'star_y' + ('pace_y' * 'ctos_sp') ; 
	    sil-file; quote <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 15&34&32height=&34 15&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ;sil=all;
	    /*sil-file; quote <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 15&34&32height=&34 15&34&32style=&34fill:rgb(55,212,23)&34 /> &10 ;sil=all;*/
	    
            if ( ('charscore['ndtran' #car]' == 'minis[#car]') && ('maxis [#car]' != 'minis[#car]') ) 
	          set px 'pos_x' + 2 ; set py 'pos_y' + 16 ; 
	          sil-file; quote <text x=&34 'px'&34&32y=&34 'py'&34&32 font-size=&34 16&34&32 > &32* </text> &10 ; sil=all;
            end
            set ctos_sp ++ ;
          end   
       stop
       set dde ++ ; 
  stop
 stop 
end
 


set star_y 'star_y' + 12 ; 
set ctos_sp 0 ; 

set px (('pace_x'+2) * ( nchar+1 ) ) + 'star_b' + 4 ; 
loop=pp 0 nnodes [0]
  if ( ( #pp == root ) || (#pp == 'tgtsp') || (!isintree [0 #pp]) ) 
         continue ; 
        end 
        set ndtran 'trad_nd[#pp]' ; 
        if ('ndtran' == (-1) )
       	       continue ;  
        end
        set dde root ; 
        sil=all ;  quote root 'dde' &10; 
        if ( #pp < 'dde'  ) 
           set bl_name $$taxon #pp ;
        else
           set bl_name $Node #pp ;
        end
        sil=all; 
        set pos_y 'star_y' + ('pace_y' * 'ctos_sp' ) ; 
        sil-file; quote <text x=&34 5&34&32y=&34 'pos_y'&34&32 font-size=&34 12&34 > &32 $bl_name:30 </text> &10 ; sil=all;
        macfloat 7 ; 
        set ctos_sp ++ ;
        if (#1 == 'trad_nd['besnod']' ) 
          set py 'pos_y' - 13 ; 
          sil-file; quote <rect x=&34 4 &34&32y=&34 'py'&34&32width=&34 'px'&34&32height=&34 17&34&32stroke-width=&34 2&34&32stroke=&34black&34&32fill=&34none&34&32 /> &10 ;sil=all;
        end
        sil=all ; quote pase por aca ; sil=all; 
        if (#pp == 'hermano' ) 
           set tochang sister [ 0 #pp] ; 
       	   if ('tochang' < root ) 
		set bl_name $$taxon 'tochang' ; 
	   else
		 set bl_name $Node 'tochang' ;
	   end
	   set pos_y 'star_y' + ('pace_y' * 'ctos_sp' ) ; 
	   sil-file; quote <text x=&34 5&34&32y=&34 'pos_y'&34&32 font-size=&34 12&34 > &32 $bl_name:30 </text> &10 ; sil=all;
	   macfloat 7 ; 
	   set ctos_sp ++ ;
	   if (#1 == 'trad_nd['besnod']' )
	        set py 'pos_y' - 13 ; 
		sil-file; quote <rect x=&34 4 &34&32y=&34 'py'&34&32width=&34 'px'&34&32height=&34 17&34&32stroke-width=&34 2&34&32stroke=&34black&34&32fill=&34none&34&32 /> &10 ;sil=all;
	   end
        end
stop






 set tot_width 'tot_width' - 80 ; 
 set dist 'pos_y' + 50 ;

 sil-file; 
 if (!'besever')
  set uncua 'uncuar'-'shift' ; set trescua 'trescuar'-'shift' ; set mit 'miti'-'shift' ; set shof 'shoft'-'shift' ; 
  macfloat 2 ; 
  quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > 0 </text>&10 ; 
  quote <text&32x=&34 110 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'uncua' </text> &10 ; 
  quote <rect x=&34 108&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ; 
  quote <text&32x=&34 210 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'mit' </text> &10 ; 
  quote <rect x=&34 208&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ; 
  quote <text&32x=&34 310 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'trescua' </text> &10 ; 
  quote <rect x=&34 308&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ; 
  quote <text&32x=&34 410 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'shof' </text> &10 ; 
  quote <rect x=&34 408&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ; 
  macfloat 10; 
 else
   quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 >Optimal</text>&10 ; 
   quote <text&32x=&34 360 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 >Suboptimal</text> &10 ;
 end 
 
 set dist 'pos_y' + 60 ; 


if (!'do_palette')
	 quote <defs>&10<linearGradient&32id=&34graa&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(240,5,5).,stop-opacity:1&34></stop>&10; 
	 quote </linearGradient>&10; 
	 quote </defs>&10; 
	 quote <rect x=&34 310&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35graa)&34 />&10 ;
	 quote <defs>&10<linearGradient&32id=&34grab&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 quote </linearGradient>&10; 
	 quote </defs>&10;
	 quote <rect x=&34 210&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35grab)&34 />&10 ;

	 quote <defs>&10<linearGradient&32id=&34grac&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(18,232,232) .,stop-opacity:1&34></stop>&10; 
	 quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 quote </linearGradient>&10; 
	 quote </defs>&10;
	 quote <rect x=&34 110&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35grac)&34 />&10 ;

	 quote <defs>&10<linearGradient&32id=&34grad&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(55,55,148).,stop-opacity:1&34></stop>&10; 
	 quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(18,232,232).,stop-opacity:1&34></stop>&10; 
	 quote </linearGradient>&10; 
	 quote </defs>&10;
	 quote <rect x=&34 10&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35grad)&34 />&10 ; 

   else 
       set tancia 10 ; 
       loop=uup 0 19
         quote <rect x=&34 'tancia'&34 &32y=&34 'dist'&34 &32width=&34 20&34&32 height=&34 20&34&32 style=&34fill:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]')&34 />&10 ;
         set tancia 'tancia' + 20 ; 
      stop  
   end 
 
 set dist 'dist' + 40 ; 
 quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > *    Optimal placement for the character</text>&10 ;
 set dist 'dist' + 20 ;
 quote <text&32x=&34 30 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Overall optimal placement </text>&10 ;
 set dist 'dist' - 13 ;
 quote <rect x=&34 4 &34&32y=&34 'dist'&34&32width=&34 17&34&32height=&34 17&34&32stroke-width=&34 2&34&32stroke=&34black&34&32fill=&34none&34&32 /> &10 ;
 set dist 'dist' + 30  ;
 quote <text&32x=&34 30 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Target species = $tgtname </text>&10 ;
         
         
         

sil-file; quote </svg> &10 ; sil=all; 
log/;

 
 
 /* TABLA DE SCORES DE CARACTERES */ 




log $char_file ; 
lquote = ; 
lquote [ ; 
quote , ; 
loop=grp 0 nchar
    set bl_name $$character #grp ; 
     sil-file; quote $bl_name , ; sil=all; 
stop 
sil-file; quote &10 ; sil=all; 
loop=nd 0 nnodes [0] 
         set ndtran 'trad_nd[#nd]' ; 
         if ('ndtran' == (-1) )
              	       continue ;  
         end
	 if (#1 < root ) 
  	    set bl_name $$taxon #1 ;
	 else
	    set bl_name $Node #1 ;
	 end
	 set nod #1 ;
	 if (('nod' == root ) ||  ('nod' == 'tgtsp') || (!isintree [0 'nod']) ) 
	    continue ; 
	 end
	 sil-file; quote $bl_name , ; sil=file;
	 loop=grp 0 nchar 
	   sil-file; quote 'charscore['trad_nd[#nd]' #grp]' , ; sil=file;
	 stop
	 sil-file; quote &10 ; sil=file;
	 set nod sister[0 'tochang'] ; 
	 if (#nd == 'hermano' ) 
		   set tochang sister [ 0 #nd] ; 
		   if ('tochang' < root ) 
		       set bl_name $$taxon 'tochang' ; /*cambiue aca decia #1 ) */
		   else
		     set bl_name $Node'tochang' ;
		   end
		  sil-file; quote $bl_name , ; sil=file;
		  loop=grp 0 nchar 
		     sil-file; quote 'charscore['trad_nd[#nd]' #grp]' , ; sil=file;
		  stop
		  sil-file; quote &10 ; sil=file;
        end
stop 
log/; 
 
  
  
 /* SVG DE SCORES DE GRUPOS DE CARACTERES */ 
 
  sil=all; quote dogrpchars   'dogrpchars'     numchrgrp 'numchrgrp'  grpscore [0 1]  'grpscore [0 1]'; 
          
if ('dogrpchars') 
	  if (!'domodif' )
		  loop 0 'numchrgrp' 
		      set mybestscore [#1] 99999999 ; 
		      loop 0 nnodes [0 ] 
			set grpscore [#2 #1] 0 ; 
		      stop 
		  stop
		  loop=nd 0 nnodes [0]
		     loop=car 0 nchar
			set coras 'charscore[#nd #car]' ; 
			 loop=grp 0 'numchrgrp' 
			    if (isinxgroup[#grp #car])
			      set grpscore [#nd #grp] 'grpscore [#nd #grp]' + 'coras' ;
			    end
			 stop
		     stop 
		 stop
	 end 	 
	 loop=grp 0 ('numchrgrp'-1) 
	       loop=nd 0 nnodes [0] 
		 if ('grpscore [#nd #grp]' < 'mybestscore [#grp]')
		   set mybestscore [#grp] 'grpscore [#nd #grp]' ; 
		end
	     stop 
	 stop 
	 loop 0 nchar 
	     set maxis[#1] 0 ; 
	     set minis[#1] 9999999 ;
	 stop 
	 set maxrange 0 ; 
	 loop 0 ('numchrgrp'-1) 
	    loop 0 nnodes [0]
	       if (  (#2 == root ) || (#2 == 'tgtsp') || (!isintree [0 #2]))
		 continue ; 
	       end 
	       if ('grpscore[#2 #1]' < 'minis[#1]' ) 
		   set minis[#1] 'grpscore[#2 #1]' ; 
	       else
		  if ('grpscore[#2 #1]' > 'maxis[#1]' ) 
		     set maxis[#1] 'grpscore[#2 #1]' ; 
		  end
	       end 
	    stop
	    if (('maxis[#1]'-'minis[#1]') > 'maxrange')
	       set maxrange 'maxis[#1]'-'minis[#1]' ;
	       set shift 'minis[#1]' ; 
	       set shoft 'maxis[#1]'; 
	    end 
	 stop 


	 log $grp_scores_tabl ; 
	 sil-file; 
	 lquote = ; 
	 lquote [ ;
	 quote , ; 
	 loop=grp 0 ('numchrgrp'-1)
	     set bl_name $$xgroup #grp ; 
	     sil-file; quote $bl_name , ; sil=file;
	 stop 
	 sil-file; quote &10 ; sil=file;
	 loop=nd 0 nnodes [0] 
	             set nod #nd ; 
	             set ndtran 'trad_nd[#nd]' ; 
	     	     if ('ndtran' == (-1) )
		          continue ;  
                     end
		     if (('nod' == root ) ||  ('nod' == 'tgtsp') || (!isintree [0 'nod']) ) 
		         continue ; 
		      end
		     if (#1 < root ) 
			 set bl_name $$taxon #1 ;
		      else
			set bl_name $Node #1 ;
		      end
		     sil-file; quote $bl_name , ; sil=file;
		     loop=grp 0 ('numchrgrp'-1)
			 sil-file; quote 'grpscore['trad_nd[#nd]'  #grp]' , ; sil=file;
		     stop
		     sil-file; quote &10 ; sil=file;
		     if (#nd == 'hermano' ) 
		        set tochang sister [ 0 #nd] ; 
		        if ('tochang' < root ) 
			 	set bl_name $$taxon 'tochang' ;
			 else
				set bl_name $Node 'tochang' ;
		         end
		         sil-file; quote $bl_name , ; sil=file;
		         loop=grp 0 ('numchrgrp'-1)
			   sil-file; quote 'grpscore['trad_nd[#nd]'  #grp]' , ; sil=file;
		         stop
		         sil-file; quote &10 ; sil=file;
		     end
	 stop 
	 sil=file; 
	 log/; 


	 log $group_file ; 
	 lquote [ ; 
	 lquote =; 
	 set tot_width 'numchrgrp' * 'pace_x' + 'star_x' + 200 ; 
	 sil-file; quote <svg width= &34 'tot_width'&34  height=&34 'tot_hig'&34  xmlns=&34 http://www.w3.org/2000/svg&34> &10 ;sil=all; 
	 set ctos 0 ; 
	 set pos_y 'star_y' - 2 ; 
	 loop=grp 0 ('numchrgrp'-1)
		   set bl_name $$xgroup #grp ;
		   set pos_x 'star_x' + ('pace_x' * 'ctos' ) ;
		   sil-file; quote <text x=&34 'pos_x'&34 &32y=&34 'pos_y'&34&32 font-size=&34 12&34&32 transform=&34 rotate (-60,'pos_x','pos_y')&34 > $bl_name:30 &32 </text> &10 ; sil=all; 
		   macfloat 7 ; 
		   set ctos ++ ; 
	 stop 
	 set ctos_sp 0 ;
	 set star_b 'star_x' - 10 ; 
	 set dde 0 ;
	 if (!'besever')
		    set span 'maxrange' ; 
		    set miti 'shift' + ('span'/2) ; 
		    set uncuar 'shift' + ( 'span' / 4 ) ;
		    set trescuar 'shift' + ( (3 * 'span') / 4 );

		   set trescuarI 'shoft' + ('shoft'-'uncuar' )  ; 
		   set mitiI   'shoft' + ('shoft'-'miti' )  ; 
		   set uncuarI   'shoft' + ('shoft'-'trescuar' )  ;
		   set shiftI 'shoft' ;
		   set shoftI  'shoft' + ('shoft' - 'shift' )   ;
		   set mini 'shift' ; 
		   set maxi 'shoft' ;  
		    if ('do_palette')
			  set mini 'shift' ; 
			  set pace ('span' / 20 );  
			  goto FILL_COLIM ; 
		    end 
	 end
         loop=grp 0 ('numchrgrp'-1)
                set bloque #1 ; 
                set pos_x 'star_b' + ('pace_x' * 'dde') ;
                set ctos_sp 0 ;
                if ('besever') 
			   set span 'maxis[#grp]' - 'minis[#grp]' ; 
			   set shift 'minis[#grp]' ; 
			   set shoft 'maxis[#grp]' ; 
			   set miti 'shift' + ('span'/2) ; 
			   set uncuar 'shift' + ( 'span' / 4 ) ;
			   set trescuar 'shift' + ( (3 * 'span') / 4 );
                           set mini 'shift' ; 
                           set maxi 'shoft' ; 
                           set trescuarI 'maxi' + ('maxi'-'uncuar' )  ; 
               	           set mitiI   'maxi' + ('maxi'-'miti' )  ; 
	   	           set uncuarI   'maxi' + ('maxi'-'trescuar' )  ;
	   	           set shiftI 'maxi' ;
 	   	           set shoftI  'maxi' + ('maxi' - 'mini' )   ;

			    if ('do_palette')
				 set mini 'minis[#grp]' ; 
				 set maxi 'maxis[#grp]' ;  
				 set pace ('span' / 20 );  
				 goto FILL_COLIM ;  
			   end 
                end 
                loop=nd 0 nnodes [0] 
                   set nod #2 ;
                   set ndtran 'trad_nd[#nd]' ; 
		   if ('ndtran' == (-1) )
		         continue ;  
                   end
                   if (('nod' == root ) ||   ('nod' == 'tgtsp') || (!isintree [0 'nod']) ) 
                     continue ; 
                   end 
                   set pos_y 'star_y' + ('pace_y' * 'ctos_sp') ;
                   set green 'maxis[#grp]'-'minis[#grp]' ;
                   set blue 0 ; 
                   if ('green' == 0 ) 
                    set blue  1  ;  
                   else
                       if (  ('green'/'maxis[#grp]') < 0.0001  ) 
                          set blue 1 ; 
                       end
                   end
                   if ('blue' )
                          set blue 130 ; 
                          set red 130 ; 
                          set green 130 ; 
                  else
                     
                           if ('minis [#1]' < 'shift' ) 
                               set elsco 'grpscore['trad_nd[#nd]'  #grp]' + ('shift' - 'minis [#grp]') ;
                           else
                               set elsco 'grpscore['trad_nd[#nd]'  #grp]' - ('minis [#grp]' - 'shift' ) ; 
                           end  
                           if (!'do_palette') 
                               set elsco 'shoft' + ('shoft' - 'elsco')  ;     
                   
                               if ('elsco' < ( 'uncuarI') )    
 				    set red   (254 - ( (254-240)  *  (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI'  ) )) )   ; 
				    set green (240 - ( (240-5)  *    (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI' ) )) )   ; 
 				    set blue  (1 + ( (5-1)  *        (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI' ) )))    ;       
 
  			       else
 				    if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) ) /  
				         set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
				         set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
				         set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
				    else
				         if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )   
				    	    set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
					    set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
					    set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
				        else    
					     set red    ( 55  - ( (55-18)  *    (( 'shoftI' - 'elsco' ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
					     set green  ( 55  + ( (232-55)  *   (( 'shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
					     set blue   ( 148 + ( (232-148)  *  (( 'shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
				        end
			            end
			       end    
                          else
                               set micore 'elsco' ; 
	                       goto SETTING_COLORS ; 
	                 end 
                 end 
                 lquote- ; 
                 SIL-FILE; quote <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 15&34&32height=&34 15&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ;SIL=FILE ;  
                  if (('grpscore['trad_nd[#nd]' #grp]' == 'minis[#grp]') && ('maxis[#grp]' != 'minis[#grp]' )) 
                        set px 'pos_x' + 2 ; set py 'pos_y' + 16 ; 
                        SIL-FILE ;    quote <text x=&34 'px'&34&32y=&34 'py'&34&32 font-size=&34 16&34&32 > &32* </text> &10 ; SIL=FILE ; 
                  end
                set ctos_sp ++ ;
                if (#nd == 'hermano' ) 
	          set pos_y 'star_y' + ('pace_y' * 'ctos_sp') ; 
                   SIL-FILE; quote <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 15&34&32height=&34 15&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ;SIL=FILE ;  
                   if (('grpscore['trad_nd[#nd]' #grp]' == 'minis[#grp]') && ('maxis[#grp]' != 'minis[#grp]' )) 
		       set px 'pos_x' + 2 ; set py 'pos_y' + 16 ; 
		       SIL-FILE ;  quote <text x=&34 'px'&34&32y=&34 'py'&34&32 font-size=&34 16&34&32 > &32* </text> &10 ; SIL=FILE ; 
                   end
                   set ctos_sp ++ ;
                  end
               stop
              set dde ++ ; 
         stop
         set star_y 'star_y' + 12 ; 
         set ctos_sp 0 ; 
         set px 'tot_width' - 216 ; 
         loop 0 nnodes [0]
                if ( ( #1 == root ) || (#1 == 'tgtsp') || (!isintree [0 #1]) ) 
                 continue ; 
                end
                if (#1 == 'tochang' )
		 	continue ;
                end
                if (#1 < root ) 
                         set bl_name $$taxon #1 ;
                        else
                         set bl_name $Node #1 ;
                end
                set pos_y 'star_y' + ('pace_y' * 'ctos_sp' ) ; 
                SIL-FILE; quote <text x=&34 5&34&32y=&34 'pos_y'&34&32 font-size=&34 12&34 > &32 $bl_name:30 </text> &10 ; SIL=FILE;  
                macfloat 7 ; 
                if (#1 == 'trad_nd['besnod]')
                 set py 'pos_y' - 13 ; 
                 SIL-FILE;  quote <rect x=&34 4 &34&32y=&34 'py'&34&32width=&34 'px'&34&32height=&34 17&34&32stroke-width=&34 2&34&32stroke=&34black&34&32fill=&34none&34&32 /> &10 ;SIL=FILE;  
                end 
                set ctos_sp ++ ;
                set nod sister[0 'tochang'] ; 
		if (  #1  ==  'nod'  ) 
                     if ('tochang' < root ) 
		      set bl_name $$taxon 'tochang' ;
		   else
		      set bl_name $Node 'tochang' ;
                   end
                 set pos_y 'star_y' + ('pace_y' * 'ctos_sp' ) ; 
		 SIL-FILE; quote <text x=&34 5&34&32y=&34 'pos_y'&34&32 font-size=&34 12&34 > &32 $bl_name:30 </text> &10 ; SIL=FILE;  
                 set ctos_sp ++ ;
                end 
         stop
         set tot_width 'tot_width' - 80 ; 
         set dist 'pos_y' + 50 ; 
         SIL-FILE;
          if (!'besever')
		  set uncua 'uncuar'-'shift' ; set trescua 'trescuar'-'shift' ; set mit 'miti'-'shift' ; set shof 'shoft'-'shift' ; 
		  macfloat 2 ; 
		  quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > 0 </text>&10 ; 
		  quote <text&32x=&34 110 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'uncua' </text> &10 ; 
		  quote <rect x=&34 108&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
		  quote <text&32x=&34 210 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'mit' </text> &10 ; 
		  quote <rect x=&34 208&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
		  quote <text&32x=&34 310 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'trescua' </text> &10 ; 
		  quote <rect x=&34 308&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
		  quote <text&32x=&34 410 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'shof' </text> &10 ; 
		  quote <rect x=&34 408&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
		  macfloat 10;  
          else
             quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 >Optimal</text>&10 ; 
             quote <text&32x=&34 400 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 >Suboptimal</text> &10 ; 
          end 
         
  set dist 'pos_y' + 60 ; 
 
  if (!'do_palette')
           quote <defs>&10<linearGradient&32id=&34graa&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
          quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
          quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(240,5,5).,stop-opacity:1&34></stop>&10; 
          quote </linearGradient>&10; 
          quote </defs>&10;
          quote <rect x=&34 310&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35graa)&34 />&10 ;
          
          quote <defs>&10<linearGradient&32id=&34grab&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
          quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(46,182,44) .,stop-opacity:1&34></stop>&10; 
          quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
          quote </linearGradient>&10; 
          quote </defs>&10;
          quote <rect x=&34 210&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35grab)&34 />&10 ;
         
          quote <defs>&10<linearGradient&32id=&34grac&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
          quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(18,232,232).,stop-opacity:1&34></stop>&10; 
          quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
          quote </linearGradient>&10; 
          quote </defs>&10;
          quote <rect x=&34 110&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35grac)&34 />&10 ;
         
          quote <defs>&10<linearGradient&32id=&34grad&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
          quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(55,55,148).,stop-opacity:1&34></stop>&10; 
          quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(18,232,232) .,stop-opacity:1&34></stop>&10; 
          quote </linearGradient>&10; 
          quote </defs>&10;
          quote <rect x=&34 10&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35grad)&34 />&10 ;
         
         
         set dist 'dist' + 40 ; 
         quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > *Optimal placement for the partition</text>&10 ;
         set dist 'dist' + 20 ;
         quote <text&32x=&34 30 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Overall optimal placement </text>&10 ;
         set dist 'dist' - 13 ;
         quote <rect x=&34 4 &34&32y=&34 'dist'&34&32width=&34 17&34&32height=&34 17&34&32stroke-width=&34 2&34&32stroke=&34black&34&32fill=&34none&34&32 /> &10 ;
         set dist 'dist' + 30  ;
	 quote <text&32x=&34 30 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Target species = $tgtname </text>&10 ;
         
   else
         set tancia 10 ; 
         loop=uup 0 19
             quote <rect x=&34 'tancia'&34 &32y=&34 'dist'&34 &32width=&34 20&34&32 height=&34 20&34&32 style=&34fill:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]')&34 />&10 ;
             set tancia 'tancia' + 20 ; 
         stop 
         set dist 'dist' + 40 ; 
	 quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > *Optimal placement for the partition</text>&10 ;
	 set dist 'dist' + 20 ;
	 quote <text&32x=&34 30 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Overall optimal placement </text>&10 ;
	 set dist 'dist' - 13 ;
	 quote <rect x=&34 4 &34&32y=&34 'dist'&34&32width=&34 17&34&32height=&34 17&34&32stroke-width=&34 2&34&32stroke=&34black&34&32fill=&34none&34&32 /> &10 ;
	 set dist 'dist' + 30  ;
	quote <text&32x=&34 30 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Target species = $tgtname </text>&10 ;

   end

   quote </svg> &10 ; 
   log/; 
   SIL=FILE; 
 
end
 
 
 
lquote - ; 
proc/; 





label COLOR_CHARGRPS
report- ;
 
k 0 ; 
tvault < 0 ; 


reroot * = 'pavote' ;
   
 lquote - ; 
 
 if ( 'trad_nd['desroot_noout']'  == (-1) ) 
    set tochang 'desroot_noout' ; 
 else
    set nod sister [0 'desroot_noout'] ; 
    set tochang 'nod' ; 
 end

/* ESTO ES PARA COLOREO DEL ARBOL DE ACUERDO A ERROR IN GROUP HAY QUE CHEQUEARLO TOO */ 
if ('doing_grp_anal')
 loop=gr 0 ('numchrgrp'-1)
     set back_maxi [#gr ] 'maxis[#gr]' ; 
     set back_mini [#gr ] 'minis[ #gr]' ;
     set maxis [#gr] 'maxi_err_grp[#gr]' ;
     set minis [#gr] 'mini_err_grp[#gr]' ;
     loop=nd 0 (nnodes [0] )
       set nod 'trad_nd[#nd]' ;  
       set back_score [#nd #gr ] 'grpscore[#nd #gr]' ;
       if ( ( #nd < root) || ('toinv[#nd]' != (-1)) ) 
         set grpscore['nod' #gr] 'falses_pos['nod' #gr]' ; 
        /* sil-all; quote grupo #gr  nodo orig=#nd, nodo en outrut:  'nod' error en  nodo de outrut 'nod' :'grpscore['nod' #gr]' copio pos ;sil=All ;*/
       else 
	 if ('toinv[#nd]' == (-1))
	     set grpscore['nod' #gr] 'falses_neg['nod' #gr]' ; 
	  /*   sil-all; quote grupo #gr  nodo orig=#nd, nodo en outrut:  'nod' error en  nodo de outrut 'nod' :'grpscore['nod' #gr]' copio neg ;sil=All ;*/
	 end
       end
      stop 
      set ndtran 'trad_nd[ 'desroot_noout' ]' ;
      set magic [#gr] 'falses_neg['ndtran' #gr]' ; 
     stop 
end
 
log/; 
 
 /* desroot_noout es el nodo que no tiene el out en el arbol enraizado original   
 Los que tienen menos 1 indican los grupos del arbol enraizado original que no estan en el enraizado en out 
 trad nod te devuelve el nodo del arbol enr en rut q corresponde al nodo entrado */


k0 ; 
tvault < 0 ; 



 

ttag-;
ttag =; 
ttag * 0 ;
tt & ; 




 set mini 'mini_all'; 
 set maxi 'maxi_all' ;
 set uncuar 'uncuar_all' ;
 set miti 'miti_all' ; 
 set span 'span_all' ;
 set trescuar 'trescuar_all' ; 
 
 set trescuarI 'maxi' + ('maxi'-'uncuar' )  ; 
 set mitiI   'maxi' + ('maxi'-'miti' )  ; 
 set uncuarI   'maxi' + ('maxi'-'trescuar' )  ;
 set shiftI 'maxi' ;
 set shoftI  'maxi' + ('maxi' - 'mini' )   ;
 
 set miniI 'shiftI' ; 
 set maxiI 'shoftI' ;  
 
 
 
 
 
 sil=all; quote minita 'mini' span 'span_all'; sil=all; 
 

 
 report- ; 
 sil=all; 
 if ('do_palette')
      set pace ('span' / 20 );  
      goto FILL_COLIM ; 
 end   
 
 sil=all; 
 
 

 if ( !'doing_grp_anal') 
   loop=no 0 'nds'
      ttag <#no ; 
      if (( #no == root) ||  (#no == 'tgtsp') || (!isintree [0 #no]) ) 
        continue ; 
      end 
      if (!'besever')  
             if ( 'mini_all' == 'maxi_all' ) 
                 ttag +#1 (0,0,0)/N#no(0) ; 
                 continue ; 
             end 
             set ccc ('core[#1]'-'mini_all' ) ; 
             if ('ccc' < 0.000000001 )
                   set micore 'mini_all' ;
		   if ('do_palette')
		         goto SETTING_COLORS ; 
		         macfloat 2 ; 
		         ttag +#1 /N#no('mini_all') ;  
		         macfloat 10 ; 
                   else
	  	       macfloat 2 ; 
		       ttag +#1 (55,55,148)/N#no('mini_all') ;  
		       macfloat 10 ; 
                   end  
             else 
                       macfloat 2 ; 
		       ttag +#1 /N#no(+'ccc') ; 
                       macfloat 10 ;
             end    
      else
         ttag +#1 (0,0,0)/N#no ;
      end
      macfloat 10 ;
  stop
end


set alturama 100 ; 
if ('numchrgrp'<= 3) 
  set sizsq 30 ;
  set alturama 70 ; 
else
  set sizsq 24 ;
end
set larama 110 ;
if ( ('numchrgrp' > 3) && ('numchrgrp' < 9) ) 
   set alturama 100 ; 
end   
if ('numchrgrp' >= 9 ) 
  set alturama 130 ; 
end 
if ( 'numchrgrp' > 12 ) 
  set ccc ( 'numchrgrp' / 3 ) ; 
  if ('ccc' * 3 < 'numchrgrp' ) 
      set ccc ++ ; 
      macfloat 0 ;
      set ccc 'ccc' ; 
      macfloat 4 ; 
  end 
  set larama 'larama' + ( ('ccc' - 4 ) * 'sizsq') + 10 ; 
  macfloat 0 ; 
  set larama 'larama' ; 
  macfloat 4 ; 
end


set nds nnodes [0] ; 

loop 0 ( 'numchrgrp'-1 ) 
  set minis[#1] 9999999 ;
  set maxis[#1] 0 ; 
stop 
set maxrange 0 ; 

loop=fs 0 ('numchrgrp'-1) 
	 loop=tq 0 nnodes [0]
		 if ('grpscore[#tq #fs]' == 7777777 ) 
		  continue ; 
		 end 
		 if ( (#tq== root ) || (#tq== 'tgtsp') || (!isintree [0 #tq]) )
		  continue ; 
		 end 
		 if ('grpscore[#tq #fs]' < 'minis[#fs]' ) 
		  set minis[#fs] 'grpscore[#tq #fs]' ; 
		 else
		  if ('grpscore[#tq #fs]' > 'maxis[#fs]' ) 
		   set maxis[#fs] 'grpscore[#tq #fs]' ; 
		  end
		 end
	 stop
	 if ( ( 'maxis[#fs]' - 'minis[#fs]') > 'maxrange' )
	  set maxrange 'maxis[#fs]' - 'minis[#fs]' ; 
	  set shift 'minis[#fs]' ; 
	  set shoft 'maxis[#fs]' ; 
	 end 
stop 

if (!'besever')
   set span 'maxrange' ; 
   set miti 'shift' + ( 'span' / 2) ; 
   set uncuar 'shift' + ( 'span' / 4 ) ;
   set trescuar 'shift' + ( (3 * 'span') / 4 );
   set trescuarI 'shoft' + ('shoft'-'uncuar' )  ; 
   set mitiI   'shoft' + ('shoft'-'miti' )  ; 
   set uncuarI   'shoft' + ('shoft'-'trescuar' )  ;
   set maxiI    'shoft' + ('shoft - 'shift' )  ;
   set shiftI 'shoft' ;
   set shoftI  'shoft' + ('shoft' - 'shift' )   ;
   set mini 'shift' ; 
   set maxi 'shoft' ; 
   if ('do_palette')
        sil=all; 
        set pace ('span' / 20 );  
        goto FILL_COLIM ; 
    end 
   end 
end 


nak = ; 





reroot  * = 'pavote' ; /* pongo el enraizado original */ /*New*/
nak= ;
tt- ; 
ttag * 0 ; 
nak = ; 
if ( !'doing_grp_anal' ) 
     ttag & $output_svggrpchar xysave eti bheight 'alturama' legup 12 thickness 4 tfontsize 35 txtsep 20 bfontsize 20 blength 'larama'   ; 
else
     ttag & $output_svggrperr xysave eti bheight 'alturama' legup 12 txtsep 20 fontsize 20 blength 'larama'  ; 
end

 loop=nd 0 'nds' 
     set ndtran 'trad_nd[#nd]' ; 
     /*quote: #nd ndtran 'ndtran' hermano 'hermano'  ; */
     if ('ndtran' == (-1) ) 
        set hermano sister [ 0 #nd] ;   
        continue ;
    end
 stop         
        






loop=grp 0 ('numchrgrp'-1)
 	 if ( 'numchrgrp' < 7 ) 
 	      set limB 5 ;
              set limA 2 ; 
              set sizsq 30 ;/*cambie era 40 */
         else
             set sizsq 24 ;
             if ( 'numchrgrp' < 13 )
                set limB 7 ;
                set limA 3 ;        
             else
                 set ccc ( 'numchrgrp' / 3 ) ; 
                  if ( ( 'ccc' * 3 ) < 'numchrgrp' ) 
                    set ccc ++ ; 
                    macfloat 0 ;
                    set ccc 'ccc' ; 
                   macfloat 4 ; 
                 end 
                  set limA 'ccc' - 1 ; 
                 set limB ('ccc' * 2 ) - 1 ; 
            end 
         end 
         if ( #grp > 'limB' ) 
                 set suma_y 'sizsq' * 2 ;
                 set suma_x 'sizsq' * ( #grp - ( 'limB' + 1 ) ) ;
         else 
            if ( #grp > 'limA' )
                set suma_y 'sizsq' ;
                set suma_x 'sizsq' * ( #grp - ( 'limA' + 1 ) ) ; 
             else
                 set suma_x 'sizsq' * #grp ; 
                 set suma_y 0 ; 
              end
         end 
         if ('besever') 
                  set shift 'minis[#grp]' ; 
                  set shoft 'maxis[#grp]' ; 
                  set span 'maxis[#grp]' - 'minis[#grp]' ; 
                  set miti 'shift' + ('span'/2) ; 
                  set uncuar 'shift' + ( 'span' / 4 ) ;
                  set trescuar 'shift' + ( (3 * 'span') / 4 );
                  set mini 'shift' ; 
                  set maxi 'shoft' ; 
                  set trescuarI 'shoft' + ('shoft'-'uncuar' )  ; 
                  set mitiI   'shoft' + ('shoft'-'miti' )  ; 
	          set uncuarI   'shoft' + ('shoft'-'trescuar' )  ;
                  set maxiI    'shoft' + ('shoft - 'shift' )  ;
                  set shiftI 'maxi' ;
		  set shoftI  'maxi' + ('maxi' - 'mini' )   ;
		  if ('do_palette')
		     set pace ('span' / 20 ); 
			  sil=all; 
		       goto FILL_COLIM ; 
                   end
          end
          loop=nd 0 'nds' 
               set ndtran 'trad_nd[#nd]' ; 
               if ('ndtran' == (-1) ) 
	                      continue ;
               end
               set nod #nd ; 
               if ( (#nd == root) || (#nd == 'tgtsp') || (!isintree [0 #nd]) ) 
                       continue ; 
               end
               if ( ('listax[#nd]' == 1) && (#nd < root) )
                   continue ; 
               end
               set pos_x ('eti[#nd 0]' - 'eti[anc[0 #nd] 0]')/ 12 + 'eti[anc[0 #nd] 0]' + 'suma_x' ; 
               set pos_y 'eti[#nd 1]' + 4 + 'suma_y'; 
               if (('maxis[#grp]'-'minis[#grp]') < 0.000000001 )
                      set blue 130 ; 
                      set red 130 ; 
                      set green 130 ; 
               else
			   if ( 'grpscore['ndtran' #grp]' == 7777777  || ('magic[#grp]' ==  7777777 ))  /* esto hay que verlo porque no se para que es */
			      set red 0 ; set green 0 ; set blue 0 ; 
			   else 
				     if ( (#nd == 'tochang') && ('doing_grp_anal' )) 
				             if ('minis [#grp]' < 'shift' ) 
						  set elsco 'magic[#grp]' + ('shift' - 'minis [#grp]') ;
					       else
						 set elsco 'magic[#grp]'  - ('minis [#grp]' - 'shift' ) ; 
					       end 
				     else
				            if ('minis [#grp]' < 'shift' ) 
				     		 set elsco 'grpscore['ndtran' #grp]' + ('shift' - 'minis [#grp]') ;
				     	    else
				     		 set elsco 'grpscore['ndtran' #grp]' - ('minis [#grp]' - 'shift' ) ; 
					    end 
				     end 
				     if (!'do_palette')
							set elsco 'shoft' + ('shoft' - 'elsco') ;  
						       if ('elsco' < ( 'uncuarI') ) ; /*240,5,5 a  254,240,1 */ 
							 set red   (254 - ( (254-240)  *  (( 'uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
							 set green (240 - ( (240-5)  *   (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
							 set blue  (1 +   ( (5-1)  *     (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )))    ;   ;   
						       else
							     if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) )  
								 set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
								 set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
								 set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
							     else
								 if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )   
									set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
									set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
									set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
								 else   /*18,232,232 a 55,55,148*/
									set red    ( 55  - ( (55-18)  *    (( 'shoftI' - 'elsco' ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
									set green  ( 55  + ( (232-55)  *   (( 'shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
									set blue   ( 148 + ( (232-148)  *  (('shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
								 end
							    end
						       end
					       else
						  set micore 'elsco' ; 
						  sil=all; 
						  goto SETTING_COLORS ; 
					       end

			 end 
               end 
           ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:white&34 /> &10 ;sil=all; 
           set pos_y 'pos_y' + 22 ; 
           set pos_x 'pos_x' + 11 ; 
           
          if ( ('grpscore['ndtran' #grp]' == 'minis[#grp]') && (!( ('maxis[#grp]'-'minis[#grp]') < 0.000000001 ) ) ) 
              set dde 'pos_y'  ;
              set ctos 'pos_x'  ; 
              if (!'doing_grp_anal')
                   if ('numchrgrp' > 6 ) 
                      set dde 'dde' - 3  ;
                      set ctos 'ctos' - 3; 
                      ttag &+ write <text x=&34 'ctos'&34&32y=&34 'dde'&34&32 font-size=&34 12&34&32 > * </text> &10 ; 
                   else
                      ttag &+ write <text x=&34 'ctos'&34&32y=&34 'dde'&34&32 font-size=&34 20 &34&32 > * </text> &10 ; 
                   end
             end 
           end
           if (#nd == 'hermano' ) 
             set nod sister [ 0 'hermano'] ; 
           end
           if (   ( #nd ==  'hermano' )  &&   (!'doing_grp_anal')  ) 
              set pos_x ('eti['nod' 0]' - 'eti[anc[0 'nod'] 0]')/ 12 + 'eti[anc[0 'nod'] 0]' + 'suma_x' ; 
	      set pos_y 'eti['nod' 1]' + 4 + 'suma_y';    
              ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:rgb('red','green','blue')&59 stroke:white&34 /> &10 ;sil=all; 
	      set pos_y 'pos_y' + 22 ; 
	      set pos_x 'pos_x' + 11 ; 
	      if ( ('grpscore['ndtran' #grp]' == 'minis[#grp]') && (!( ('maxis[#grp]'-'minis[#grp]') < 0.000000001 ) ) )                 
			  set dde 'pos_y'  ;
			  set ctos 'pos_x'  ; 
			  if ('numchrgrp' > 6 ) 
			       set dde 'dde' - 3  ;
			       set ctos 'ctos' - 3; 
			       ttag &+ write <text x=&34 'ctos'&34&32y=&34 'dde'&34&32 font-size=&34 12&34&32 > * </text> &10 ; 
			    else
			       ttag &+ write <text x=&34 'ctos'&34&32y=&34 'dde'&34&32 font-size=&34 20 &34&32 > * </text> &10 ; 
			     end
	       end 
          end        
     stop
stop
 
set dist 0 ; 

loop 0 (nnodes [0]) 
 if ('eti [#1 1]' > 'dist')
    set dist 'eti [#1 1]' ; 
 end
stop 
 
set posx 'dist' + 230 ; 

ttag &+ write <text&32x=&34 120&34 &32 y=&34 'posx'&34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Character groups </text>&10 ; 
set posx 'posx' - 20 ;

loop=cd 0 ('numchrgrp'-1)
 if ('numchrgrp' < 7) 
  set limB 5 ;
  set limA 2 ; 
 else
  if ( 'numchrgrp' < 13)
   set limB 7 ;
   set limA 3 ;          
  else
   set ccc ( 'numchrgrp' / 3 ) ; 
         if ('ccc' * 3 < 'numchrgrp' ) 
           set ccc ++ ; 
           macfloat 0 ;
           set ccc 'ccc' ; 
           macfloat 4 ; 
    end 
    set limA 'ccc' - 1 ; 
    set limB ('ccc' *2 ) - 1 ; 
  end 
 end 
 if (#cd > 'limB' ) 
                 set suma_y 23 * 2 ;
                 set suma_x 23 * (#cd - ('limB' + 1 )) ;
 else 
         if (#cd > 'limA' )
                set suma_y 23 ;
                set suma_x 23 * (#cd - ('limA' + 1 )) ; 
         else
                set suma_x 23 * #cd ; 
          set suma_y 0 ; 
         end
 end 
 set pos_x 'suma_x' + 20 ;
 set pos_y 'suma_y' + 'posx' ;
 ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 22&34&32height=&34 22&34&32style=&34fill:white&59 stroke:black&34 &32stroke-width=&34 0.1&34 /> &10 ;sil=all ; 
 set dde #cd ;
 set pos_x 'pos_x' + 5 ; set pos_y 'pos_y' + 14 ; 
 ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34  > 'dde' </text>&10 ; 
stop
set pos_y 'pos_y' + 30 ; 

if (!'doing_grp_anal' ) 
	 set pos_x ('pos_y' + 30) ; 
	 ttag&+ write <text&32x=&34 20 &34 &32 y=&34 'pos_x' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 >Target Species=&32 $tgtname </text>&10 ; 
	 set pos_x ('pos_y' + 80) ; 
	 if ('numchrgrp' > 6 ) 
		  ttag&+ write <text&32x=&34 20 &34 &32 y=&34 'pos_x' &34 &32stroke-width=&34 1&34&32 font-size=&34 22&34 > * </text>&10 ; 
	 else
		  ttag&+ write <text&32x=&34 20 &34 &32 y=&34 'pos_x' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 > * </text>&10 ; 
	 end
	 set pos_x ('pos_y' + 70) ;
	 ttag&+ write <text&32x=&34 80 &34 &32 y=&34 'pos_x' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Optimal placement for that group of chars. </text>&10 ; 
end

set posx 'dist' + 130 ; 
lquote [ ; 
if ('doing_grp_anal' ) 
 ttag&+ write <text&32x=&34 20 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 >Smaller errors</text>&10 ; 
 ttag&+ write <text&32x=&34 490 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 >Larger errors</text> &10 ; 
end
set posx 'posx' + 20 ;


goto WRITE_BARS  ; 

ttag & ;

if ('doing_grp_anal')
 loop 0 nnodes [0]
 loop=gr 0 ('numchrgrp'-1)
  set minis [ #gr ] 'back_mini [#gr ]' ;
  set maxis [ #gr ] 'back_maxi [#gr ]' ;
  loop=nd 0 ('nnodes [0] )
   set grpscore[#nd #gr] 'back_score [#nd #gr ]' ;
  stop 
 stop 
 stop
end

 


proc/; 



label WRITE_BARS 
 set dist 'posx' ;  
 if (!'besever')
    if ('doing_grp_anal')
	set uncua 'uncuar'-'shift' ; set trescua 'trescuar'-'shift' ; set mit 'miti'-'shift' ; set shof 'shoft'-'shift' ; 
	macfloat 2 ; 
	ttag&+ write<text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > 0 </text>&10 ; 
	ttag&+ write<text&32x=&34 160 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> 'uncua' </text> &10 ; 
	ttag&+ write<rect x=&34 159&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
	ttag&+ write<text&32x=&34 310 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> 'mit' </text> &10 ; 
	ttag&+ write<rect x=&34 309&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
	ttag&+ write<text&32x=&34 460 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> 'trescua' </text> &10 ; 
	ttag&+ write<rect x=&34 459&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
	ttag&+ write<text&32x=&34 610 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> 'shof' </text> &10 ; 
	ttag&+ write<rect x=&34 608&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
	macfloat 10;
    else
       set uncua 'uncuar'-'shift' ; set trescua 'trescuar'-'shift' ; set mit 'miti'-'shift' ; set shof 'shoft'-'shift' ; 
	macfloat 2 ; 
	ttag&+ write<text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > 0 </text>&10 ; 
	ttag&+ write<text&32x=&34 160 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+ 'uncua' </text> &10 ; 
	ttag&+ write<rect x=&34 159&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
	ttag&+ write<text&32x=&34 310 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+ 'mit' </text> &10 ; 
	ttag&+ write<rect x=&34 309&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
	ttag&+ write<text&32x=&34 460 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+ 'trescua' </text> &10 ; 
	ttag&+ write<rect x=&34 459&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
	ttag&+ write<text&32x=&34 610 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+ 'shof' </text> &10 ; 
	ttag&+ write<rect x=&34 608&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
	macfloat 10;
     end
 else
   if (!'doing_grp_anal')
	ttag&+ write<text&32x=&34 500 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 18&34 >Suboptimal</text>&10 ; 
	ttag&+ write<text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 18&34 >Optimal</text> &10 ; 
   end  
 end 
 set dist 'posx' + 10 ; 
 if (!'do_palette')     
	 ttag&+ write <defs>&10<linearGradient&32id=&34graa&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(240,5,5).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 460&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35graa)&34 />&10 ;

	 ttag&+ write <defs>&10<linearGradient&32id=&34grab&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 310&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grab)&34 />&10 ;

	 ttag&+ write <defs>&10<linearGradient&32id=&34grac&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(18,232,232) .,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 160&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grac)&34 />&10 ;

	 ttag&+ write <defs>&10<linearGradient&32id=&34grad&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(55,55,148).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(18,232,232).,stop-opacity:1&34></stop>&10; 
	 ttag&+ write </linearGradient>&10; 
	 ttag&+ write </defs>&10;
	 ttag&+ write <rect x=&34 10&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grad)&34 />&10 ;
  else 
	 set tancia 10 ; 
	 loop=uup 0 19
	    ttag&+ write <rect x=&34 'tancia'&34 &32y=&34 'dist'&34 &32width=&34 30&34&32 height=&34 30&34&32 style=&34fill:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]')&59stroke:none &34 />&10 ;
	    set tancia 'tancia' + 30 ; 
	 stop  
   end 
   set posx 'posx' + 50 ; 

proc/; 


label CALCULATE_ERRORS 
report- ;
set dde 0 ; 
lquote = ; lquote [ ; 
if ('noda' && 'doing_grp_anal' ) 
    k0 ; 
    tv < 0 ; 
    loop=yg 0 nnodes [0]
      set falses_pos [#yg 'cual'] 7777777 ; 
      set falses_neg [#yg 'cual'] 7777777 ; 
      set sp_pos_grp [#yg 'cual'] 0 ;
      set sp_neg_grp [#yg 'cual'] 0 ;
    stop
    set dde 'cual' + 1 ; 
    set blues ['dde'] 7777777 ;
    set reds ['dde'] 7777777 ;
    sil-file; quote Error not calculated for char. group 'cual' . All chars. missing for target species &10; sil=all; 
    k 0 ; 
   set noda 0 ;
   proc/; 
end 
k0 ; 
loop 0 ('nosize'-1)
   set negg [ #1 ] 0 ; set poss [ #1 ] 0 ; 
stop 
 

set blue 0 ; set red 0 ; set green 0 ; 
/* recorro todos los arboles, si hay error en algunos pero no en todos entonces es ambiguedad */


goto MAGIC_FOR_OUT ;  

 
loop=tx 0 ntax 
	 constr - ; 
	 force ] ; 
	 set prunne #tx ; 
	 k0 ; 
	 tv < 0 ; 
	 
	 if ( (#tx == root) || ( #tx == 'tgtsp' ) || (!isintree [0 #tx]) ||  (#tx == outgroup) ) 
	   continue ; 
	 end
	 if ('muymiss_sp[#tx ]' == 1 )
	   set nodo $$taxon #tx ; 
	   sil-file; quote $nodo(#tx)= Not analyzed (Missing data > 'limmis' ) &10; sil=all; 
	   continue ; 
	 end 
	 prunt 0/#tx ;
	 force /&0 ;
	 constrain = ;  
	 k 0 ; 
	 mu 3 = h 1 ;
	 bb ;
	 if ( ntrees >= 999 )
	    tch 0.998 ; 
	 end 
	 tvault < 0 ;
	  set ref_tree ntrees ;
	 loop=nn 0 ( nnodes['ref_tree'] ) 
	    set yacambN [#nn] 0 ; set yacambP [#nn] 0 ; 
	 stop
	 set eltax #tx ; 
	 set nodo $$taxon #tx ; 
	 goto NODE_DISTANCE ; 
	 set nodo $$taxon #tx ; 
	 macfloat 3 ; 
	 sil-file; quote $nodo(#tx)= 'min_dist'/'mean_dist'/'max_dist' &10 ; sil=all; 
	 set blue 'blue' + 'min_dist' ;
	 set red 'red' + 'max_dist' ;
	 set green 'green' + 'mean_dist' ; 
	 macfloat 7 ; 
	 set hayigual 0 ; 
	 if ('doamb')  
	   loop 0  ( ntrees -1 ) 
	 	    if (eqtrees ['opt_tree' 'ref_tree'] ) 
	 	   	set hayigual 1 ;
	 	  	endloop 
	 	    end 
	   stop
	   if ('hayigual' ) 
	       sil=all; quote una de las posiciones de #tx corresponde con la correcta ; sil=all; 
	      continue ; 
	    end
	 end
	 loop=la 0 ( ntrees-1 ) 
	          set opt_tree #la ;
		  if (eqtrees ['opt_tree' 'ref_tree'] ) 
		     continue ; 
		  end 
	          if ('yacambN[#tx]' == 0 ) 
		      set negg [#tx] ++ ; 
		      set yacambN[#tx] 1 ; 
		  end
		  set mano sister [ 'opt_tree' #tx ] ; 
		  if ('mano' < root ) 
		    if ('yacambP['mano']' == 0 ) 
			 set poss ['mano'] ++ ;
			 set yacambP['mano'] 1 ; 
			 if ('mano' == 5 )
			   sil=all; quote entro #tx en   'mano' ; sil=all; 
			 end 
		     end
		  else
		     set onetocero grptogrp 'ref_tree' 'opt_tree' ;
		     set man_trad 'onetocero ['mano']' ; 
		     if ('man_trad' > 0 )
		         if ('yacambP['man_trad']' == 0 ) 
		    	   set poss ['man_trad'] ++ ;
		  	   set yacambP['man_trad'] 1 ; 
			    sil=all; quote caca 'man_trad' pis 'poss ['man_trad']' ; sil=all;    
		        end
		     end
		  end
		  loop=nd 0 (nnodes ['ref_tree']) 
		         set onetocero grptogrp 'opt_tree' 'ref_tree' ;
		         if (#nd == #tx || (!isintree['ref_tree' #nd] ) ) 
			        if (#tx > 10000  ) daaa end     
				continue ; 
			 end
			 if ('onetocero [#nd]' < 0 )  
			         ag - 0 ;
				 ag = 0 @'ref_tree' #nd ; 
				 set tadentro 0 ; 
				 if ( isinagroup [0 #tx] ) 
				   set tadentro 1 ; 
				 end 
				 if ('tadentro') 
				    if ('yacambN[#nd]' == 0 ) 
				        set negg [ #nd ] ++ ; 
				        set yacambN[#nd] 1 ;
				    end 
				 else
			            if ('yacambP[#nd]' == 0 ) /* para no sumarle dos veces al mismo nodo que fue ya considerado q tiene error por este taxon */ 
				      set poss [ #nd ] ++ ;
				      sil=all; quote Nodo #nd cambio por taxon #tx ; sil=all ; 
				      if ( #nd == 0 )
			  		sil=all; quote entro #tx en  'mano'  despues ; sil=all; 
			              end 
				      set yacambP[#nd] 1 ;
				      if (#tx > 1000 ) gaaa end 
			            end
				end
			 end
		  stop
		set mano sister [ 'opt_tree' outgroup ] ; 
		set raiz root ; 
                set dientes deslist [ 'opt_tree' 'mano'] ;
		loop=di 0 1
	            sil=all; quote placing #tx 'mano' mano dientes[#di] 'dientes[#di]' out= outgroup ; sil=All; 
		    if ('dientes[#di]' == #tx )
		      if ('yacambN[outgroup]' == 0 ) 
		        set poss[outgroup] ++ ; 
		        set yacambN[outgroup] 1 ;
		      end
		    end 
	        stop     
	 stop  
	 set dde ntrees + 1; 
stop


sil=all; quote error en nodo 0 'poss [ 0 ]'  ; 


k 0 ; 
tv < 0 ; 


set blue 'blue' / 'sps_inn' ; set red 'red' / 'sps_inn' ;  set green 'green' / 'sps_inn' ; 



if (!'doing_grp_anal')
 set blues[0] 'blue' ;
 set reds [0] 'red' ;
 set greens [0] 'green' ; 
else
 set dde 'cual' + 1 ;
 set blues['dde'] 'blue' ;
 set reds ['dde'] 'red' ;
 set greens ['dde'] 'green' ;
 
end

lquote [ ; 
lquote =; 
sil-file; quote Taxon and character sampling in error calculation &10; sil=all; 
sil-file; quote N species : 'sps_inn' &10; sil=all;
sil-file; quote Active characters  &10; sil=all;
sil-all; 
loop=klm 0 nchar 
 if (isact[#klm] ) 
 quote #klm,&32; 
 end
stop 
sil=all; 
sil-file ; quote &10 ; sil=all ;
if ('guicherr' == 0 ) sil-file; quote Error in placement Avg. Minimum D: 'blue'  &10; sil=all;  end
if ('guicherr' == 1 ) sil-file; quote Error in placement Avg. Mean D: 'green'  &10; sil=all;  end
if ('guicherr' == 2 ) sil-file; quote Error in placement Avg. Max D: 'red'  &10; sil=all;  end




if ('doing_grp_anal') 
 set mini_err_grp['cual'] 9999999 ; 
 set maxi_err_grp['cual'] 0 ; 
	 loop=nd 0 (nnodes[0] ) 
	   set falses_neg [#nd 'cual' ] 'negg[#nd]' ; 
	   set falses_pos [#nd 'cual' ] 'poss[#nd]' ;
	 stop
else
   set mini_err 9999999 ; 
   set maxi_err 0 ; 
   loop=nd 0 (nnodes[0] ) 
	  set false_neg [ #nd ] 'negg[#nd]' ; 
	  set false_pos [ #nd ] 'poss[#nd]' ; 
  stop
end

 

set dde 'sps_inn' ; 
set lodes deslist [ 0 root] ; 
set posy listsize - 1 ; 
set green 0 ; 

 
loop=nd 0 (nnodes [0])
  set ndo #nd ;
  if ( ( 'ndo' == root ) || (!isintree [0 'ndo']) ) 
   continue ; 
  end 
  set posy root ; 
  if ( ('ndo') <= root ) 
          if ('doing_grp_anal') 
             if ('muymiss_sp['ndo']' == 0 ) 
                  set falses_neg['ndo' 'cual'] 'falses_neg['ndo' 'cual']' * 100 ; 
                  set dde 'sps_inn' - 1 ; 
                 set sp_neg_grp ['ndo' 'cual'] 1 ; 
             else
                 set falses_neg['ndo' 'cual'] 7777777 ; 
                 set dde 'sps_inn' ;
                 set sp_neg_grp['ndo' 'cual'] 0 ; 
             end
             set falses_pos['ndo' 'cual'] ('falses_pos['ndo' 'cual']'/('dde')) * 100 ;  
             set sp_pos_grp['ndo' 'cual'] 'dde' ; 
          else

            if ('muymiss_sp['ndo' ]' == 0 )
                  set false_neg['ndo'] ('false_neg['ndo']' * 100 ) ; 
                  set dde 'sps_inn' - 1 ; 
                  set sp_neg['ndo'] 1   ; 
            else
                  set false_neg['ndo'] 7777777 ;
                  set dde 'sps_inn' ; 
                  set sp_neg ['ndo'] 0 ; 
            end
            set false_pos['ndo'] ( 'false_pos['ndo']' / ( 'dde' ) ) * 100 ; 
            set sp_pos['ndo] 'dde' ; 
          end
 
 end
 if ('ndo' > root ) 
        ag-; 
         ag = 0 @0 'ndo' ;
         set tadentro 0 ; 
         loop=tt 0 ntax 
           if (('muymiss_sp[#tt ]' == 0 ) && (isinagroup [0 #tt] ) ) 
             set tadentro ++ ;
           end
         stop 
         if ('doing_grp_anal')
            if (('sps_inn'-'tadentro') == 0 )
                set falses_pos [ 'ndo' 'cual' ] 7777777 ; 
                set sp_pos_grp ['ndo' 'cual'] 0 ; 
             else 
                set falses_pos['ndo' 'cual'] ('falses_pos['ndo' 'cual']'/(('sps_inn')-'tadentro')) * 100 ; 
                set sp_pos_grp ['ndo' 'cual'] ('sps_inn'-'tadentro' ) ; 
            end 
            if ('tadentro' != 0 )  
               set falses_neg['ndo' 'cual'] ('falses_neg['ndo' 'cual']'/'tadentro') * 100 ;  
               set sp_neg_grp ['ndo' 'cual'] 'tadentro' ; 
            else
               set falses_neg['ndo' 'cual'] 7777777 ;
               set sp_neg_grp ['ndo' 'cual'] 0 ; 
            end 
         else
           sil=all; quote nodo 'ndo' false_pos['ndo']  'false_pos['ndo']' tadentro 'tadentro' sps_inn 'sps_inn'  ; sil=all; 
           if (('sps_inn'-'tadentro') == 0 ) 
               set false_pos['ndo'] 7777777 ; 
               set sp_pos ['ndo' ] 0 ; 
           else 
               set false_pos['ndo'] ('false_pos['ndo']'/(('sps_inn') - 'tadentro') ) * 100 ; 
               set sp_pos ['ndo' ] ('sps_inn' - 'tadentro') ; 
           end
            if ('tadentro' != 0 ) 
                 set false_neg['ndo'] ('false_neg['ndo']'/ 'tadentro') * 100 ; 
                 set sp_neg ['ndo' ] 'tadentro' ; 
            else
               set false_neg ['ndo'] 7777777 ; 
               set sp_neg ['ndo' ] 0 ; 
           end
         end
         ag-; 
 end
stop 

 


set mini_err 999999999999 ; 
set maxi_err 0 ; 




lquote - ; 



loop=nd 0 (nnodes[0] ) /* tengo q chequar que esto este bien. Ademas tengo que terminar los errrores impresos q le faltan la inversion y ademas que too se prunee el out */
	 if (!isintree [0 #nd])
   	    continue ;
	 end
	 set nod 'trad_nd[#nd]' ;
	 sil=all ; quote  'toinv[#nd]' nod 'nod' #nd  trad_nd[nd] 'trad_nd[#nd]' ; sil=all ;
	 if (!'doing_grp_anal')        
	           if ('toinv[#nd]' == (-1) ) 
	              set error 'false_neg['nod']' ; 
	           else
	              set error 'false_pos['nod']' ;
	           end 
		  if ('error' == 7777777 ) 
		      continue ; 
		  end
		  if ('error' < 'mini_err') 
		     set mini_err 'error' ;
		  end 
		  if ('error' > 'maxi_err') 
		     set maxi_err 'error' ;
		  end
	 else
	        if ('toinv[#nd]' == (-1) ) 
	  	       set error 'falses_neg['nod' 'cual']' ; 
	        else
	  	       set error 'falses_pos['nod' 'cual']' ;
	           end
		   if ('error' == 7777777 ) 
		     continue ; 
		   end 
		   if ('error' < 'mini_err_grp['cual']' ) 
		      set mini_err_grp['cual'] 'error' ;
		   end 
		   if ('error' > 'maxi_err_grp['cual']' ) 
		      set maxi_err_grp['cual'] 'error' ;
		   end
	 end 
stop
 

lquote- ; 


if('calc_prob')
  goto ERROR_PROBABILITIES ; 
end
sil=all; quote saliendo de error prob ; 
set dde 0 ; 
sil=all;

k0 ; 

 
proc/; 



label LAUNCH_ERROR_CALCULATION 

loop=yy 0 nchar 
  set bak_listchar [#yy] 'listchar [#yy]' ; 
stop 

loop=ll 0 ntax 
 if ( 'listax[#ll]' == 1 )
  taxc - #ll ; 
 end 
stop
tv <0 ; 




if (('doerror_w_tgt') && (!'notarget') ) 
  set guichsp 'tgtsp' ; 
  goto MY_MISSING ; 
  k0 ; 
end 
  
set test_grp 9999 ; 
k0 ; 
tv < 0 ; 
set sps_inn 0 ; 
set doing_grp_anal 0 ; 
loop=hj 0 ntax 
 set guichsp #hj ;
   if ( ( 'guichsp' == 'tgtsp' ) || (!isintree [0 'guichsp']) ) 
      continue ; 
   end
   goto MY_MISSING ; 
   goto TEST_SPECIES_CHARSAMPLING ; 
stop 
k 0 ; 
lquote -; 
lquote ] ; 
if ('char_anal' ) 
  log $toter_string ; 
  sil-file; quote --------------------- NODAL DISTANCE FOR EACH BACKBONE SPECIES (Min/Avg/Max) -------------------------------; sil=alL; 
end

goto CALCULATE_ERRORS ;

 

if ('doerror_w_grps') 
	  loop=yy 0 nchar 
	    set listchar [#yy] 'bak_listchar [#yy]' ; 
	  stop
	  set doing_grp_anal 1 ; 
	  set cual 0; 
	  loop=up 0 ( 'numchrgrp'-1 )
	 
	    k0 ; 
	    tv < 0 ; 
	    set sps_inn 0 ; 
	    if (('doerror_w_tgt') && (!'notarget') ) 
	      set guichsp 'tgtsp' ; 
	      goto MY_MISSING ; 
	    end 
	    cc ] . ; cc [ {#up} ;
	    loop=er 0 nchar
	      if ( isinxgroup[ #up #er ] ) 
		if ('listchar[#er]' == 0 ) 
		 cc ] #er ; 
		end
	       end
	     stop 
	     set test_grp #up ; 
	   loop=hj 0 ntax 
		  set guichsp #hj ;
		  if (  ( 'guichsp' == 'tgtsp' ) || (!isintree [0 'guichsp']) )  /* ('guichsp' == outgroup) ||*/ 
		      continue ; 
		  end
		  set noda 0 ; 
		  goto MY_MISSING ; 
		  goto TEST_SPECIES_CHARSAMPLING ; 
	   stop
	   k 0 ; 
	   if ('char_anal') 
	      sil-file; quote --------------------- NODAL DISTANCE FOR EACH BACKBONE SPECIES   char. partition=  $xgroup #up (Min/Avg/Max) ------------------------- &10; sil=all;; 
	   end
	   goto CALCULATE_ERRORS ; 
	   set cual ++ ; 
	stop 
	  cc [ . ; 
	  loop=yy 0 nchar 
	    set listchar [#yy] 'bak_listchar [#yy]' ; 
	    if ('listchar [#yy]' == 0) 
	     cc ] #yy ; 
	    end 
	  stop


end


 macfloat 3 ; 
 if ('char_anal')
	   sil-file; quote --------------------- Errors in Placement Summary --------------------- &10; sil=all; 
	   if ('calc_prob') 
	     sil-file; quote Dataset ,EP , Probability &10; sil=all; 
	    if ('guicherr' ==  0 ) sil-file; quote Complete ,'blues[0]', 'prob[0 0]'  &10; sil=all; end
	    if ('guicherr' ==  1 ) sil-file; quote Complete ,'greens[0]','prob[0 1]' &10; sil=all; end
	    if ('guicherr' ==  2 ) sil-file; quote Complete ,'reds[0]',  'prob[0 2 ]' &10; sil=all; end
	  else
	      sil-file; quote Dataset ,EP &10; sil=all; 
	      if ('guicherr' ==  0 ) sil-file; quote Complete ,'blues[0]'  &10; sil=all; end
	      if ('guicherr' ==  1 ) sil-file; quote Complete ,'greens[0]' &10; sil=all; end
	      if ('guicherr' ==  2 ) sil-file; quote Complete ,'reds[0]'   &10; sil=all; end
	  end
	  
	 if ('doerror_w_grps'  )
	 loop=uu 0 ('numchrgrp'-1)
	  set dde #uu + 1 ; 
	   if ( 'blues['dde']' == 7777777) 
	      sil-file; quote $xgroup #uu ,NA ,NA &10; sil=all; 
	   else
	        if ('calc_prob')
	          if ('guicherr' ==  0 )  sil-file; quote $xgroup #uu, 'blues['dde']' ,'prob['dde' 0]' &10 ; sil=all; end 
	          if ('guicherr' ==  1 )  sil-file; quote $xgroup #uu, 'greens['dde']','prob['dde' 1]' &10 ; sil=all; end 
	          if ('guicherr' ==  2 )  sil-file; quote $xgroup #uu, 'reds['dde']'  ,'prob['dde' 2 ]'&10 ; sil=all; end 
	        else
	          if ('guicherr' ==  0 ) sil-file; quote $xgroup #uu, 'blues['dde']'  &10 ; sil=all; end
	          if ('guicherr' ==  1 ) sil-file; quote $xgroup #uu, 'greens['dde']' &10 ; sil=all; end
	          if ('guicherr' ==  2 ) sil-file; quote $xgroup #uu, 'reds['dde']'   &10 ; sil=all; end
	          
	        end 
	    end
	 stop 
	 end 
  log/ ; 
end 
  cc [ . ; 
  loop=yy 0 nchar 
     set listchar [#yy] 'bak_listchar [#yy]' ; 
     if ('listchar [#yy]' == 0) 
      cc ] #yy ; 
     end 
  stop
if ('doerror_w_grps'  && 'char_anal' )
 goto PRINT_ERROR_BARS ;  
end 
if (  'doerror_w_grps'  && 'clade_anal' ) 
    goto COLOR_CHARGRPS; 
end
set doing_grp_anal 0 ; 
 
 

 
 

if ('clade_anal') 
	 log $Los_errors ; 
	 lquote = ; 
	 lquote [ ; 
	 k0 ; 
	 tv < 0 ; 

	 sil-file ; quote Placement error for each subtree of reference tree &10; sil=all; 
	 sil-file ; quote ,Complete_dataset, Complete_dataset,; sil=all; 
	 if ('doerror_w_grps'   ) 
	   loop=gc 0 ('numchrgrp'-1)
	      set bl_name $$xgroup #gc ; 
	      sil-file; quote $bl_name,$bl_name, ;sil=all; 
	   stop
	 end 
	 sil-file; quote&10 Subtree,ISE,OSE ; sil=all; 
	 if ('doerror_w_grps'   ) 
	    loop=gc 0 ('numchrgrp'-1)
	       sil-file; quote ISE,OSE, ; sil=all; 
	    stop
	 end 
	 sil-file; quote &10 ; sil=all; 
	 k0 ; 
	 tv < 0  ; 
	 macfloat 3 ; 
	 table /3 ; 
  


       
	 reroot * = 'pavote';  /*  para que quede como el original */ 
 
        loop=dd 0 ( nnodes [ 0 ] ) 
	         set ndtran 'trad_nd[#dd]' ; 
	         sil=all; quote Nodo #dd ndtran 'trad_nd[#dd]'  toinv[#dd] 'toinv[#dd]' fp[ndtran] 'false_pos['ndtran']' fn[ndtran] 'false_neg['ndtran']' fp[dd]   'false_pos[#dd]' fn[#dd] 'false_neg[#dd]' ; sil=all; 
		 sil=all ; quote Nodo #dd 'desroot_noout' 
		 if ( (#dd == root) || ( #dd == 'tgtsp' ) || (!isintree [0 #dd]) ) 
		     continue ; 
		  end
	          if (#dd !='ogrup' ) 
			  if (#dd == 'desroot_noout' )
				set ndtran 'trad_nd[sister [ 0 'desroot_noout']]'   ;
				set erne   'false_pos['ndtran']'  ; 
				set erpo   'false_neg['ndtran']' ;
				sil=all; quote entro en 1 ; sil=all; 
			 else 
			     if ('toinv[#dd]' == (-1)) 
				 set erne   'false_pos['ndtran']'  ; 
				 set erpo   'false_neg['ndtran']' ;
				 sil=all; quote entro en 2 ; sil=all; 
			     else
				  set erpo 'false_pos['ndtran']'  ; 
				  set erne 'false_neg['ndtran']' ;
				  sil=all; quote entro en 3 ; sil=all; 
			     end
			  end  
	          else
	            set erpo 'false_pos[ 'trad_nd['desroot_noout']']' ;  
	          end 
		  sil=all ; quote Nodo #dd desroot_noout 'desroot_noout'  toinv[#dd] 'toinv[#dd]'   ;
	 
		  if ( #dd <= ntax ) 
			   set bl_name $$taxon #dd ;
			   if (('erpo' != 7777777) && ( 'erne' != 7777777) )
			    set posx 'erpo'/100 ; set posy 'erne'/100 ;                     
			    sil-file; quote $bl_name,'posx','posy', ; sil=all; 
			   end
			   if (('erpo' == 7777777) && ( 'erne' != 7777777))
				  set posy 'erne'/100 ;  
				  sil-file; quote $bl_name,NA,'posy', ; sil=all; 
			   end
			   if (('erpo' != 7777777) && ( 'erne' == 7777777))
				  set posx 'erpo'/100 ;
				  sil-file; quote $bl_name,'posx', NA , ; sil=all; 
			   end
			   if (('erpo' == 7777777) && ( 'erne' == 7777777)) 
				  sil-file; quote $bl_name,NA, NA , ; sil=all; 
			   end
		  else
		       if (('erpo' != 7777777) && ( 'erne' != 7777777)) 
			     set posx 'erpo'/100 ; set posy 'erne'/100 ;
				sil-file; quote Nd #dd,'posx','posy', ; sil=all; 
			   end
			   if (('erpo' == 7777777) && ( 'erne' != 7777777)) 
				  set posy 'erne'/100 ;  
				    sil-file; quote Nd #dd,NA,'posy', ; sil=all; 
			   end
			   if (('erpo' != 7777777) && ( 'erne' == 7777777)) 
			       set posx 'erpo'/100 ;
			       sil-file; quote Nd #dd, 'posx',NA ,; sil=all; 
			   end
			   if (('erpo' == 7777777) && ( 'erne' == 7777777)) 
				sil-file; quote Nd #dd,NA, NA , ; sil=all; 
			   end

		  end
		  if ('doerror_w_grps'   )
			    sil-file ;  
			    loop=gc 0 ('numchrgrp'-1)
			      if (#dd !='ogrup') 
						if (#dd == 'desroot_noout' )
							set ndtran 'trad_nd[sister [ 0 'desroot_noout'] ]'   ;
							set erne   'falses_pos['ndtran' #gc]'  ; 
							set erpo   'falses_neg['ndtran' #gc]' ;
						 else 
						     if ('toinv[#dd]' == (-1)) 
							 set erne   'falses_pos['ndtran' #gc]'  ; 
							 set erpo   'falses_neg['ndtran' #gc]' ;
						     else
							  set erpo 'falses_pos['ndtran' #gc]'  ; 
							  set erne 'falses_neg['ndtran' #gc]' ;
						     end
						  end  
			      else
				  set erpo 'falses_pos[ 'trad_nd['desroot_noout']' #gc]' ;  
			      end 
			       if (('erpo' != 7777777) && ( 'erne' != 7777777)) 
				     set posx 'erpo'/100 ; set posy 'erne'/100 ;  
				       quote 'posx','posy',  ; 
				end
				if (('erpo' == 7777777) && ( 'erne' != 7777777)) 
				    set posy 'erne'/100 ;
				     quote NA,'posy', ;  
				end
				if (('erpo' != 7777777) && ( 'erne' == 7777777)) 
				      set posx 'erpo'/100 ;
				       quote 'posx', NA ,  ;
				end
				if (('erpo' == 7777777) && ( 'erne' == 7777777)) 
				      quote NA, NA , ; 
				end
			   stop
		  end

		 sil-file; quote &10 ; sil=all; 
	 stop 
	 
	 
	 macfloat 7;
 	 sil-file ; quote &10 Species sampling for calculation of each subtree / group of characters &10 ; sil=all ; 
	 sil-file ; quote ,Complete_dataset, Complete_dataset,; sil=all; 
	 if ('doerror_w_grps'      ) 
	  loop=gc 0 ('numchrgrp'-1)
	   set bl_name $$xgroup #gc ; 
	   sil-file; quote $bl_name,$bl_name, ;sil=all; 
	  stop
	 end 
	 sil-file; quote&10 Subtree,ISE,OSE, ; sil=all; 
	 if ('doerror_w_grps'  ) 
	  loop=gc 0 ('numchrgrp'-1)
	   sil-file; quote false_pos,false_neg, ; sil=all; 
	  stop
	 end 
	 sil-file; quote &10 ; sil=all; 
	  loop=dd 0 ( nnodes [ 0 ] )
		  if ( (#dd == outgroup) || (#dd == root) || ( #dd == 'tgtsp' ) || (!isintree [0 #dd]) ) 
		      continue ; 
		  end
		  set ndtran 'trad_nd[#dd]' ; 
		  if (#dd == 'desroot_noout' )
		   	set ndtran 'trad_nd[sister [ 0 'desroot_noout']]'   ;
		  end
		  set erpo 'sp_pos['ndtran']'  ; 
		  set erne 'sp_neg['ndtran']' ; 
		  if ( #dd <= ntax ) 
			      set bl_name $$taxon #dd ;
			      if ( ('erpo' == 0) && ('erne' == 0) )
				 sil-file; quote $bl_name,NA,NA, ; sil=all; 
			      end
			      if ( ('erpo' != 0) && ('erne' == 0) )
				  sil-file; quote $bl_name,'erpo',NA, ; sil=all; 
			      end
			      if ( ('erpo' == 0) && ('erne' != 0) )
				  sil-file; quote $bl_name,NA,'erne', ; sil=all;
			      end
			      if ( ('erpo' != 0) && ('erne' != 0) )
				 sil-file; quote $bl_name,'erpo','erne', ; sil=all; 
			      end
		  else
			      if ( ('erpo' == 0) && ('erne' == 0) )
				   sil-file; quote Nd #dd,NA,NA, ; sil=all; 
				end
				if ( ('erpo' != 0) && ('erne' == 0) )
				  if ('toinv[#dd]' == (-1))
				     sil-file; quote Nd #dd,NA , 'erpo', ; sil=all; 
				  else
				     sil-file; quote Nd #dd,'erpo',NA, ; sil=all; 
				  end

				end
				if ( ('erpo' == 0) && ('erne' != 0) )
				  if ('toinv[#dd]' == (-1))
					 sil-file; quote Nd #dd,'erne',NA, ; sil=all; 
				  else
					  sil-file; quote Nd #dd,NA,'erne', ; sil=all; 
				  end 
				end
				if ( ('erpo' != 0) && ('erne' != 0) )
				  if ('toinv[#dd]' == (-1))
				     sil-file; quote Nd #dd,'erne','erpo', ; sil=all; 
				  else
				     sil-file; quote Nd #dd,'erpo','erne', ; sil=all; 
				  end

			      end
		  end
		  if ('doerror_w_grps'   )
			   loop=gc 0 ('numchrgrp'-1)
				   set erpo 'sp_pos_grp['ndtran' #gc]'  ; 
				   set erne 'sp_neg_grp['ndtran' #gc]' ; 
				   if ( ('erpo' == 0) && ('erne' == 0) )
					  sil-file; quote NA,NA, ; sil=all; 
				   end
				   if ( ('erpo' != 0) && ('erne' == 0) )
					if ('toinv[#dd]' == (-1))   
					  sil-file; quote NA, 'erpo',; sil=all; 
					else
					   sil-file; quote 'erpo',NA, ; sil=all; 
					end 
				   end
				   if ( ('erpo' == 0) && ('erne' != 0) )
					if ('toinv[#dd]' == (-1))   
					  sil-file; quote 'erne', NA,; sil=all; 
					else
					   sil-file; quote NA,'erne', ; sil=all; 
					end 
				   end
				   if ( ('erpo' != 0) && ('erne' != 0) )
				     if ('toinv[#dd]' == (-1))   
					sil-file; quote 'erne', 'erpo',; sil=all; 
				     else
					sil-file; quote 'erpo','erne', ; sil=all; 
				     end 
				   end
			   stop
		  end
		 sil-file; quote &10 ; sil=all; 
	   stop 
end
 
 lquote - ; 
 log/;
 k0 ;
 tv < 0 ; 
 tv - ; 
 tv > 0 ; 
 k0 ; 
 taxc + . ; 
 loop=yy 0 nchar 
  set listchar [#yy] 'bak_listchar [#yy]'; 
 stop 
 taxc + . ; 
 
proc/;




label TEST_SPECIES_CHARSAMPLING 
 
 k0 ; 
 set blue 0 ; set red 0 ;set green 0 ; 
 tv < 0 ; 
 sil=all; quote &10; sil=all; 
 if ('test_grp' != 9999 ) 
     loop=pt 0 nchar 
	   if (!(isinxgroup ['test_grp' #pt])) 
	      continue ; 
	   end
	   if ( ( (!'notarget') && 'doerror_w_tgt' ) || ((!'notarget') && 'docross_w_tgt' ) )    
	       if ( 'tgt_miss[#pt]' != 1) 
		      if ( 'sp_char_miss[#pt]' == 1 ) 
			set blue ++ ;
			set red ++ ;
		      else
			set red ++ ; 
		      end 
		end
	   else
		     if ( 'sp_char_miss[#pt]' == 1 ) 
			set red ++ ; 
			set blue ++ ;
		    else
		      set red ++ ; 
		     end
	   end 
    stop
 else 
  loop=hh 0 nchar
     if ( ((!'notarget') && 'doerror_w_tgt' ) || ((!'notarget') && 'docross_w_tgt' ) )
        if ( 'tgt_miss[#hh]' != 1) 
          if ( 'sp_char_miss[#hh]' == 1 ) 
             set red ++ ; 
               set blue ++ ;
             else
               set red ++ ; 
             end 
        end
    else
        if ( 'sp_char_miss[#hh]' == 1 ) 
           set red ++ ; 
           set blue ++ ;
        else
            set red ++ ; 
        end 
     end
  stop 
end
if ('red' == 0 ) 
   set noda 1 ; 
else 
       set green 'blue' / 'red' ; 
       if ('green'>= 'limmis' ) 
          set muymiss_sp ['guichsp' ] 1 ;
      else
         set muymiss_sp [ 'guichsp' ] 0 ; 
         set sps_inn++ ; 
         sil=all; quote cual = 'cual'  especie 'guichsp' adentro sps_inn 'sps_inn' &10; sil=all; 
       end
 end 
 
proc/; 




 



 
label SPR_LIK
report- ;
set mini 99999 ; 
set raiz root ;

loop=no 0 (ntax * 2 )
	 k 0 ;
	 tv < 0 ;
	 prunt 0/'prunne' ; 
	 if ( ( #no == root) || (#no == outgroup) || (!isintree [0 #no] ) )
	  continue ; 
	 end
	 edit 0 'raiz' 'prunne' #no ; 
	 set elesco 0 ; 
	 if ('doing_unlinked' && (!'doing_grp_anal')) 
	   loop=po 0 ('numchrgrp'-1)
	       cc ] . ; cc [ {#po} ; 
	       loop=er 0 nchar
		 if ( isinxgroup[#po #er] && 'listchar[#er]' == 0 ) 
		   cc ] #er ; 
		 end
	       stop 
	       piwe- ; 
	       set elesco 'elesco' + mklik [0] ;
	   stop 
	   cc [ . ; 
	   loop=jj 0 nchar 
	      if ( 'listchar[#jj]' == 0 )
		cc ] #jj ;
	      end
	   stop 
	 else
	     piwe-; 
	    set elesco mklik [0] ; 
	 end
	   if ('elesco' < 'mini' )
	       set mini 'elesco' ; 
	       tv < . ;
	       tv - ;
	       tv > 1 ; 
	       tv > 0 ; 
	       k0 ; 
	  else
	     if ('elesco' == 'mini' )
	       tv > 0 ; 
	     end 
	  end
stop 
k0 ; 
tv < . ; 
tc 1. ; 
tv < 0 ; 
tv - ;
set last ntrees ; 
tv > 'last' ; 
proc/; 


label SPR_LIK_CONSTRAIN
  
 

constrain- ; 
force ] ; 
force /&0 ; 
constrain =; 
mu 1 = wag ; 

sil=all; quote despues de wagner y antes de sprit ; sil=all; 


cc [ . ; 
loop=jj 0 nchar 
    if ( 'listchar[#jj]' == 0 )
      cc ] #jj ;
    end
stop 
if (!'doing_unlinked')
             piwe- ; 
	    set elesco mklik [0] ; 
else
        set elesco 0 ; 
	loop=po 0 ('numchrgrp'-1)
	  cc ] . ; cc [ {#po} ;/* vv*/ 
	  loop=er 0 nchar
	     if ( isinxgroup[#po #er] && 'listchar[#er]' == 0 ) 
	       cc ] #er ; 
	     end
	  stop 
	  piwe - ;  
	  set elesco 'elesco' + mklik [0] ;
	stop
	cc [ . ; 
	loop=jj 0 nchar 
	  if ( 'listchar[#jj]' == 0 )
	    cc ] #jj ;
	  end
	stop 
end
sil=all; quote el score de wagner es 'elesco' ; sil=all; 
set best 'elesco' ; 
sprit 0 
        set dde ++ ; 
        if (!mono[0]) 
            continue ;
        end
        if (!'doing_unlinked')
              piwe- ; 
              set elesco mklik [0] ; 
        else
             set elesco 0 ; 
                 loop=po 0 ('numchrgrp'-1)
                   cc ] . ; cc [ { #po } ;  
                    loop=er 0 nchar
                      if ( ( isinxgroup[ #po #er ] ) && ( 'listchar[#er]' == 0 ) ) 
                         cc ] #er ; 
                       end
                    stop 
                    piwe-; 
                    set elesco 'elesco' + mklik [0] ;
                 stop 
                 cc [ . ; 
                 loop=jj 0 nchar 
                    if ( 'listchar[#jj]' == 0 )
                       cc ] #jj ;
                    end
                stop 
           end
           if ( 'elesco' < 'best' )
              set best 'elesco' ; 
              resetswap ; 
           end
stop
set posx (ntrees + 1 ) ; 
sil=all; quote despues de sprit el score es 'best' y la cantidad de arboles es 'posx';  ;  sil=all; 

set esco 'best' ; 

proc/; 

label GENERATE_OUTPUT_STRICT
macfloat 2 ;
log $output_conditions ; 
cls ; clb  ;
lquote = ; 
lquote [ ; 
quote &10 ; 
sil-all ; 


quote - Datamatrix read from $input_file&10; 

if (!'stricting')
   quote - Reference tree read from $input_treefile &10 ; 
else
   quote - Multiple reference trees read from $input_treefile &10 ; 
end
if ('resolved')
 if ('stricting')
  quote  - WARNING ! At least one input tree with polytomes, randomly resolved before running the analysis &10  ;
else
  quote - WARNING ! Reference tree with polytomies, randomly resolved before running the analysis &10  ;
end

if ('domodif') 
   quote - Allowing target species to modify reference tree  &10 ; 
end

 quote - Trees rerooted on Outgroup species &10   ; 
 


sil-all; quote - Target species: $taxon 'tgtsp'&10; sil=all; 

   /* nopiwe 0 = IW , 1 = Multiple Optimality criterion   2= LIKELIHOOD    3 = PARSIMONIA  ; */ 

if ('nopiwe' == 2 )
 sil-all; quote - Analysis run Under Maximum Likelihood criterion &10 ;  sil=all; 
end
if ('nopiwe' == 3)
 sil-all ;quote - Analysis run Under Maximum Parsimony criterion &10 ;sil=all; 
end
if ('nopiwe' == 0 )
  sil-all ; quote - Analysis run under Implied Weighting criterion &10 ; sil=all; 
    if ('guichval' == 0 )
     sil-all ;    quote with a k value= 'kkval' &10 ; sil=all; 
    else
   sil-all ;    quote  &32 Weighting using range value = 'nval' (k value = 'kkval' ) &10; sil=all; 
    end
end

  if ('dolik' ) 
     if ('numchrgrp')
        if ('unlinked')
          sil-all; quote &32&32 Unlinked Mk model with character groups representing partitions &10;sil=all;
        else
          sil-all; quote &32&32 Linked Mk model &10;sil=all;
        end
     else
         sil-all; quote &32&32 Mk model &10;sil=all;
     end 
     if (!'mk_space') 
          sil-all ; quote &32&32 Equal state space for each character &10; sil=all ;
     else
         sil-all ; quote &32&32 Different state space for each character &10; sil=all ;
     end
 end

if ('domodif')
  if ('dolist' || 'char_anal' ) 
     sil-all; quote - WARNING! Character/Error analyses cannot be run when the option &10 &32&34Allow target species to modify relationships&34 is selected  &10 ; sil=all;   
  end
  if ('sensato' == 1  )
     sil-all; quote - WARNING! Sensitivity/Leave-one-out validation analysis cannot be run when the option &10&32 &34Allow target species to modify relationships&34 is selected &10   ; sil=all; 
  end
  if ( 'nopiwe' == 1 )
      sil-all; quote - WARNING! Multiple optimality criteria analysis cannot be run when the option&10&32 &34Allow target species to modify relationships&34  is selected  &10; sil=all;    
  end
end

  
sil-all; quote - Best trees saved in $output_mpts  file  &10 ; sil=all; 

sil-all; quote - An svg file was generated ($output_svg) showing the optimal position of the target species &10 ; sil=all; 

set tiempo time ; 
macfloat 3 ; 
sil-all ; quote - Running time: 'tiempo's &10; sil=all ; 
macfloat 10 ; 
tt- ; 
log/; 
proc/; 


 
label GENERATE_OUTPUT

 
macfloat 2 ;
log $output_conditions ; 
cls ; clb  ;
lquote = ; 
lquote [ ; 
quote &10 ; 
sil-all ; 
quote - Datamatrix read from $input_file&10; 
quote - Reference tree read from $input_treefile&10; 
if ('resolved')
 quote - WARNING ! Input tree with polytomes, randomly resolved before running the analysis &10 ; 
end 
 
 
if ( ( 'notarget' )  ) 
   quote - No target species selected &10 ; 
else
     quote - Target species: $taxon 'tgtsp' &10 ; 
end
lquote = ; 
lquote [ ; 

if ('multisp' || (('notarget' == 1) && ('ause' == 1 )) )
          sil-all; quote - Query species placed in backbone topology:&10&32&32 ; sil=all; 
	  loop 0 ntax 
	    if ('listax[#1]' == 1 ) 
	       sil-all; quote $taxon #1 ; sil=all; 
	    end
	  stop
	  sil-all; quote &10 ; sil=all;  
else 
  sil-all;  quote - No additional species in query list&10;sil=all; 
end
lquote - ; 


if ('nopiwe' == 2 )
sil-all;  quote - Analysis run Under Maximum Likelihood criterion ; sil=all; 
end
if ('nopiwe' == 3 )
 sil-all; quote - Analysis run Under Maximum Parsimony criterion ;sil=all; 
end
if ('nopiwe' == 0 )
 sil-all; quote - Analysis run under Implied Weighting criterion ; sil=all; 
end



 
if ('nopiwe' == 1 ) 
  sil-all; quote - Analyses run Under multiple optimality criterion: &10 ;sil=all;
  lquote =; lquote [ ; 
  if ('mk_frm_mult')
   sil-all; quote &32&32 Maximum Likelihood &10; sil=all; 
   if ('numchrgrp')
    if ('unlinked')
    sil-all; quote &32&32&32&32 Unlinked Mk model with character groups representing partitions &10;sil=all;
    else
    sil-all; quote &32&32&32&32  Linked Mk model &10;sil=all;
    end
   else
    sil-all; quote &32&32&32 (Mk model) &10;sil=all;
   end 
   if (!'mk_space') 
   sil-all ; quote &32&32&32&32 Considering the same state space for every character &10; sil=all ;
   else
   sil-all ; quote &32&32&32&32 Each character with its own state space &10 ; sil=all ;
   end
  end 
  if ('pars_frm_mult')
  sil-all; quote &32&32 Maximum Parsimony &10;sil=all;
  end
  if ('piw_frm_mult')
  sil-all; quote &32&32 Implied Weighting (Concavity value = 'kkval')&10 ;sil=all;
  end
  lquote- ; 
end





if ((!'sensato') && ('nopiwe' != 1) ) 
  if ('nopiwe' == 0 )
    if ('guichval' == 0 )
      quote - with a k value= 'kkval'; 
    else
       lquote =; lquote [ ; 
      quote  &32 Weighting using range value = 'nval' (k value = 'kkval' ) &10; 
      lquote -; 
    end
  end
  if ('dolik' ) 
     if ('numchrgrp')
        if ('unlinked')
          sil-all; quote &32&32 Unlinked Mk model with character groups representing partitions &10;sil=all;
        else
          sil-all; quote &32&32 Linked Mk model &10;sil=all;
        end
     else
         sil-all; quote &32&32 Mk model &10;sil=all;
     end 
     if (!'mk_space') 
          sil-all ; quote &32&32 Equal state space for each character; sil=all ;
     else
         sil-all ; quote &32&32 Different state space for each character; sil=all ;
     end
     if ('doing_EPA')
       sil-all; quote &32&32 Relative probabilities displayed (EPA approach) ; sil=all; 
     end
 end
end 
if ('sensato')  
	 if ( ('dosensit' == 0) || ('dosensit' == 2) ) 
	     sil-all; quote - Sensitivity Analysis performed ; sil=all; 
	       if ('dolik') 
		   if ('reduced_mk_sens') 
		      sil-all; quote --Condition 0 = different state space for each character ; sil=all;
		      sil-all; quote --Condition 1 = equal state space for each character ; sil=all;
		   else
		          sil-all; quote --Condition 0 = different state space for each character, linked model ; sil=all;
			  sil-all; quote --Condition 1 = different state space for each character, unlinked model ; sil=all;
		          sil-all; quote --Condition 2 = equal state space for each character, linked model ; sil=all;
			  sil-all; quote --Condition 3 = equal state space for each character, unlinked model ; sil=all;
		   end
	       else
		          if ('guichsensit' == 2 ) 
				set dde 'nconds' ; 
				sil-all; quote - Sensitivity analysis run under 'dde' different settings defined in file $setting_file ; sil=all; 
			 else
				sil-all; quote - Sensitivity analysis run under different K values for implied weighting : ; sil=all; 
				lquote = ; 
				sil-all;  quote &32 ; sil=all; 
				loop 0 ('nconds' - 1)
			  	  sil-all;  quote 'condic[#1]', ; sil=all ;  
				stop 
				sil-all; quote &10 ; sil=all; 
				lquote - ; 
			 end 
	      end
	 end
end 


if (('dosensit' == 1) || ('dosensit' == 2) && ('sensato' == 1)  )
              if ('docross_w_tgt') 
	         if (!'notarget')
	            sil-all; quote - Leave-one-out validation analysis run considering character sampling of target species  ; sil=all; 
	         else
	            sil-all; quote - Leave-one-out validation analysis run considering the complete character sampling ; sil=all;
	         end 
	      else
	         sil-all; quote - Leave-one-out validation analysis run considering the complete character sampling ; sil=all;
              end
             
              
              
              if ( 'guichsensit' == 0 )
		 lquote = ; lquote [ ; 
		 sil-all; quote - Leave-one-out validation run under different K values in implied weighting : &10 ;sil=all; 
		 macfloat 2 ; 
		  sil-all; quote&32&32Setting&32|%32k value |&32Avg. nodal Distance &10;sil=all; 
		 loop 0 ('nconds'- 1) 
			sil-all; quote&32&32&32&32&32 #1 &32&32&32|&32&32 'condic[#1]' &32&32&32&32&32&32|&32 'distri[#1]' &10;sil=all; 
		 stop 
		 macfloat 7 ; 
		 lquote- ; 
		 if ('multiopt')
			lquote = ; lquote [ ; 
			sil-all; quote - Leave-one-out validation determined multiple optimal settings:&10 &32&32; sil=all ; 
			loop 0 ('nconds'-1)
			 if ('distri[#1]' =='distri['bespos']' )
			     sil-all; quote #1 &32 ;sil=all ; 
			 end
			stop
			sil-all; quote &10 ;sil=all ; 
			lquote - ; 
			sil-all; quote - Analysis run under Implied weighting (k value= 'bescond') ; sil=all ; 
		 else
			sil-all; quote - Leave-one-out validation chose a k value of 'bescond' for Implied weighting. Analysis run under that setting ; sil=all;
		 end
	     else
			lquote = ; lquote [; 
			sil-all ; quote - Leave-one-out validation analysis on settings read from file $setting_file &10 ; sil=all;
			macfloat 2 ; 
			sil-all; quote&32 Avg. nodal Distance &10;sil=all; 
			loop 0 ('nconds'-1 ) 
			 sil-all; quote &32Setting #1 = 'distri[#1]' nodes &10;sil=all; 
			stop
			if ('multiopt')
			   sil- all; quote &32Leave-one-out validation determined multiple optimal settings &10 ; sil= all; 
			   sil- all; quote &32 Analysis run under setting 'bespos' &10 ; sil=all; 
			 else
			   sil-all; quote - Setting selected by Leave-one-out validation: 'bespos' &10 ; sil=all; 
		         end
			 lquote - ; 
	     end
	  end 
	 end 
end  

if ('domodif') 
  sil-all;  quote - Allowing target species to  modify reference tree&10; sil=all; 
end

lquote - ; 


if (('nopiwe' != 1 ) && ('sensato' == 0 )) 
    if (!'notarget')
        if ('multisp')
           sil-all;  quote - Best tree(s) save in $output_mpts file, including optimal placement of the target and the query species ; sil=all; 
           sil-all; quote - A svg file was generated ( $output_svg ) displaying the scores of placing the target species on each branch of the backbone tree ; sil=all; 
        else
           sil-all; quote - Best tree(s) save in $output_mpts file, including optimal placement of the target species ; sil=all; 
	   sil-all; quote - A svg file was generated ( $output_svg ) displaying the scores of placing the target species on each branch of the backbone tree ; sil=all;
	   if ('did_colorquer'  ) 
	   sil-all; quote - A svg file was generated  ( &color_query.svg ) showing the placement of all query species on the backbone tree ; sil=all;                
        end
    else
       sil=all;  quote - Best tree(s) save in $output_mpts file, including optimal placement the query species ; sil=all; 
       if ('multree' == 0  ) 
          sil=all;  quote - A svg file was generated ( $output_svg ) highlighting the optimal position of the query species ; sil=all; 
       end
    end
end



 

 /* nopiwe 0 = IW , 1 = Multiple Optimality criterion 2= LIKELIHOOD 3 = PARSIMONIA ; */ 
 /*sensato= 1 es cross o sensit */ 
 /* dosensit 0 = sensitivity ; 1= CV ; 2 CV y Sensit ; 3 compare optim criter */ 
 /* pars_frm_mult piw_frm_mult mk_frm_mult */
 /* guichsensit 0 = k values ; 1= maximum Likelihood 2 = archivo settings */

if ( ( 'sensato' == 0 ) || ( ('sensato' == 1) && ( ('dosensit' == 1 ) || ('dosensit' == 2 ) ) ) )
 if ('dolist')
 lquote = ; lquote [; 
 sil-all ; quote- Colored chart with character scores for each position of target species saved in $output_svgchars ; sil=all; 
 sil-all ; quote &10 ; sil=all; 
 if ('dogrpchars')
  sil-all; quote - Colored chart with character group scores for each position of target species saved in $group_file ; sil=all; 
  sil-all ; quote &10 ; sil=all;
 end
 if (!'besever')
   sil-all; quote &32&32 Colors representing the largest score range for a char./grp. of chars. &10; sil=all;
 else 
   sil-all ; quote &32&32 Colors representing the score range for each char./grp. of chars. &10; sil=all; 
 end
 lquote - ; 
 end
end

if ('char_anal') 
	 if ('doerror_w_tgt') 
	    if (!'notarget')
	       sil-all; quote - Error in placement (EP) calculated with character sampling of target species  ; sil=all; 
	    else
	       sil-all; quote -  Error in placement (EP) calculated with the complete character sampling ; sil=all;
	    end 
	 else
	    sil-all; quote - Error in placement (EP) calculated with the complete character sampling ; sil=all;
	 end
	 if ('doerror_w_grps'  ) 
	    if ('numchrgrp' > 0)
	      sil-all; quote - Error in placement (EP) calculated also for each character group ; sil=all;
	    else
	      sil-all; quote - Error in placement (EP) not calculated for character groups (undefined) ; sil=all;
	    end
	 end
	 if ('guicherr'== 0) sil-all; quote &32&32 EP values corresponding to the minimum nodal distance per spp. ; sil=all ;  end
	 if ('guicherr'== 1) sil-all; quote &32&32 EP values corresponding to the mean nodal distance per spp. ; sil=all ; end
	 if ('guicherr'== 2) sil-all; quote &32&32 EP values corresponding to the maximum nodal distance per spp. ; sil=all ; end
         if ('calc_prob') 
          sil-all; quote &32&32 EP significance calculated ; sil=all;
         end
end



if ('nopiwe' == 1 ) 
     sil-all; quote - A svg file was generated ( $output_sensit) displaying the scores of placing the target species on each branch of the backbone tree for each optimality criteria selected ; sil=all; 
end





if ('clade_anal') 
  if ('doerror_w_tgt') 
     if (!'notarget')
        sil-all; quote - Subtree errors (ISE/OSE) calculated with character sampling of target species  ; sil=all; 
      else
        sil-all; quote - Subtree errors (ISE/OSE) calculated with the complete character sampling ; sil=all;
     end 
  else
     sil-all; quote - Subtree errors (ISE/OSE) calculated with the complete character sampling ; sil=all;
  end
  if ('doerror_w_grps'  ) 
    if ('numchrgrp' > 0)
      sil-all; quote - Subtree errors (ISE/OSE) calculated also for each char. group ; sil=all;
    else
      sil-all; quote - Subtree errors (ISE/OSE) not calculated for char. groups (undefined) ; sil=all;
    end
  end
  if ('doamb' )
    sil-all; quote &32&32 Ambiguity considered as error  ; sil=all;
  end 
end





set tiempo time ; 
macfloat 3 ; 
sil-all ;quote - Running time: 'tiempo's ; sil=all ; 
macfloat 10 ; 

if ('offML_char_anal')
  sil-all; quote - WARNING! Error analysis was not run. It is not available for Maximum Likelihood. Analysis not run; sil=all; 
end
if ( 'doandsense' )
 sil-all; quote - WARNING! Character analysis was not run. It cannot be performed in the context of Sensitivity/Leave-one-out validation analyses; sil=all ;
end
if ('doandmult')
   sil-all; quote - WARNING! Character analysis was not run. It cannot be performed in the context of Multiple Optimality Criteria analysis; sil=all;  
end  
if ('doandmusp')
  sil-all; quote - WARNING! Character/group scores was not run. It cannot be calculated with multiple query species ; sil=all; 
end
if ('errndsense')
  sil-all; quote - WARNING! Error analysis was not run. It cannot be performed in the context of Sensitivity analysis;  sil=all; 
end
if ('errandmult')
  sil-all; quote - WARNING! Error analysis was not run. It cannot be performed in the context of Multiple Optimality Criteria analysis; sil=all; 
end
sil=all; 
tt- ; 
tv- ; 
log/; 
proc/; 

label MY_MISSING

 loop=ch 0 nchar
   set sp_char_miss [ #ch] 0 ; 
   if (iscont[#ch] ) 
            set blue contmin [#ch 'guichsp' 0] ; 
            set red contmax [#ch 'guichsp' 0] ; 
            if ( ( contmin [#ch 'guichsp' 0] == 0.000) && ( contmax [#ch 'guichsp' 0] == missing ) ) 
             if ('guichsp' == 'tgtsp') 
              set listchar [#ch] 0 ;
              set tgt_miss [#ch] 1 ; 
             end
             set sp_char_miss[#ch] 1 ; 
            end
   else
     if (islmark[#ch])
             set ptos 0 ; 
             loop=ll 0 lmnpoints[#ch]
              if (lmxcoord [#ch #ll 0 'guichsp'] == -10000001 ) 
                set ptos ++ ; 
              end
             stop 
             if ('ptos' == (lmnpoints [#ch] + 1)) 
              if ('guichsp' == 'tgtsp')
                set listchar[#ch] 0 ;
                set tgt_miss [#ch] 1 ; 
              end
              set sp_char_miss[#ch] 1 ; 
             end 
     else 
             if ( states [ #ch 'guichsp' 0 ] == missing ) 
              if ('guichsp' == 'tgtsp')
               set tgt_miss [#ch] 1 ; 
               set listchar[#ch] 0 ;
              end
             set sp_char_miss[#ch] 1 ; 
             end
            end
     end
stop 
if ('guichsp' == 'tgtsp' ) 
 cc [ . ; 
 loop=jj 0 nchar 
  if ( 'listchar[#jj]' == 0 )
      set blue #jj ; 
      cc ] 'blue' ;
  end
 stop
end 
proc/; 




label COLORTREE_ERROR
 
taxc + . ; 
report- ;
sil=all; 
k0 ; 
tvault < 0 ;

reroot  * = 'pavote' ; 

set nds nnodes [ 0 ] ; 
ttag * 0 ;
loop=nd 0 nnodes[0] 
  ttag <#nd ; 
   if ( (#1 == root) || (#1 == 'tgtsp') ||   (!isintree [0 #nd]) ) 
     continue ; 
   end 
   if ( ( #1 < root) && ( 'listax [#nd]' == 1 ) ) 
     continue ; 
   end
   ttag +#nd #nd  ;
stop 

ttag & ;
set larama 140 ; 
/*ttag & $output_svg xysave eti bheight 70 legup 15 thickness 4 tfontsize 35 txtsep 20 bfontsize 28 blength 80 colors ; */
/*ttag & $output_svg xysave eti bheight 70 legup 15 thickness 4 tfontsize 35 txtsep 20 bfontsize 28 blength 80 colors ; */
ttag & $output_svg  xysave eti bheight 110 legup 15 txtsep 20 bfontsize 20  tfontsize 35 blength 'larama' colors ; 
set dist -99999 ; 


loop 0 nnodes [ 0] 
 if ('eti [#1 1]' > 'dist')
   set dist 'eti [#1 1]' ; 
 end
stop 
set dist 'dist' + 80 ; 
set posx 'dist' - 40 ; 
lquote [ ; 

set posx 'dist' -15 ; 
 
  set span 'maxi' - 'mini' ; 
  set shift 'mini' ; 
  set shoft 'maxi' ; 
  set mit ('span'/2) ; 
  set uncua ( 'span' / 4 ) ;
  set trescua ( (3 * 'span') / 4 ) ;
  macfloat 2 ; 



set span_err 100 ; 
set miti_err ('span_err'/2) ; 
set uncuar_err ( 'span_err' / 4 ) ;
set trescuar_err ( (3 * 'span_err') / 4 );


loop=nd 0 nnodes[0] 
	 if ( (#1 == root) || (#1 == 'tgtsp') ||   (!isintree [0 #nd]) ) 
	    continue ; 
	 end 
	 if ( ( #1 < root) && ( 'listax [#nd]' == 1 ) ) 
	    continue ; 
	 end
	
	 set tancia ('eti [#1 0]' - 'eti [anc[0 #1] 0]' ) / 4 ; 
	 set posx 'eti [anc[0 #1] 0]' + ('tancia' * 3 );


	if ('clade_anal')
		  set posy 'eti[#1 1]' + 10 ; 
		  set tancia ('eti [#1 0]' - 'eti [anc[0 #1] 0]' ) ;
		  set miti 'eti [anc[0 #1] 0]' + ('tancia'/2) ; 
		  set dde 'tancia' /8 ; 
		  set px 'tancia' - ('dde' * 2) ; 
		  set limA 'eti [anc[0 #1] 0]' + 'dde' ;
		  set uncu 'px' / 8 ; 
		  set pos_y 'posy' + 30 ; 
		  set ref 'miti' + 'uncu' ; 

		  macfloat 7 ;
		  ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(255,255,255)&59 stroke:black&59&32 stroke-width:2&34 /> &10 ;
		  set blue 'posy' + 16 ; 
		  set red 'limA'    ; 
		  set elmasi 'red' - 2 ; 
		  set green 'blue' + 9 ; 
		  set dde 'green'  + 12 ; 
		  ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;
		  ttag&+ write <text&32x=&34 'elmasi' &34 &32 y=&34 'dde' &34 &32stroke-width=&34 1&34&32 font-size=&34 12&34 > 0 </text>&10 ;

		   set red 'limA' + ('px' / 4 )  ;
		   set limB 'red' - 2 ; 
		   set elmasi 'red' - 8 ; 
		   ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;


		  set red 'limA' + ('px' / 2 )  ;
		  set elmasi 'red' - 8 ; 
		  ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;
		  ttag&+ write <text&32x=&34 'elmasi' &34 &32 y=&34 'dde' &34 &32stroke-width=&34 1&34&32 font-size=&34 12&34 > 10 </text>&10 ;

		  set red 'limA' +  ('px'  * (3 / 4 ))  ;
		  set elmasi 'red' - 10 ; 
		  ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;

		  set red 'limA' +  'px'    ;
		  set elmasi 'red' - 14 ; 
		  ttag&+ write<line x1=&34 'red'&34&32y1=&34 'blue'&34&32x2=&34 'red'&34&32y2=&34 'green'&34&32style=&34fill:black&59 stroke-width:2&34 /> &10 ;
		  ttag&+ write <text&32x=&34 'elmasi' &34 &32 y=&34 'dde' &34 &32stroke-width=&34 1&34&32 font-size=&34 12&34 > &62 20 </text>&10 ;
                   
                  if (#nd == 'tochang' )
                    continue ;
                  end
		  set nod 'trad_nd[#nd]' ;
		  if ( ( #nd < root) || ('toinv[#nd]' != (-1)) ) 
			 set error 'false_pos['nod']' ; 
		  else 
			  if ('toinv[#nd]' == (-1))
				set error 'false_neg['nod']' ; 
			   end
		  end
 		  if ('error' != 7777777 ) 
		     if ('error' > 20 ) 
			  ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(130,130,130)&59 stroke:black&59&32 stroke-width:2&34 /> &10 ;
		     else
		       set px 'px' * ( 'error' / 20 ) ;  
		       ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(130,130,130)&59 stroke:black&59&32 stroke-width:2&34 /> &10 ;
		     end 
		  else
		     ttag &+ write <rect x=&34 'limA'&34&32y=&34 'posy'&34&32width=&34 'px'&34&32height=&34 20&34&32style=&34fill:rgb(130,130,130)&59 stroke:black&59&32 stroke-width:2&34  /> &10 ;
		  end   
		  set posy 'posy' - 2 ; 
      end
stop 





set posx 'dist' +70 ; 
ttag&+ write <text&32x=&34 20 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Bars below branches represent In Subtree Error (ISE) </text>&10 ;
end 

ttag & ;



proc/; 

label PRINT_ERROR_BARS 
silent = file ; 
lquote = ;
lquote [ ; 
tabl /2 ; 
macfloat 2 ; 
log $output_errbars ; sil-all; 
set tot_hig 1600 ; 
set tot_width 3000 ; 
sil-file ; quote <svg width=&34  'tot_width'&34  height= &34 'tot_hig' &34  xmlns=&34 http://www.w3.org/2000/svg&34> &10 ; sil=all; 

 
 set mass 0  ;
 set posx 0 ; 
 
 if ('guicherr' == 0 ) 
   set mass 'blues[0]' ; 
   if ('doerror_w_grps'    )
     loop=uu 0 ('numchrgrp'-1)
       set green (#uu + 1) ; 
       if ( 'blues['green']' != 7777777)
         set posx++ ; 
         if ('blues['green']' > 'mass' ) 
           set mass 'blues['green']' ; 
         end
       end  
     stop 
  end
end  

if ('guicherr' == 1 ) 
   set mass 'greens[0]' ; 
   if ('doerror_w_grps'    )
     loop=uu 0 ('numchrgrp'-1)
       set green (#uu + 1) ; 
       if ( 'greens['green']' != 7777777)
         set posx++ ; 
         if ('greens['green']' > 'mass' ) 
           set mass 'greens['green']' ; 
         end
       end  
     stop 
 end
end 
if ('guicherr' == 2 ) 
    set mass 'reds[0]' ; 
    if ('doerror_w_grps'    )
      loop=uu 0 ('numchrgrp'-1)
        set green (#uu + 1) ; 
        if ( 'reds['green']' != 7777777)
          set posx++ ; 
          if ('reds['green']' > 'mass' ) 
            set mass 'reds['green']' ; 
          end
        end  
      stop 
 end
end


set ejeX_startX 100 ;   set ejeX_y 250 ; 

set separ 50 ;  
set anch 40 ; 
set shift ('separ' ) * ('numchrgrp' + 1 ) + 100 ; 
set green ('separ' * ('posx' + 1)) + 20 + 'ejeX_startX'  ;  
set ejeX_finX 'green'; 
set x_span 'ejeX_finX' -  'ejeX_startX' ; 

set ejeY_startY 50 ;   

set ejeY_x 'ejeX_startX' ; 

set ejeY_finY 'ejeX_y' ; 

set y_span 'ejeY_finY' -  'ejeY_startY' ; 


/*LINEA VERTICAL */
sil-file ;quote <line x1=&34 'ejeX_startX'&34&32 y1=&34 'ejeY_startY'&34&32 x2=&34 'ejeY_x'&34&32 y2=&34 'ejeY_finY'&34&32 stroke=&34 black&34&32 stroke-width=&34 3&34&32/> &10 ; sil=file ;

set green 'ejeY_startY' + 180 ;  
set ctos 'ejeY_x' - 40 ; 
sil-file ;quote <text x=&34 'ctos'&34 &32y=&34 'green'&34&32 font-size=&34 18&34&32 transform=&34 rotate (-90,'ctos','green')&34 >  Error in Placement (EP)  </text> &10 ; sil=file ;


/* BARRAS ERROR */ 
set separ 50 ;  
set anch 40 ; 
set posx_graf 'ejeX_startX' + 2  ; 
if ('guicherr'  == 0 ) 
   set altu 'y_span' * ( 'blues[0]'/ 'mass')  ;
end
if ('guicherr'  == 1 ) 
set altu 'y_span' * ( 'greens[0]'/ 'mass')  ;
end
if ('guicherr'  == 2 ) 
 set altu 'y_span' * ( 'reds[0]'/ 'mass')  ;
end
 
set posy_graf 'ejeY_startY' +('y_span' - 'altu' )  ;

sil-file;  quote <rect x=&34 'posx_graf'&34 &32y=&34 'posy_graf'&34&32width=&34 'anch'&34&32 height=&34 'altu'&34&32style=&34fill:black&34 />   &10 ;sil=all; 

set posx_nam 'posx_graf' + ('anch'/2) ; set posy_nam ('ejeY_finY' + 10)  ; 

sil-file; quote <text x=&34 'posx_nam'&34 &32y=&34 'posy_nam'&34&32 text-anchor=&34 end&34&32  font-size=&34 14&34&32 transform=&34 rotate (-60,'posx_nam','posy_nam')&34 > Complete Dataset &32 </text> &10 ; sil=all; 


loop=aa 0 ('numchrgrp')
        set vta #aa + 1 ;
	if ('guicherr'  == 0 ) 
	   set esco 'blues['vta']' ; 
	end
	if ('guicherr'  == 1 ) 
	   set esco 'greens['vta']' ; 
	end
	if ('guicherr'  == 2 ) 
	   set esco 'reds['vta']' ; 
	end
	if ( 'esco' == 7777777) 
	 continue ;  
	end  
	set bl_name $$xgroup #aa ;
	set error_global 'esco'    ; 
	set altu 'y_span' * ( 'esco'/ 'mass')  ; 
	set posy_graf 'ejeY_startY' +('y_span' - 'altu' )  ;
	set posx_graf 'posx_graf' + 'separ' ; 
	sil-file;  quote <rect x=&34 'posx_graf'&34 &32y=&34 'posy_graf'&34&32width=&34 'anch'&34&32 height=&34 'altu'&34&32style=&34fill:black&34 />   &10 ;sil=all; 
	set posx_nam 'posx_graf' + ('anch'/2) ; set posy_nam ('ejeY_finY' + 10)  ;
	sil-file; quote <text x=&34 'posx_nam'&34 &32y=&34 'posy_nam'&34&32 text-anchor=&34 end&34&32  font-size=&34 14&34&32 transform=&34 rotate (-60,'posx_nam','posy_nam')&34 > $xgroup #aa &32 </text> &10 ; sil=all; 
stop 


/* numero maximo */ 
set green 'ejeY_x' -30 ; 
sil-file ;quote <text x=&34 'green'&34&32y=&34 'ejeY_startY'&34&32  font-size=&34 14&34 > &32 'mass' </text> &10 ;sil=file ;
sil-file ;quote <line x1=&34 'ejeX_startX'&34&32 y1=&34 'ejeY_startY'&34&32 x2=&34 'ejeX_finX' &34&32 y2=&34 'ejeY_startY'&34&32 stroke=&34 black&34&32 stroke-dasharray=&34 4&34&32 stroke-width=&34 1&34&32/> &10 ; sil=file ;



set interrr ('mass' / 2) ;   
/* numero intermedio */ 
set inter_y 'ejeY_startY' + (('ejeX_y' - 'ejeY_startY'  ) / 2) ; 
sil-file ;quote <text x=&34 'green'&34&32y=&34 'inter_y'&34&32  font-size=&34 14&34 > &32 'interrr' </text> &10 ;sil=file ;
sil-file ;quote <line x1=&34 'ejeX_startX'&34&32 y1=&34 'inter_y'&34&32 x2=&34 'ejeX_finX' &34&32 y2=&34 'inter_y'&34&32 stroke=&34 black&34&32 stroke-dasharray=&34 4&34&32 stroke-width=&34 1&34&32/> &10 ; sil=file ;

set interrr 'mass'- ('mass' / 4) ;   
/* numero intermedio */ 
set inter_y 'ejeY_startY' + (('ejeX_y' - 'ejeY_startY'  ) / 4) ; 
sil-file ;quote <text x=&34 'green'&34&32y=&34 'inter_y'&34&32  font-size=&34 14&34 > &32 'interrr' </text> &10 ;sil=file ;
sil-file ;quote <line x1=&34 'ejeX_startX'&34&32 y1=&34 'inter_y'&34&32 x2=&34 'ejeX_finX' &34&32 y2=&34 'inter_y'&34&32 stroke=&34 black&34&32 stroke-dasharray=&34 4&34&32 stroke-width=&34 1&34&32/> &10 ; sil=file ;

set interrr ('mass' - ('mass' * 0.75)) ;   
/* numero intermedio */ 
set inter_y 'ejeY_startY' + (('ejeX_y' - 'ejeY_startY'  ) * 0.75) ; 
sil-file ;quote <text x=&34 'green'&34&32y=&34 'inter_y'&34&32  font-size=&34 14&34 > &32 'interrr' </text> &10 ;sil=file ;
sil-file ;quote <line x1=&34 'ejeX_startX'&34&32 y1=&34 'inter_y'&34&32 x2=&34 'ejeX_finX' &34&32 y2=&34 'inter_y'&34&32 stroke=&34 black&34&32 stroke-dasharray=&34 4&34&32 stroke-width=&34 1&34&32/> &10 ; sil=file ;

/*numero minimo cero  */ 
sil-file ;quote <text x=&34 'green'&34&32y=&34 'ejeX_y'&34&32  font-size=&34 14&34 > &32 0 </text> &10 ;  sil=file ;

/* lineA HORIZONTAL */
sil-file ;quote <line x1=&34 'ejeX_startX'&34&32 y1=&34 'ejeX_y'&34&32 x2=&34 'ejeX_finX' &34&32 y2=&34 'ejeX_y'&34&32 stroke=&34 black&34&32 stroke-width=&34 3&34&32/> &10 ; sil=file ;
 
sil-file; quote </svg>   &10 ;  sil=all; 
log/ ; 
proc/; 



label ERROR_PROBABILITIES
 
loop 0 ((nnodes[0] * ntax) - 1 )
   set distrib[#1] 0 ; 
stop 
k0 ; 
tvault <0 ;
set dde nnodes [0] ;
set iteres 500; 
k0  ; 
lquote = ;
lquote [ ; 
sil=all; 

loop=cnd 0 ('iteres'-1)
  set dist   0 ; 
  k0 ;
  set cuantas 0 ; 
  loop=tx 0 ntax 
     k0 ;
     nak - ; 
     tvault < 0 ;
     if ( (#tx == outgroup) || ( #tx == 'tgtsp' ) || (!isintree [0 #tx]) || ('muymiss_sp[#tx ]' == 1 ) ) 
        continue ; 
     else
      set cuantas ++ ; 
     end  
     set ris ntrees + 1  ; 
     prunt 0/#tx  ;
     set eltax #tx ; 
     set losod outgroup ; 
     outgroup ; 
     set rut root ; 
     set nds ( nnodes [0 ] - 1 )  ; 
     set van 0 ; 
     loop 1 10000
       set nod getrandom [0 'nds'] ; 
       if ( (#tx != 'nod') && ( 'nod' != 'rut' )  && (isintree [0 'nod']) )  
         endloop 
       else
        set van ++ ; 
       end
       if ('van' > 800 )
         proc/; 
       end  
     stop  
     edit 0 'rut' #tx 'nod' ;  
     tvault < 0 ; 
     reroot ;  
     if (eqtrees [ 0 1 ]) 
       set pos_y 0 ; 
     else
        set onetocero grptogrp   1 0  /#tx  ;
        set pos_one anc [1 #tx] ;
        set pos_cero anc [0 #tx] ; 
        set nodo_trans 'onetocero['pos_cero']' ; 
        set pos_y distnode [ 1 'pos_one' 'nodo_trans' ] ;
        set onetocero grptogrp   0 1  / #tx  ;
        set pos_one anc [1 #tx] ;
        set pos_cero anc [0 #tx] ; 
        set nodo_trans 'onetocero['pos_one']' ; 
        set pos_x distnode [ 0 'pos_cero' 'nodo_trans' ] ;
        if ('pos_x' < 'pos_y') 
          set pos_y 'pos_x' ; 
        end
     end
     set dist 'dist' +  'pos_y'  ; 
     set dde ++ ; 
  stop 
/*  sil-all ;quote iter #cnd  cuantas 'cuantas' &10 ; sil=all; */
  k 0 ; 
  set distrib['dist'] ++ ; 
 /* sil-file; quote aumente la distr de 'dist' en 1 e nla iter #cnd &10;  sil=all;*/
 /*sil-file; quote 'dist' &10;sil=all;  */

stop



set total 0 ; 
if ('sps_inn' !=  ('cuantas' + 1) ) 
 errms spsinn =  'sps_inn' cuantas 'cuantas' tgtsp 'tgtsp'; 
end


if ( 'guicherr' == 0  ) 
  set observ 'blue' * ('sps_inn'  );  
end
if (  'guicherr' == 1 ) 
  set observ 'green' * ('sps_inn') ;  
end
if ( 'guicherr' == 2  ) 
  set observ 'red' * ('sps_inn') ;  
end

if ('calc_prob')
        set total 0 ; 
       /* sil-all; quote observ min  'observ' ; */
        loop=ff 0 ('observ')
	  set total 'distrib[#ff]'+ 'total' ;    
	stop
	if (!'doing_grp_anal')
	  set prob [0 'guicherr' ] ('total' / 'iteres') ; 
	  sil-file; quote Probability= 'prob [0 'guicherr' ]'  &10 ; 
	else
	  set prob [('cual'+1) 'guicherr' ] ('total' / 'iteres') ; 
	  sil-file; quote Probability= 'prob [ ('cual'+1) 'guicherr' ]'   &10 ; 
	end
end 
 

proc/; 














/* ESTO HACE UN WAGNER POR ML LO VOY A REEMPLAZAR POR UN WAGNER MP CONSTRAINED */ 
/*
loop=aa 0 ntax
        force ] ; 
        constrain - ; 
        sil=all ; quote antes de definir las constrains randtaxa = 'rand_taxa[#aa]' ; ; 
       	force; 
       	sil=all;
        force /&0 ; 
        ts * forceado.tre ; s ; ts/; 
        sil=all ; quote despues de definir las constrains ; 
	   	force; 
        constrain = ; 
         if ( (! 'listax[ 'rand_taxa[#aa]' ]' ) || (('rand_taxa[#aa]' == 'tgtsp') && ('coloring'))  || ( 'rand_taxa[#aa]' == outgroup )  ) 
            continue ;
         else
           taxc + 'rand_taxa[#aa]' ;
         end 
         cc ] . ;
         k0 ;
         
         mu 1 = h 1 ;
         set best 999999999 ; 
         cc [ . ; 
         loop=jj 0 nchar 
            if ( 'listchar[#jj]' == 0 )
             cc ] #jj ;
            end
         stop 
         loop=tt 0 ntrees 
                  if (!'doing_unlinked')
                      piwe- ; 
                      set elesco mklik [#tt] ; 
                  else
                      set elesco 0 ; 
                      loop=po 0 ('numchrgrp'-1)
                          cc ] . ; cc [ { #po } ;
                          loop=er 0 nchar
                             if ( (isinxgroup[ #po #er ]) && ('listchar[ #er ]' == 0) ) 
                                cc ] #er ; 
                             end
                          stop 
                          piwe-; 
                          set elesco 'elesco' + mklik [#tt] ;
                       stop
                       cc [ . ; 
                        loop=jj 0 nchar 
                           if ( 'listchar[#jj]' == 0 )
                             cc ] #jj ;
                          end
                       stop 
                  end
                  if ('elesco' < 'best' ) 
                     set best 'elesco' ; 
                     set bespos #tt ; 
                  end 
        stop
        tc 'bespos' ; 
        reroot ; 
stop  
 
set dde 0 ; 
taxc + . ; 
report-; 

tvault <0 ; 
force ] ;
force /&1 ; 
constrain ;
tc 0 ; 
*/


label  ML_SEARCH_ERROR
  lset speed 0.05 ldelta 0.01 bdelta 0.01 passes 40 40 ;
 lquote - ; 
 k0 ;
 tv< 0 ; 
 copytree 0 ; 
 prunt 1/ 'prunne' ; 
 set tiempo time ; 
 sil=all; quote antes de cortar eltax 'prunne' tiempo 'tiempo' ; sil=all; 
 goto UPDATE_PRUNNED ; 
 set tiempo time ; 
 sil=all; quote despues  de cortar eltax 'prunne' tiempo 'tiempo'; sil=all; 
 goto CALCULATE_ML_RED ; 
proc/; 
 
  
 
 label  UPDATE_PRUNNED
         set full_tree 0 ; 
 	 set red_tree 1 ; 
 	 set onetocero grptogrp  'red_tree' 'full_tree'  /'prunne' ;   
 	 report=; 
 	 lset display brlen ; 
 	 piwe-; 
 	 maketable + mk_brlen ; 
 	 set pos_x mklik ['full_tree'] ; 
 	 maketable - ;
 	 report-; 
 	 lset display lik ; 
 	 set cerotoone grptogrp 'full_tree' 'red_tree'  /'prunne' ;  
 	 loop=yy 0 (nnodes['red_tree'])
 	    set red_mk_brlen[ #yy ]  'mk_brlen [ 'cerotoone[#yy]']' ; 
 	 stop
 	 sil=all ; quote eltax 'prunne' ; sil=all; 
 	 set ter sister ['full_tree' 'prunne'] ; 
 	 set pos_one 'onetocero[ 'ter']'  ;  
 	 set pos_two  anc[ 'red_tree' 'pos_one'] ;
 	 set pos_cero  sister ['red_tree' 'pos_one' ] ; 
         /* if ('pos_one' > root)
 	     set listita deslist[ 'red_tree' 'pos_one'] ; 
              set pos_tre 'listita[0]' ;  
              set pos_cua 'listita[1]' ;
              sil=all; quote pos_tre 'pos_tre' pos_cua 'pos_cua'  ;
              set red_mk_brlen ['pos_tre'] (-1) ;
 	    set red_mk_brlen ['pos_cua'] (-1) ;
          end*/
          set red_mk_brlen ['pos_one'] (-1) ;
 	 set red_mk_brlen ['pos_cero'] (-1) ;
 	 set red_mk_brlen ['pos_two'] (-1) ;
 	 report=; 
 	 lset display brlen ; 
 	 piwe-; 
 	 maketable + tmp_brlen ; 
 	 set pos_x fixlik [ 'red_tree' red_mk_brlen ] ; 
 	 maketable - ; 
 	 report- ; 
  	 sil=all;  quote arbol Pruneado 'prunne' fixed : 'pos_x'  ;  sil=all; 
         quote time 'tiempo' ; sil=all; 
 proc/; 
  
  
 
 label CALCULATE_ML_RED 
    set mini 9999999 ;
    constrain - ; 
    force ] ; 
    tv > 0  ; /* el 0 es el referencia completo el 1 es en podado que hay qeu borrar despues */ 
    force /&1 ;
    constrain =; 
    k 0 ; 
    cc ] . ; 
    mu 1 = h 1 ; 
    bb; 
    if ('doing_grp_anal')
        cc [ {#up} ;
        loop=er 0 nchar
          if ( isinxgroup[ #up #er ] ) 
             if ('listchar[#er]' == 0 ) 
               cc ] #er ; 
             end
          end
        stop 
    else
       cc [ . ; 
       loop=er 0 nchar
         if ('listchar[#er]' == 0 ) 
             cc ] #er ; 
         end
       stop
    end 
      tv > . ; /* mando todos al vault ahora el 0 es el completo ref el 1 el red y el esto son los completos a probar */ 
    k 0 ; 
    tv < . ;
    set vamos 0 ; 
    loop=eee 2 ntrees
       	    set ref_tree 1 ; 
	    set opt_tree #eee ;  
	    set onetocero grptogrp 'ref_tree' 'opt_tree' /'prunne' ;
	    loop=dd 0 (nnodes['opt_tree'])
	       set opt_mk_brlen[#dd]  'tmp_brlen [ 'onetocero[#dd]']' ; 
	    stop
	    set pos_one anc ['opt_tree' 'prunne'] ;
	    set pos_cero sister['opt_tree' 'prunne'] ; 
	    set opt_mk_brlen ['pos_one'] (-1) ;
	    set opt_mk_brlen ['pos_cero'] (-1) ;
	    set opt_mk_brlen ['prunne'] (-1) ;
	    set pos_two anc ['opt_tree' 'pos_one']; 
	    if ( 'pos_two' != root  )
	       set opt_mk_brlen ['pos_two'] (-1) ;
	    end
	    report=; 
	    lset display brlen ; 
	    report - ;
	    piwe-; 
	    /*set elesco fixlik [ 'opt_tree' opt_mk_brlen ] ;*/
	    set elesco mklik [ 'opt_tree' ] ; 
	    sil=all; quote elesco de #eee = 'elesco'; sil=all; 
	    if ( 'elesco' < 'mini' )
	       set mini 'elesco' ;
	       set guichimini [0] #eee ;
	       set vamos 0 ;
	    else
	       if ( 'elesco' == 'mini' )
	        set guichimini ['vamos'] #eee ;
	         set vamos ++ ;
	       end
 	    end  
    stop 
    k 0 ; /* borro todo */ 
    tv <. ; /* traigo todo de vault */ 
    tv - ;  /* borr el vault */
    tv > 0 ; /* mando al vault el completo ref */ 
    set vamos 'vamos' - 1 ; 
    macfloat 0 ; 
    tc 'guichimini [ 0 - 'vamos' &32 ]' ; /* me quedo con el mejor ahora el cero es el ref completo y el 1 es el mejor */ 
    macfloat 7 ; 
    sil=all; 
     tv < 0 ; /* traigo el ref completo del vault y me queda ultimo el ref */ 
 proc/ ; 
 
 
 label CHECK_STATUS   
  set doandsense 0 ; 
  set doandmult 0 ;
  set doandmusp 0 ; 
  if ( 'dolist' )
	   if ('sensato'  )
	      set doandsense 1  ;
	      set dolist 0 ; 
	   end
	   if ('nopiwe' ==  1 ) 
	       set doandmult 1 ; 
	       set dolist 0 ; 
	   end
	   if ('multisp'  ) 
	      set doandmusp 1 ;
	      set dolist 0 ; 
	   end 
  end
 
  
  
  if ('domodif' ) 
    if ( 'nopiwe' == 2) 
      errmsg * The option /Allow target species to modify relationships / is not available for Maximum Likelihood ; 
    end
    if ( 'nopiwe' == 1) 
          errmsg * The option /Allow target species to modify relationships/ is not available for Multiple Optimality Criteria analysis ; 
    end
    if ( 'sensato' == 1) 
         errmsg * The option /Allow target species to modify relationships/ is not available for Sensitivity/>Leave-one-out validation analyses ; 
    end
    if ('char_anal' || 'clade_anal')
      errmsg * The option /Allow target species to modify relationships/ is not available for Error Analyses ; 
    end
    if ('dolist')
          errmsg * The option /Allow target species to modify relationships/ is not available for Character Analysis ; 
    end
    
    
  end
  
  
   /* nopiwe 0 = IW , 1 = Multiple Optimality criterion   2= LIKELIHOOD    3 = PARSIMONIA  ; */ 
   /*sensato= 1 es cross o sensit */ 
   /* dosensit 0 = sensitivity ; 1= CV ; 2 CV y Sensit ; 3 compare optim criter */ 
   /* pars_frm_mult  piw_frm_mult mk_frm_mult */
   /* guichsensit 0 = k values ; 1= maximum Likelihood 2 = archivo settings */
  

  
  
  
  if ( 'nopiwe' == 2) 
    set offML_char_anal 0 ; 
    if ('char_anal' || 'clade_anal')
      set char_anal 0 ; 
      set offML_char_anal 1 ;  
    end
    if ('sensato' &&  (  ('dosensit' == 1) || ('dosensit' == 2 ) ) )
         cls;  sil-all;  ra1 ; tplot [ ; k 0 ;cls;
         errmsg * Leave-one-out validation analysis is not available for Maximum Likelihood ; 
    end
    if ('multisp') 
            sil-all;  ra1 ; tplot [ ; k 0 ;cls;
            errmsg * Multiple query species analysis is not available for Maximum Likelihood ; 
    end
  end  
   
   if (('sensato') && ('nopiwe' == 1) ) 
      sil-all; ra 1 ; tplot [ ; k0 ; cls;  
      errmsg * Sensitivity/Leave-one-out validation analysis cannot be run with multiple optimality criteria ; 
       report=; 
   end
   if (('guichsensit' == 1) && ('nopiwe' != 2) && ('sensato') ) 
     sil-all; ra1 ; tplot [ ;k0 ; cls;
     errmsg * Sensitivity analysis on ML paramters can only be performed under Maximum Likelihood criterion ; 
   end
   if (('guichsensit' == 0) && ('nopiwe' != 0) && ('sensato') ) 
      sil-all; ra1 ; tplot [ ; k 0 ;cls; 
      errmsg * Sensitivity/Leave-one-out validation analyses on k values can only be performed under Implied Weighting criterion ; 
   end
  if ('guichval' == 3 ) 
   if ('kmax' <= 'kmin')
      ra1 ; tplot [ ; k0 ; cls; 
      sil-all; errmsg Minimum k value is higher than maximum k value ; 
      proc/; 
   end
  end
  







proc/; 
 
 


label FILL_COLIM  
  
 loop=ll 0 20
   set colim [#ll] 'mini' + ('pace' * #ll ) ;  
 stop 
  
proc/; 





label SETTING_COLORS  

set sszz 'maxclr' - 1 ; 

	loop=cl 0 'sszz' 
	         set shof #1 ; /* set shof #cl ;  */ 
	         set std 'shof' + 1  ;
		 if ('shof' != ('maxclr'-1))
		    if ( ( 'micore' >= 'colim['shof']' ) && ( 'micore' < 'colim[ 'std' ]' ) )
		      set red 'viridis[ 0 'shof']' ; 
		      set green 'viridis[ 1 'shof']' ;
		      set blue 'viridis[ 2 'shof']' ;
		    end
		else
		    if ( ( 'micore' >= 'colim['shof']' ) && ( 'micore' <= 'colim[ 'std' ]' ) )
		       set red    'viridis[ 0 'shof']' ; 
		       set green  'viridis[ 1 'shof']' ;
		       set blue   'viridis[ 2 'shof']' ;
		   end
		end 
	stop
	
proc/;  


label SETTING_PALETTE  
set viridis [ 0 0 ] 240 ; set viridis [ 1 0 ] 249  ; set viridis [ 2 0 ] 33 ;
set viridis [ 0 1 ] 247 ; set viridis [ 1 1 ] 226 ; set viridis [ 2 1 ] 37 ;
set viridis [ 0 2 ]  252 ; set viridis [ 1 2 ]  205 ; set viridis [ 2 2 ] 37 ;
set viridis [ 0 3 ] 254 ; set viridis [ 1 3 ] 183 ; set viridis [ 2 3 ] 45 ;
set viridis [ 0 4 ] 252 ; set viridis [ 1 4 ]  163 ; set viridis [ 2 4 ] 56 ;
set viridis [ 0 5 ] 247 ; set viridis [ 1 5 ] 144 ; set viridis [ 2 5 ] 68 ;
set viridis [ 0 6 ]  240 ; set viridis [ 1 6 ] 127 ; set viridis [ 2 6 ] 79  ;
set viridis [ 0 7 ] 231  ; set viridis [ 1 7 ] 110 ; set viridis [ 2 7 ] 91 ;
set viridis [ 0 8 ] 221 ; set viridis [ 1 8 ] 94 ; set viridis [ 2 8 ] 102 ;
set viridis [ 0 9 ] 209 ; set viridis [ 1 9 ]  78; set viridis [ 2 9 ]  114;
set viridis [ 0 10 ] 197 ; set viridis [ 1 10 ] 64 ; set viridis [ 2 10 ] 126 ;
set viridis [ 0 11 ] 182 ; set viridis [ 1 11 ] 48 ; set viridis [ 2 11 ]  139 ;
set viridis [ 0 12 ] 167  ; set viridis [ 1 12 ] 33 ; set viridis [ 2 12 ] 151 ;
set viridis [ 0 13 ] 149 ; set viridis [ 1 13 ]  17; set viridis [ 2 13 ]   161;
set viridis [ 0 14 ]  131; set viridis [ 1 14 ]  5 ; set viridis [ 2 14 ]   167 ;
set viridis [ 0 15 ] 110 ; set viridis [ 1 15 ] 0 ; set viridis [ 2 15 ] 168 ;
set viridis [ 0 16 ] 89 ; set viridis [ 1 16 ]  1; set viridis [ 2 16 ]  165 ;
set viridis [ 0 17 ]  67 ; set viridis [ 1 17 ] 3 ; set viridis [ 2 17 ] 158 ;
set viridis [ 0 18 ] 44 ; set viridis [ 1 18 ] 5 ; set viridis [ 2 18 ] 148 ;
set viridis [ 0 19 ] 13 ; set viridis [ 1 19 ] 8 ; set viridis [ 2 19 ]  135;
proc/;



label MAGIC_FOR_OUT   
	 constr - ; 
	 force ] ; 
	 k0 ; 
	 tv < 0 ; 
	 out 'outrut' ; 
	 rer ; 
	 if ('muymiss_sp['prevout']' == 1 )
		   set nodo $$taxon #tx ; 
		   sil-file; quote $nodo('prevout')= Not analyzed (Missing data > 'limmis' ) &10; sil=all; 
		   proc/; 
	end 
	prunt 0/'prevout' ;
	force /&0 ;
	constrain = ;  
	k 0 ; 
	mu 3 = h 1 ;
	bb ;
	if ( ntrees >= 999 )
	   tch 0.998 ; 
	end 
	tvault < 0 ; /* traigo el cero de vaoutl y lo reenraizo */ 
	rer ; 
	si=all ; quote prevout 'prevout'  outrut 'outrut ; 
	
	set ref_tree ntrees ;
	set eltax 'prevout' ; 
	set nodo $$taxon 'prevout' ; 
	goto NODE_DISTANCE ; 
	set nodo $$taxon 'prevout' ; 
	sil-all; quote $nodo('prevout')= 'min_dist'/'mean_dist'/'max_dist' &10 ; sil=all; 
	set blue 'blue' + 'min_dist' ;
	set red 'red' + 'max_dist' ;
	set green 'green' + 'mean_dist' ;
	loop=nn 0 ( nnodes['ref_tree'] ) 
	    set yacambN_out [#nn] 0 ; set yacambP_out [#nn] 0 ; 
	stop
	loop=la 0 (ntrees-1) 
	          set opt_tree #la ;
		  if (eqtrees ['opt_tree' 'ref_tree'] ) 
	            continue ; 
		  end 
	          if ('yacambN_out['prevout']' == 0 ) 
		      set negg_out ['prevout'] ++ ; 
		      set yacambN_out['prevout'] 1 ; 
		  end
		  set mano sister [ 'opt_tree' 'prevout' ] ; 
		  if ('mano' < root ) 
		     if ('yacambP_out['mano']' == 0 ) 
			 set poss_out ['mano'] ++ ;
			 set yacambP_out['mano'] 1 ; 
			 if (outgroup > 10000 ) baaa end 
		     end
		  else
		   set onetocero grptogrp 'ref_tree' 'opt_tree' ;
		   set man_trad 'onetocero ['mano']' ; 
		   if ('man_trad' > 0 )
		    if ('yacambP_out['man_trad']' == 0 ) 
			   set poss_out ['man_trad'] ++ ;
			   set yacambP_out['man_trad'] 1 ; 
			   sil-all; quote 'man_trad' 'poss_out ['man_trad']' ; sil=all;   
			  if (outgroup > 10000  ) caaa end   
		    end
		   end
		  end
		  loop=nd 0 (nnodes ['ref_tree']) 
			 set onetocero grptogrp 'opt_tree' 'ref_tree' ;
			 if (#nd == outgroup || (!isintree['ref_tree' #nd] ) ) 
			        if (outgroup > 10000  ) daaa end     
				continue ; 
			 end
			 if ('onetocero [#nd]' < 0 )  
			         ag - 0 ;
				 ag = 0 @'ref_tree' #nd ; 
				 set tadentro 0 ; 
				 if ( isinagroup [0 'prevout'] ) 
				   set tadentro 1 ; 
				 end 
				 if ('tadentro') 
				    if ('yacambN_out[#nd]' == 0 ) 
				        set negg_out [ #nd ] ++ ; 
				        set yacambN_out[#nd] 1 ;
				     end 
				 else
			            if ('yacambP_out[#nd]' == 0 ) 
				      set poss_out [ #nd ] ++ ;
				      set yacambP_out[#nd] 1 ;
				      if (outgroup > 1000 ) gaaa end 
			            end
				end
			 end
		  stop
	 stop  
     set dde ntrees + 1; 
     outgroup 'prevout' ;
     lquote - ; 
     tt- ; 
     lquote- ; 
     loop=nd 0 (nnodes ['ref_tree']) 
        set ndtran 'trad_nd_out[#nd]' ;
        sil=all ;quote nodo #nd ntran 'ndtran' posout 'poss_out [#nd]' toinv 'toinv_out[#nd]' ;  
        if ('poss_out [#nd]' == 1 ) 
            if ('toinv_out[#nd]' == (-1) ) 
                  set negg ['ndtran']  'negg ['ndtran']'   + 1 ; 
                  sil=all ; quote le aumente neg a  'ndtran' por directo nodo #nd outrut 'outrut';  
            else
                  set poss ['ndtran'] 'poss ['ndtran']'   + 1   ; 
                  sil=all ; quote le aumente pos a  'ndtran' por directo nodo #nd  outrut 'outrut'; 
            end  
       end
        if ('negg_out [#nd]' == 1 )  
              if ('toinv_out[#nd]'  == (-1)) 
                  sil=all ;quote le aumente pos a  'ndtran' por inverso nodo #nd 'outrut'; 
		  set poss ['ndtran']  'poss ['ndtran']'   + 1 ;  
               else
                 set negg ['ndtran'] 'negg ['ndtran']'   + 1 ; 
                 end  
       end
    stop 
 
out 'prevout' ; 
proc/; 
 

label RUN_STRICT

 
cls; 
var: tricto elno ter ela  ele  outi caca arbol opt_nod [2000] rut 
; 

 
 
tt- ; 
set redsiz 15 ; 

nelsen * /'tgtsp' ; 

loop 0 99 ; 
     set  opt_nod [#1]   0 ; 
stop     
travtree +  ;
report- ; 

loop=tre 0 (ntrees-1) 
     set arbol #tre ;
    /* sil-all; quote ARBOL #tre ; sil=all; */
     set ter sister[ #tre 'tgtsp'] ; /* ancestro del target en el arbol lupeado */ 
     set tricto ntrees ; 
     set nod eqgroup [ #tre  'ter' 'tricto'] ; /* nodo correspondiente en el strict  */ 
     if ('nod' < 1 ) 
        /*  sil-all;quote no esta el nodo 'ter' del arbol #tre en el estricto ; sil=all;*/
          travtree below 'arbol' 'ter' elno
		   set nod anc [ #tre 'elno'] ;
		   copytree 'arbol' ; 
		   set ele ntrees ;  
		   prunt 'ele'/'tgtsp' ; 
		   set cual simgroup ['arbol'  'nod'  'ele'] ; 
		   set noda eqgroup [ 'ele' 'cual' 'tricto'] ; 
		   /*sil-all; quote cual 'cual' nodo 'nodo noda 'noda' ;   sil=all; */
		   if ('noda' > root) 
		     set cestros deslist [ 'tricto'  'noda'] ; 
		     set caca listsize ; 
		     /* sil-all;quote caca 'caca' ; */
		     if ('caca' > 2 ) 
			set opt_nod ['noda'] 2 ;
			/* sil-all;quote cambien el valor de optnode aquis para nodo 'noda'  a 2 ; sil=all; */ 
			 set ela 'ele' - 1; 
		         tc 0.'ela' ; killtrav ; 
		    else
		      set opt_nod ['nod'] 1 ;
			/* sil-all; quote cambien el valor de optnode aquis para nodo 'nod'  1 ; sil=all;*/ 
			set ela 'ele' - 1; 
		         tc 0.'ela' ; killtrav ; 
		    end 
		 else
		   /* sil-all;quote no esta el nodo  'nod'  en el strict ;sil=all;*/
		 end
		 set ela 'ele' - 1; 
		 sil=all ; tc 0.'ela' ; 
         endtrav
     else
	set opt_nod ['nod'] 1 ;
	/* sil-all;quote cambien el valor de optnode aquis para nodo 'nod' ; sil=all;*/ 
     end
stop 

loop 0 nnodes [ntrees] 
  if ('opt_nod [#1]' != 0  )
   /* sil-all; quote nodo #1 optimo 'opt_nod [#1]'; sil=All; */
 end
stop 
 
tc / ; 

ttag * 0 ; 
 
 
set nconds  6;  
if ('nconds'<= 3) 
  set sizsq 30 ;
  set alturama 70 ; 
else
  set sizsq 24 ;
end
set larama 110 ;
if ( ('nconds' > 3) && ('nconds' < 9) ) 
   set alturama 100 ; 
end   
if ('nconds' >= 9 ) 
  set alturama 130 ; 
end 
if ( 'nconds' > 12 ) 
  set ccc ( 'nconds' / 3 ) ; 
  if ('ccc' * 3 < 'nconds' ) 
      set ccc ++ ; 
      macfloat 0 ;
      set ccc 'ccc' ; 
      macfloat 4 ; 
  end 
  set larama 'larama' + ( ('ccc' - 4 ) * 'sizsq') + 10 ; 
 
  macfloat 0 ; 
  set larama 'larama' ; 
  macfloat 4 ; 
end

 
ttag & salimos.svg  xysave eti bheight 'alturama'  legup 15 txtsep 20 bfontsize 20  tfontsize 35 blength 'larama' thickness 4  ; /* bheight 120 */

set outi outgroup ; 


loop=cd 0 ('nconds'-1)

 
         if ('nconds' < 7) 
                 set limB 5 ;
                 set limA 2 ; 
                 set sizsq 30 ;
         else
             set sizsq 24 ;
             if ( 'nconds' < 13)
               set limB 7 ;
               set limA 3 ;         
            else
               set ccc ( 'nconds' / 3 ) ; 
                 if ('ccc' * 3 < 'nconds' ) 
                     set ccc ++ ; 
                     macfloat 0 ;
                     set ccc 'ccc' ; 
                     macfloat 4 ; 
               end 
               set limA 'ccc' - 1 ; 
               set limB ('ccc' *2 ) - 1 ; 
             end 
        end 
        if (#cd > 'limB' ) 
             set suma_y 'sizsq' * 2 ;
             set suma_x 'sizsq' * (#cd - ('limB' + 1 )) ;
        else 
           if (#cd > 'limA' )
                     set suma_y 'sizsq' ;
                     set suma_x 'sizsq' * (#cd - ('limA' + 1 )) ; 
           else
                   set suma_x 'sizsq' * #cd ; 
                    set suma_y 0 ; 
           end
        end 
	loop=no 0 nnodes [ 0] 
		/* sil-all; quote nodo #no  ;*/ 
		set rut anc [0 'outi' ] ; 
		if ( ( #no == 'rut')  ||( #no == 'tgtsp'))
		  continue 
		end 
		/* sil-all; quote nodo #no ;*/
		  /* set pos_x ('eti[#no 0]' - 'eti[anc[0 #no] 0]')/ 12 + 'eti[anc[0 #no] 0]' - 5  ; 
		   set pos_y 'eti[#no 1]' + 8  ; */
		   set pos_x ('eti[#no 0]' - 'eti[anc[0 #no] 0]')/ 12 + 'eti[anc[0 #no] 0]' + 'suma_x' ; 
		   set pos_y 'eti[#no 1]' + 4 + 'suma_y'; 
           
		  if ( 'opt_nod [#no]' == 1) 
		     ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:red&59 stroke:white&34 /> &10 ;sil=all; 
		  else
		    if ( 'opt_nod [#no]' == 2) 
		        set pos_x 'eti[#no 0]' + ('eti[ #no 0]'/ 12 ) ; 
		        ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:white&59 stroke:black&34 /> &10 ;sil=all; 
		     else
		        ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 'sizsq'&34&32height=&34 'sizsq'&34&32style=&34fill:white&59 stroke:black&34 /> &10 ;sil=all; 
		     end 
		  end
	stop 
	
stop 	
	
	
	 
	set dist 0 ; 
	
	loop 0 (nnodes [0]) 
	 if ('eti [#1 1]' > 'dist')
	    set dist 'eti [#1 1]' ; 
	 end
	stop 
	 
	set posx 'dist' + 230 ; 
	
	ttag &+ write <text&32x=&34 120&34 &32 y=&34 'posx'&34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Character groups </text>&10 ; 
	set posx 'posx' - 20 ;
	
	loop=cd 0 ('nconds'-1)
	 if ('nconds' < 7) 
	  set limB 5 ;
	  set limA 2 ; 
	 else
	  if ( 'nconds' < 13)
	   set limB 7 ;
	   set limA 3 ;          
	  else
	   set ccc ( 'nconds' / 3 ) ; 
	         if ('ccc' * 3 < 'nconds' ) 
	           set ccc ++ ; 
	           macfloat 0 ;
	           set ccc 'ccc' ; 
	           macfloat 4 ; 
	    end 
	    set limA 'ccc' - 1 ; 
	    set limB ('ccc' *2 ) - 1 ; 
	  end 
	 end 
	 if (#cd > 'limB' ) 
	                 set suma_y 23 * 2 ;
	                 set suma_x 23 * (#cd - ('limB' + 1 )) ;
	 else 
	         if (#cd > 'limA' )
	                set suma_y 23 ;
	                set suma_x 23 * (#cd - ('limA' + 1 )) ; 
	         else
	                set suma_x 23 * #cd ; 
	          set suma_y 0 ; 
	         end
	 end 
	 set pos_x 'suma_x' + 20 ;
	 set pos_y 'suma_y' + 'posx' ;
	 ttag &+ write <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 22&34&32height=&34 22&34&32style=&34fill:white&59 stroke:black&34 &32stroke-width=&34 0.1&34 /> &10 ;sil=all ; 
	 set dde #cd ;
	 set pos_x 'pos_x' + 5 ; set pos_y 'pos_y' + 14 ; 
	 ttag &+ write <text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y'&34 &32stroke-width=&34 1&34&32 font-size=&34 14&34  > 'dde' </text>&10 ; 
	stop
	set pos_y 'pos_y' + 30 ; 

	
ttag & ; 

proc/; 





 
label PLACE_TARGET_WITH_MODIF
set mini 9999999999 ; 
set maxi 0 ; 
k 0 ; 
tt- ; 


tvault<0 ;
rer ; 

set nds nnodes [0] ;
if ('dolik')
   lset speed 0.1 ldelta 0.08 bdelta 0.08 passes 10 10   ;    
   if ('mk_space' )
       lset nogstatespace ; 
   end
end
set van 0 ; 

 
loop=nd 0 (nnodes[0]) 
         k 0 ; 
         tvault<0 ; 
         rer ; 

         if ((#nd == root) ||  (#nd == 'tgtsp') || (!isintree [0 #nd]) || (#nd == outgroup) )
             continue ; 
         end
         
         /*
         if (#nd == outgroup ) 
	 		     loop=xx 0 ntax 
	 		       if ( (#xx != outgroup) && (isintree [0 #xx]) )   
	 		          set outcross outgroup ;  
	 		          outgroup #xx ; 
	 		          rer ; 
	 		          endloop ; 
	 		        end
	 		    stop 
	 end
	 */
         set blue root ; 
         quote: 'blue' 'tgtsp' #nd ;  
         sil=all; 
         edit 0 'blue' 'tgtsp' #nd ; 
         set blue score[0] ; 
         set ter sister[0 'tgtsp'] ; 
         set ces anc[0 'tgtsp'] ;  
         force + [ @0 'ces'  ]  [ @0 'ter'  ] ;   
         k 0 ; 
         constrain=;
       
         mu 300 = h 5  ;/*mu 30 */ 
         bb = fillonly ; 
         if (ntrees >= 999 )
             tch 0.998 ; 
         end
         set esco score[0] ; 
         if ('blue' < 'esco' ) 
            set esco 'blue' ; 
         end 
         quote: nodo #nd esco 'esco' blue 'blue'  ; 
         set core[#nd] 'esco' ;
         if ('esco' <= 'mini')
                  if ('esco' == 'mini')
                      save ; 
                      set van 'van' + (ntrees + 1) ; 
                  else 
                      set van (ntrees + 1) ; 
                      ts/; ts *$output_mpts ; save; 
                  end 
                  set mini 'esco' ; 
                  set besnod #nd ;
         end 
         if ('esco' > 'maxi' ) 
            set maxi 'esco' ; 
         end 
         if ( 'dogrpchars'  &&  'dolist' )
                sil=all ;quote entro a los calculos 	NODO #nd ; sil=All; 
                  
                loop=po 0 ( 'numchrgrp'-1 )
			  set mini 99999 ;  set maxi 0 ;
			  /*sil=all ;quote grupo #po ; sil=All; */
			  cc ] . ; cc [ { #po } ;
			  loop=er 0 nchar
			      if ( (isinxgroup[ #po #er ]) && ('listchar[ #er ]' == 0) ) 
				  cc ] #er ; 
			      end
			  stop
			  loop=ee 0 ntrees
			      set esco score[#ee] ; 
			      if ('esco' < 'mini' ) 
				 set mini 'esco' ; 
			      end
			      if ('esco' > 'maxi') 
				set maxi 'esco' ;
			      end 
			  stop 
		          set grpscore[#nd #po] 'mini' ; 
		          set maxgrpscore[#nd #po] 'maxi' ;
		          sil=all; quote el score de grupo #po nodo #nd es 'grpscore[#nd #po]' el maxi es 'grpscore[#nd #po]' ; sil=all;  
	         stop
	         cc ] . ; 
	         loop=ps 0 nchar 
		    if ('listchar[#ps]' == 1 ) 
		 	cc [ #ps ; 
		   end 
	     	 stop 
	 end
stop

quote: mini 'mini' besnod 'besnod' ; 

 
proc/
; 





 
label PLACE_TARGET_WITH_MODIF_MULTREES


set mini 9999999999 ; 
set maxi 0 ; 
sil=all; 
report - ; 
tt- ; 
tv < . ; 
rer; 
nelsen * /'tgtsp' ; 
tc / ; 

if ( nnodes[0] == 0 ) 
  ra1 ; tplot [ ; k0 ; cls; 
  sil-all;
  errmsg The strict consensus after having pruned the target species is completely unresolved. The analysis cannot be completed ; 
end 

 

set nds nnodes [0] ;
if ('dolik')
   lset speed 0.1 ldelta 0.08 bdelta 0.08 passes 10 10   ;    
   if ('mk_space' )
       lset nogstatespace ; 
   end
end
set van 0 ; 

set maxi 0 ; 
set mini 9999999 ; 
macreport-; 

tt-; 

 
log saliendo.txt ; 

loop=nd 0 (nnodes[0])
         set tofork 0 ;  
         k 0 ; 
         tv < . ; 
         rer ; 
	 nelsen * /'tgtsp' ; 
         tc / ;  
    
         set nod #nd ; 
         if ((#nd == root) ||  (#nd == 'tgtsp') || (!isintree [0 #nd]) || ( #nd == outgroup  ) )
	              continue ; 
         end
         if ( nodfork [ 0 'nod' ] > 2 )   
           set tofork 1 ; 
         end
        
         set blue root ; 
         quote: 'blue' 'tgtsp' 'nod' ; 
         
         edit 0 'blue' 'tgtsp' 'nod' ; 
         set blue score[0] ; 
         set ces anc[0 'tgtsp'] ;  
         set dientes deslist [0 'ces'] ; 
         if ('dientes[0]' == 'tgtsp')
          set ter 'dientes[1]' ;
         else
           set ter 'dientes[0]' ;
         end
         force + [ @0 'ces'  ]  [ @0 'ter'  ] ;   
         k 0 ; 
         constrain=;
         mu 300 = h 5  ; 
         quote: vta afuera #nd ; 
         set esco score[0] ; 
         if ('blue' < 'esco' ) 
            set esco 'blue' ; 
         end
         set score_poly[#nd 0 ]   'esco' ;
         if ('esco' < 'mini')
            set mini 'esco' ; 
         end
         if ('esco' > 'maxi')
            set maxi 'esco' ; 
         end
     
         if ( 'tofork' )   
              quote: entro en tofork ; 
              nak- ; /*borrar*/ 
              k 0 ; 
	      tv < . ; 
	      rer ; 
	      nelsen * /'tgtsp' ; 
	      tc / ;  
              set nod #nd ; 
              set blue root ;
              sil-all; nak- ; tp ; 
                quote: 'blue' 'tgtsp' 'nod' ; 
              edit 0 'blue' 'tgtsp' 'nod' ; 
              set red anc [0 'tgtsp'] ;  
              set lis deslist[ 0 'red']; 
              conden/0 .-'nod' 'lis[0-(listsize-1)]'; 
              force=&0;
              constrain=;
              mu 300 = h 5  ; 
         
	      set  esco  score[0]  ;
	      if ('esco' < 'mini')
                  set mini 'esco' ; 
              end
              if ('esco' > 'maxi')
                set maxi 'esco' ; 
              end
             set  score_poly[#nd 1 ] 'esco' ; 
         else
             set score_poly[#nd 1]  99999 ;	 
	 end 
	    
 stop
 
 
/* coloreo las ramas con los colores como siempre  para las ramas poly le puedo superponer una rama xq tengo las coor y de los desc. tengo que lupearlas y ver los valores minimos y maximos de y  */

k0 ; 
tv < . ; 
rer ; 
tt- ; 
nelsen * /'tgtsp' ; 
tchoose/ ; 

set nds nnodes [ 0 ] ; 


report- ; 




goto PRINT_MULTREES ; 


proc/; 



label DEFINE_POLY_HEIGH 

set lis deslist [0 'nod' ] ;
set dde 99999999999 ;  
set pos_y 0 ; 
loop=aa 0 (listsize-1)
 if (       'eti[ 'lis[#aa]' 1 ]' < 'dde' )
    set dde 'eti[ 'lis[#aa]' 1]' ; 
 end
 if ('eti[ 'lis[#aa]' 1 ]' > 'pos_y' )
    set pos_y 'eti['lis[#aa]' 1]' ; 
 end
stop  
proc/; 







label CHAR_SCORES_MODIF

report- ;

if ('dolik')
  /*lset speed 0.2 ldelta 0.01  bdelta 0.01 passes 30 30  ;  */
  lset speed 0.1 ldelta 0.08 bdelta 0.08 passes 10 10   ;   
 /* lset speed 0.1 ldelta 0.1  bdelta 0.1 passes 3 3  ;  */
 if ('mk_space' )
  lset nogstatespace ; 
 end
 if ('unlinked' ) 
   set doing_unlinked 1 ; 
 end
end

cc ] . ; 
loop=ps 0 nchar 
  if ('listchar[#ps]' == 1 ) 
  cc [ #ps ; 
  end 
stop 
lset display lik; 

loop=tr 1 ntrees
  set bran sister [#tr 'tgtsp'] ; 
  if ('bran' > root)
    set bran_ref simgroup [#1 'bran' 0 ] ; 
  else
    set bran_ref 'bran' ;
  end
  report= ; 
  if ('dolik')
    if (!'doing_unlinked') 
       report = ; 
      /* piwe- ; */
       maketable + mk_charscores ; 
       piwe-  ;
       set dde mklik [#tr] ; 
       maketable - ;
       loop=ch 0 nchar
         set charscore ['bran_ref' #ch] 'mk_charscores [#ch]' ;
         sil=all ; quote score #ch  'mk_charscores [#ch]' ; sil=all ;    
       stop 
          report- ;
    else
      loop=po 0 ('numchrgrp'-1)
          cc ] . ; cc [ {#po} ; 
          loop=er 0 nchar
             if ( isinxgroup[#po #er] && 'listchar[#er]' == 0 ) 
              cc ] #er ; 
             end
          stop
          report=; 
          piwe-; 
          maketable + mk_charscores ; 
          piwe -  ;
           set dde mklik [#tr] ; 
          maketable - ;
          report- ; 
          loop=ch 0 nchar
           if (isinxgroup[#po #ch])
             set charscore ['bran_ref' #ch] 'mk_charscores [#ch]' ; 
           end 
         stop 
       stop 
       cc ] . ; 
       loop=ps 0 nchar 
            if ('listchar[#ps]' == 1 ) 
             cc [ #ps ; 
            end 
      stop 
    end
  else
       loop=ch 0 nchar
         set charscore ['bran_ref' #ch] score [#tr #ch] ; 
       stop 
  end
 report-; 
stop 

cc ] . ; 
loop=ps 0 nchar 
  if ('listchar[#ps]' == 1 ) 
     cc [ #ps ; 
  end 
  set charscore [outgroup #ps] 'charscore [sister[0 outgroup] #ps]' ; 
stop 


proc/; 
 
 



label DOCOLORTABLE_MODIF
report- ;
k 0 ; 
tvault < . ; 
tc 0 ; 

 
set star_x 220 ; set star_y 200 ; set pace_x 16 ; set pace_y 17 ; 
set tot_width (nchar + 1 ) * ('pace_x'+2) + 'star_x' + 250 ; 
set tot_hig (2 * (ntax + 1) ) * 'pace_y' + 'star_y' + 250 ; 

lquote = ; 
lquote [ ; 
silent = all ; 
report- ; 
 
set ctos 0 ; 


set pos_y 'star_y' - 2 ; 
set ctos_sp 0 ;
set star_b 'star_x' - 10 ; 
set maxrange 0 ;
silent = all ;
set dde 0 ;              

set pivote sister[0 outgroup] ; /* esta es la rama que queda sin tag */ /*New*/
reroot  * = 'pavote' ; /* pongo el enraizado original */ /*New*/
nak= ; 
tt- ; 

ttag * 0 ; 


 

     
  sil=all; quote dogrpchars   'dogrpchars'     numchrgrp 'numchrgrp'  grpscore [0 1]  'grpscore [0 1]'; 
          
if ('dogrpchars') 
	 loop 0 nchar 
	     set maxis[#1] 0 ; 
	     set minis[#1] 9999999 ;
	 stop 
	 set maxrange 0 ; 
	 loop 0 ('numchrgrp'-1) 
	    loop 0 nnodes [0]
	       if (  (#2 == root ) || (#2 == 'tgtsp') || (!isintree [0 #2]))
		 continue ; 
	       end 
	       if ('grpscore[#2 #1]' < 'minis[#1]' ) 
		   set minis[#1] 'grpscore[#2 #1]' ; 
	       else
		  if ('grpscore[#2 #1]' > 'maxis[#1]' ) 
		     set maxis[#1] 'grpscore[#2 #1]' ; 
		  end
	       end 
	    stop
	    if (('maxis[#1]'-'minis[#1]') > 'maxrange')
	       set maxrange 'maxis[#1]'-'minis[#1]' ;
	       set shift 'minis[#1]' ; 
	       set shoft 'maxis[#1]'; 
	    end 
	 stop 
         loop 0 ('numchrgrp'-1) 
	 	    loop 0 nnodes [0]
	 	       if (  (#2 == root ) || (#2 == 'tgtsp') || (!isintree [0 #2]))
	 		 continue ; 
	 	       end 
	 	       if ('maxgrpscore[#2 #1]' < 'minis[#1]' ) 
	 		   set minis[#1] 'maxgrpscore[#2 #1]' ; 
	 	       else
	 		  if ('maxgrpscore[#2 #1]' > 'maxis[#1]' ) 
	 		     set maxis[#1] 'maxgrpscore[#2 #1]' ; 
	 		  end
	 	       end 
	 	    stop
	 	    if (('maxis[#1]'-'minis[#1]') > 'maxrange')
	 	       set maxrange 'maxis[#1]'-'minis[#1]' ;
	 	       set shift 'minis[#1]' ; 
	 	       set shoft 'maxis[#1]'; 
	 	    end 
	 stop 

	 log $grp_scores_tabl ; 
	 sil-file; 
	 lquote = ; 
	 lquote [ ;
	 quote , ; 
	 loop=grp 0 ('numchrgrp'-1)
	     set bl_name $$xgroup #grp ; 
	     sil-file; quote $bl_name Min/Max, ; sil=file;
	 stop 
	 sil-file; quote &10 ; sil=file;
	 loop=nd 0 nnodes [0] 
	             set nod #nd ; 
	              if (#nd == 'tochang' )
		      	 	       continue ;
                      end
		     if (('nod' == root ) ||  ('nod' == 'tgtsp') || (!isintree [0 'nod']) ) 
		         continue ; 
		      end
		     if (#1 < root ) 
			 set bl_name $$taxon #1 ;
		      else
			set bl_name $Node #1 ;
		      end
		     sil-file; quote $bl_name , ; sil=file;
		     loop=grp 0 ('numchrgrp'-1)
			 sil-file; quote 'grpscore['trad_nd[#nd]'  #grp]'/'maxgrpscore['trad_nd[#nd]'  #grp]', ; sil=file;
		     stop
		     sil-file; quote &10 ; sil=file;
		     set nod sister[0 'tochang'] ; 
                     if (  #nd  ==  'nod'  )
	                 if ('tochang' < root ) 
			 	set bl_name $$taxon 'tochang' ;
			 else
				set bl_name $Node 'tochang' ;
		         end
		         sil-file; quote $bl_name , ; sil=file;
		         loop=grp 0 ('numchrgrp'-1)
			   sil-file; quote 'grpscore['trad_nd[#nd]'  #grp]'/'maxgrpscore['trad_nd[#nd]'  #grp]' , ; sil=file;
		         stop
		         sil-file; quote &10 ; sil=file;
		     end
	 stop 
	 sil=file; 
	 log/; 



	 log $group_file ; 
	 lquote [ ; 
	 lquote =; 
	 set tot_width 'numchrgrp' * 'pace_x' + 'star_x' + 200 ; 
	 sil-file; quote <svg width= &34 'tot_width'&34  height=&34 'tot_hig'&34  xmlns=&34 http://www.w3.org/2000/svg&34> &10 ;sil=all; 
	 set ctos 0 ; 
	 set pos_y 'star_y' - 2 ; 
	 loop=grp 0 ('numchrgrp'-1)
		   set bl_name $$xgroup #grp ;
		   set pos_x 'star_x' + ('pace_x' * 'ctos' ) ;
		   sil-file; quote <text x=&34 'pos_x'&34 &32y=&34 'pos_y'&34&32 font-size=&34 12&34&32 transform=&34 rotate (-60,'pos_x','pos_y')&34 > $bl_name:30 &32 </text> &10 ; sil=all; 
		   macfloat 7 ; 
		   set ctos ++ ; 
	 stop 
	 set ctos_sp 0 ;
	 set star_b 'star_x' - 10 ; 
	 set dde 0 ;
	 if (!'besever')
		    set span 'maxrange' ; 
		    set miti 'shift' + ('span'/2) ; 
		    set uncuar 'shift' + ( 'span' / 4 ) ;
		    set trescuar 'shift' + ( (3 * 'span') / 4 );

		   set trescuarI 'shoft' + ('shoft'-'uncuar' )  ; 
		   set mitiI   'shoft' + ('shoft'-'miti' )  ; 
		   set uncuarI   'shoft' + ('shoft'-'trescuar' )  ;
		   set shiftI 'shoft' ;
		   set shoftI  'shoft' + ('shoft' - 'shift' )   ;
		   set mini 'shift' ; 
		   set maxi 'shoft' ;  
		    if ('do_palette')
			  set mini 'shift' ; 
			  set pace ('span' / 20 );  
			  goto FILL_COLIM ; 
		    end 
	 end
         loop=grp 0 ('numchrgrp'-1)
                set bloque #1 ; 
                set pos_x 'star_b' + ('pace_x' * 'dde') ;
                set ctos_sp 0 ;
                if ('besever') 
			   set span 'maxis[#grp]' - 'minis[#grp]' ; 
			   set shift 'minis[#grp]' ; 
			   set shoft 'maxis[#grp]' ; 
			   set miti 'shift' + ('span'/2) ; 
			   set uncuar 'shift' + ( 'span' / 4 ) ;
			   set trescuar 'shift' + ( (3 * 'span') / 4 );
                           set mini 'shift' ; 
                           set maxi 'shoft' ; 
                           set trescuarI 'maxi' + ('maxi'-'uncuar' )  ; 
               	           set mitiI   'maxi' + ('maxi'-'miti' )  ; 
	   	           set uncuarI   'maxi' + ('maxi'-'trescuar' )  ;
	   	           set shiftI 'maxi' ;
 	   	           set shoftI  'maxi' + ('maxi' - 'mini' )   ;

			    if ('do_palette')
				 set mini 'minis[#grp]' ; 
				 set maxi 'maxis[#grp]' ;  
				 set pace ('span' / 20 );  
				 goto FILL_COLIM ;  
			   end 
                end 
                loop=nd 0 nnodes [0] 
                   set nod #2 ;
                   if (#nd == 'tochang' )
		  	continue ;
                   end
                   if (('nod' == root ) ||   ('nod' == 'tgtsp') || (!isintree [0 'nod']) ) 
                     continue ; 
                   end 
                   set pos_y 'star_y' + ('pace_y' * 'ctos_sp') ; 
                   if (('maxis[#grp]'-'minis[#grp]')== 0 )
                          set blue 130 ; 
                          set red 130 ; 
                          set green 130 ; 
                  else
                     
                           if ('minis [#1]' < 'shift' ) 
                               set elsco 'grpscore['trad_nd[#nd]'  #grp]' + ('shift' - 'minis [#grp]') ;
                           else
                               set elsco 'grpscore['trad_nd[#nd]'  #grp]' - ('minis [#grp]' - 'shift' ) ; 
                           end  
                           if (!'do_palette') 
                               set elsco 'shoft' + ('shoft' - 'elsco')  ;     
                   
                               if ('elsco' < ( 'uncuarI') )    
 				    set red   (254 - ( (254-240)  *  (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI'  ) )) )   ; 
				    set green (240 - ( (240-5)  *    (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI' ) )) )   ; 
 				    set blue  (1 + ( (5-1)  *        (('uncuarI'-'elsco' ) / ( 'uncuarI' - 'shiftI' ) )))    ;       
 
  			       else
 				    if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) ) /  
				         set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
				         set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
				         set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
				    else
				         if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )   
				    	    set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
					    set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
					    set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
				        else    
					     set red    ( 55  - ( (55-18)  *    (( 'shoftI' - 'elsco' ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
					     set green  ( 55  + ( (232-55)  *   (( 'shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
					     set blue   ( 148 + ( (232-148)  *  (( 'shoftI' - 'elsco'  ) / ( 'shoftI' - 'trescuarI' ) ) ))  ;
				        end
			            end
			       end    
                          else
                               set micore 'elsco' ; 
	                       goto SETTING_COLORS ; 
	                 end 
                 end 
                 lquote- ; 
                 SIL-FILE; quote <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 15&34&32height=&34 15&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ;SIL=FILE ;  
                  if (('grpscore['trad_nd[#nd]' #grp]' == 'minis[#grp]') && ('maxis[#grp]' != 'minis[#grp]' )) 
                        set px 'pos_x' + 2 ; set py 'pos_y' + 16 ; 
                        SIL-FILE ;    quote <text x=&34 'px'&34&32y=&34 'py'&34&32 font-size=&34 16&34&32 > &32* </text> &10 ; SIL=FILE ; 
                  end
                set ctos_sp ++ ;
                set nod sister[0 'tochang'] ; 
		if (  #nd  ==  'nod'  )
	          set pos_y 'star_y' + ('pace_y' * 'ctos_sp') ; 
                   SIL-FILE; quote <rect x=&34 'pos_x'&34&32y=&34 'pos_y'&34&32width=&34 15&34&32height=&34 15&34&32style=&34fill:rgb('red','green','blue')&34 /> &10 ;SIL=FILE ;  
                   if (('grpscore['trad_nd[#nd]' #grp]' == 'minis[#grp]') && ('maxis[#grp]' != 'minis[#grp]' )) 
		       set px 'pos_x' + 2 ; set py 'pos_y' + 16 ; 
		       SIL-FILE ;  quote <text x=&34 'px'&34&32y=&34 'py'&34&32 font-size=&34 16&34&32 > &32* </text> &10 ; SIL=FILE ; 
                   end
                   set ctos_sp ++ ;
                  end
               stop
              set dde ++ ; 
         stop
         set star_y 'star_y' + 12 ; 
         set ctos_sp 0 ; 
         set px 'tot_width' - 216 ; 
         loop 0 nnodes [0]
                if ( ( #1 == root ) || (#1 == 'tgtsp') || (!isintree [0 #1]) ) 
                 continue ; 
                end
                if (#1 == 'tochang' )
		 	continue ;
                end
                if (#1 < root ) 
                         set bl_name $$taxon #1 ;
                        else
                         set bl_name $Node #1 ;
                end
                set pos_y 'star_y' + ('pace_y' * 'ctos_sp' ) ; 
                SIL-FILE; quote <text x=&34 5&34&32y=&34 'pos_y'&34&32 font-size=&34 12&34 > &32 $bl_name:30 </text> &10 ; SIL=FILE;  
                macfloat 7 ; 
                if (#1 == 'trad_nd['besnod]')
                 set py 'pos_y' - 13 ; 
                 SIL-FILE;  quote <rect x=&34 4 &34&32y=&34 'py'&34&32width=&34 'px'&34&32height=&34 17&34&32stroke-width=&34 2&34&32stroke=&34black&34&32fill=&34none&34&32 /> &10 ;SIL=FILE;  
                end 
                set ctos_sp ++ ;
                set nod sister[0 'tochang'] ; 
		if (  #1  ==  'nod'  ) 
                     if ('tochang' < root ) 
		      set bl_name $$taxon 'tochang' ;
		   else
		      set bl_name $Node 'tochang' ;
                   end
                 set pos_y 'star_y' + ('pace_y' * 'ctos_sp' ) ; 
		 SIL-FILE; quote <text x=&34 5&34&32y=&34 'pos_y'&34&32 font-size=&34 12&34 > &32 $bl_name:30 </text> &10 ; SIL=FILE;  
                 set ctos_sp ++ ;
                end 
         stop
         set tot_width 'tot_width' - 80 ; 
         set dist 'pos_y' + 50 ; 
         SIL-FILE;
          if (!'besever')
		  set uncua 'uncuar'-'shift' ; set trescua 'trescuar'-'shift' ; set mit 'miti'-'shift' ; set shof 'shoft'-'shift' ; 
		  macfloat 2 ; 
		  quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > 0 </text>&10 ; 
		  quote <text&32x=&34 110 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'uncua' </text> &10 ; 
		  quote <rect x=&34 108&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
		  quote <text&32x=&34 210 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'mit' </text> &10 ; 
		  quote <rect x=&34 208&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
		  quote <text&32x=&34 310 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'trescua' </text> &10 ; 
		  quote <rect x=&34 308&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
		  quote <text&32x=&34 410 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34>+ 'shof' </text> &10 ; 
		  quote <rect x=&34 408&34&32y=&34 'dist'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
		  macfloat 10;  
          else
             quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 >Optimal</text>&10 ; 
             quote <text&32x=&34 400 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 >Suboptimal</text> &10 ; 
          end 
         
  set dist 'pos_y' + 60 ; 
 
  if (!'do_palette')
           quote <defs>&10<linearGradient&32id=&34graa&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
          quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
          quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(240,5,5).,stop-opacity:1&34></stop>&10; 
          quote </linearGradient>&10; 
          quote </defs>&10;
          quote <rect x=&34 310&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35graa)&34 />&10 ;
          
          quote <defs>&10<linearGradient&32id=&34grab&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
          quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(46,182,44) .,stop-opacity:1&34></stop>&10; 
          quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
          quote </linearGradient>&10; 
          quote </defs>&10;
          quote <rect x=&34 210&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35grab)&34 />&10 ;
         
          quote <defs>&10<linearGradient&32id=&34grac&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
          quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(18,232,232).,stop-opacity:1&34></stop>&10; 
          quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
          quote </linearGradient>&10; 
          quote </defs>&10;
          quote <rect x=&34 110&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35grac)&34 />&10 ;
         
          quote <defs>&10<linearGradient&32id=&34grad&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
          quote <stop offset=&34 0&37&34&32style=&34stop-color:rgb(55,55,148).,stop-opacity:1&34></stop>&10; 
          quote <stop offset=&34 100&37&34&32style=&34stop-color:rgb(18,232,232) .,stop-opacity:1&34></stop>&10; 
          quote </linearGradient>&10; 
          quote </defs>&10;
          quote <rect x=&34 10&34 &32y=&34 'dist'&34 &32width=&34 100&34&32 height=&34 16&34&32 style=&34fill:url(&35grad)&34 />&10 ;
         
         
         set dist 'dist' + 40 ; 
         quote <text&32x=&34 10 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > *Optimal placement for the partition</text>&10 ;
         set dist 'dist' + 20 ;
         quote <text&32x=&34 30 &34 &32 y=&34 'dist' &34 &32stroke-width=&34 1&34&32 font-size=&34 14&34 > Overall optimal placement </text>&10 ;
         set dist 'dist' - 13 ;
         quote <rect x=&34 4 &34&32y=&34 'dist'&34&32width=&34 17&34&32height=&34 17&34&32stroke-width=&34 2&34&32stroke=&34black&34&32fill=&34none&34&32 /> &10 ;
   else
         set tancia 10 ; 
         loop=uup 0 19
             quote <rect x=&34 'tancia'&34 &32y=&34 'dist'&34 &32width=&34 20&34&32 height=&34 20&34&32 style=&34fill:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]')&34 />&10 ;
             set tancia 'tancia' + 20 ; 
         stop 
   end

   quote </svg> &10 ; 
   log/; 
   SIL=FILE; 
 
end


lquote - ; 
proc/; 



LABEL COLORTREE_MULTREE
tg -1 ; 
tg -0 ; 
 
tt- ; 
tv < . ; 
tv - ; 
rer; 
unique ; 
set losarboles ntrees ;
nelsen * ;
set blue ntrees; 
set red 'blue'-1 ; 
tg = 0  0.'red' ;  /* grupo 0 los arboles pruneados */ 
tg = 1 'blue' ;    /* grupo 1 el strict */ 
tv > . ; 
k0 ; 
tv < . ; 

if ('dolik')
    lset speed 0.05 ldelta 0.01 bdelta 0.01 passes 40 40 ;
   if ('mk_space' )
      lset nogstatespace ; 
    end
    if ('unlinked' ) 
      set doing_unlinked 1 ; 
    end
end


loop=nd 0  (nnodes ['blue']) 
    set score_poly[ #nd  0 ]  999999999 ; 
    set score_poly[ #nd 1  ]  999999999 ; 
stop 
 

loop=tr 0 ('losarboles') 
       set luptre #tr ; 
       GOTO CALCULATE_SCORE_ONETREE ; 
       GOTO GIVE_SCORES_TO_STRICT ; 
       k0 ; 
stop       
tv < . ;
set mini 9999999999 ; 
set maxi 0 ; 
set tricto ntrees ; 
loop=dd 0 nnodes [ 'tricto' ] 
    if ((#dd  == outgroup) || (#dd == root) || (#dd  == 'tgtsp' ) || (!isintree ['tricto' #dd ]) )
       continue ; 
    end
  if ( nodfork [ 'tricto' #dd ] > 2 ) 
    if ( 'score_poly[ #dd 1 ]' < 'mini') 
        set mini 'score_poly[#dd 1 ]'  ; 
    end
  end
  if ('score_poly[ #dd 0 ]' < 'mini' ) 
      set mini 'score_poly[#dd 0 ]'  ;
  end
  if ( nodfork [ 'tricto' #dd ] > 2 ) 
      if ( 'score_poly[ #dd 1]' > 'maxi') 
          set maxi 'score_poly[#dd 1 ]'  ; 
          sil=all ; quote el maxi es ahora 'maxi' por score_poly[#dd 1 ]  ;  
      end
   end
  if ('score_poly[#dd 0 ]' > 'maxi' ) 
        set maxi 'score_poly[#dd 0 ]'  ;
         sil=all ; quote el maxi es ahora 'maxi' por score_poly[#dd 0 ]  ;  
  end
stop ; 

sil=all; quote el minimo es 'mini' maxi 'maxi' ; 



tv <. ; 
 set nds nnodes [ntrees ] ; 
 tc / ;   
 
goto PRINT_MULTREES ; 
 

PROC/; 


       



LABEL CALCULATE_SCORE_ONETREE
           macreport-; sil=all; 
           k 0 ; 
	   tv < . ;
	   tch 'luptre' ;  
	   sil=all; 
	   force/&0; 
	   constrain=; 
	   col none ; 
	   cc ] . ;
	   mu 1 = ho 1 ;
	   bb = fillonly ; 
	   loop=ps 0 nchar 
	     if ('listchar[#ps]' == 1 ) 
	       cc [ #ps ; 
	     end 
	   stop 
	   constrain- ; 
	   macfloat 10 ;
	   set mini 999999 ; 
	   set maxi 0 ; 
	   report- ; 
	   set sumLik 0 ;
	   if ('dolik') 
	     goto CALCULATE_ML_REF ; /*ver*/
	   end
	   tv < 'luptre' ; 
	   set green ntrees ; 
	   loop=rr 0 (ntrees-1)
	     set bran sister [#1 'tgtsp'] ; 
	      if (!'dolik' )  
	     	set elesco score [#1] ; 
	      else
	             
	     	     set elesco 0 ; 
	     	     if ( 'doing_unlinked' )
	     	          loop=po 0 ( 'numchrgrp' - 1 )
	     	                   cc ] . ; cc [ { #po } ;
	     	                   loop=er 0 nchar
	     	                         if ( isinxgroup[#po #er] && 'listchar[#er]' == 0 ) 
	     	                           cc ] #er ; 
	     	                         end
	     	                   stop
	     	                   piwe- ; 
	     	                   
	     	                   set dde mklik [#rr] ; 
	     	                   set elesco 'elesco' + 'dde' ;
	     	            stop
	     	            cc ] . ; 
	     	            loop=ps 0 nchar 
	     	               if ('listchar[#ps]' == 1 ) 
	     	                  cc [ #ps ; 
	     	               end 
	     	            stop 
	     	      else
	     	           set opt_tree #1 ; 
	     		   goto CALCULATE_ML ; 
	     	      end
	    end 	   
            if ('bran' > root)
		     set bran_ref simgroup [ #rr 'bran' 'green' ] ;
		     set core['bran_ref'] 'elesco' ;
		     set coras 'elesco' ;
	    else
		   set bran_ref 'bran' ;
		   set core['bran_ref'] 'elesco' ; 
		   set coras 'elesco' ;
	    end 
	   stop
	   if ('doing_EPA')
		 set maxi 0 ; 
		 macfloat 40 ; 
		 table /10 ; 
		 set sumLik 0 ; 
		 set mini_bk 'mini' ; 
		 set mini 1 ; 
		 set shift 'mini_bk' - 'mini' ; 
		 loop=lor 0 nnodes [0] 
		   if ((#lor == outgroup) || (#lor == root) || (#1 == 'tgtsp' ) || (!isintree [0 #lor]) )
		     continue ; 
		   end
		   set ladif ('core[#lor]' - 'shift') *(-1) ; 
		   set core[#lor] (power [ 2.7182818 'ladif' ] * 1000000 ); 
		   set sumLik 'sumLik' + 'core[#lor]' ; 
		 stop
		 loop=lor 0 nnodes [0] 
		     if ((#lor == outgroup) || (#lor == root) || (#1 == 'tgtsp' ) || (!isintree [0 #lor]) )
		        continue ; 
		     end
		     set core[#lor] (1 - ('core[#lor]' / 'sumLik')) ; 
		  stop
		 macfloat 10 ; 
	   end 
	   set van 0 ; 
	   K0 ; 
proc/; 


label GIVE_SCORES_TO_STRICT
 k 0 ; 
 tv < . ;
 set tricto ntrees ; 
 macreport -;  
 /*sil=all; quote -------------------------ANALIZANDO ARBOL 'luptre' --------------------------------; sil=all; */
 nak- ; 
 tp 'luptre' ; 
 sil=all; 
 loop=nd 0  nnodes ['luptre'] 
     set nod eqgroup [  'luptre' #nd 'tricto'] ; 
     if ((#nd  == outgroup) || (#nd == root) || ( #nd  == 'tgtsp' ) || ('nod' < 0 ) )
        continue ; 
      end
     if ('core[#nd]' < 'score_poly['nod'  0 ]' ) 
          set score_poly['nod'  0 ] 'core[#nd]' ; 
     end 
 stop
 loop=nd 0  (nnodes ['tricto']) 
    set nod #nd ; 
    if (('nod'  == outgroup) || ('nod' == root) || ('nod'  == 'tgtsp' ) || (!isintree ['tricto' 'nod' ]) )
     continue ; 
    end
     
    set posy 0 ; 
    if ( nodfork [ 'tricto' 'nod' ] > 2 )   
            set posy 1 ; 
            set lis deslist [ 'tricto' #nd] ; 
	    set dde listsize ; 
	    loop=op 0 ('dde'-1 )
	                  set green 'lis[#op]' ; /* descendiente del nodo poly 'nod' en strict */
	                  set noda  eqgroup [  'tricto'  'green'  'luptre'] ; /* nodo en luptre q se corresponde al descendiente de 'nod' en strict */
			  set red   eqgroup [  'tricto'  'nod'  'luptre'] ; /* nodo en luptre q se corresponde al poly en strict */
			  sil=all; quote Descendinte del poly en el estricto es  'green' que es 'noda' en luptre y vamos hasta el nodo correspondiente al poly en el luptre 'red' ; 
			  set posy anc['luptre'  'noda'] ; 
			  /*sil-all ; quote el anc de noda ('noda') es 'posy' en 'luptre' ; */
			  if ( 'posy'== 'red'  ) 
			   continue 
			  end 
			  travtree path 'luptre' 'noda' 'red'  blue  
			           /* si-all ; quote el nodo intermedio es 'blue' ; 
			            if ( ( 'blue' != 'red')  && ('blue' != 'noda') )  */
			              sil=all;  ; quote red 'red' blue 'blue' noda 'noda' entro con un core de 'core['blue']' y un poly de 'score_poly[ 'nod' 1 ]' ; sil=all;  
				      if ('core['blue']' < 'score_poly[ 'nod' 1 ]' )
				          sil=all ; quote asigno a 'nod' el score de core[blue] 'core['blue']' blue 'blue' ; 
		 		          set score_poly['nod' 1 ] 'core['blue']' ; 
				      end  
				    end 
			   endtrav
	      stop
    end
 stop   
 macreport - ; sil=all; 
 k0 ; 
 
 proc/; 
 
 
 
 
 
 label PRINT_MULTREES
 
 
 set dde 0 ; 
 set maxi_all 'maxi' ; set mini_all 'mini' ; 
 sil=all; quote minit 'mini' maxi 'maxi' ;sil=all; 
 
 set span 'maxi' - 'mini' ; set span_all 'span' ; 
 set miti 'mini' + ('span'/2) ; set miti_all 'miti' ; 
 set uncuar 'mini' + ( 'span' / 4 ) ; set uncuar_all 'uncuar' ; 
 set trescuar 'mini' + ( (3 * 'span') / 4 ); set trescuar_all 'trescuar' ; 
 set coras ntrees ; 
 
 set trescuarI 'maxi' + ('maxi'-'uncuar' )  ; 
 set mitiI   'maxi' + ('maxi'-'miti' )  ; 
 set uncuarI   'maxi' + ('maxi'-'trescuar' )  ;
 set maxiI    'maxi' + ('maxi - 'mini' )  ;
 
 macfloat 10 ;
 set violet 0 ;
 /*sil-file; quote span 'span' miti 'miti' uncuar 'uncuar' trescuar 'trescuar' ; sil=all; */
 if ('do_palette')
   set pace ('span' / 20 );  
   goto FILL_COLIM ; 
end  

ttag * 0 ;
  

loop=no 0 'nds'
   ttag <#no ; 
   if ((#no == root) || (#no == 'tgtsp') || (!isintree [0 #no]) ) 
      continue ; 
   end 
   if ('mini' == 'maxi') 
     ttag +#1 (0,0,0) ; 
     continue ; 
   end 
   set ccc 'score_poly[#no 0 ]'-'mini' ; 
   if ('ccc' < 0.000001 )
 	    set micore 'mini' ;
 	    if ('do_palette')
 	            goto SETTING_COLORS ; 
 	    else
 	            set red 55 ; 
 	            set green 55 ;  
 	            set blue  148 ;  
 	     end  
 	     macfloat 2 ; 
 	     if (!'doing_EPA')
 	       ttag +#1 ('red','green','blue') ;
 	    else
 	       macfloat 4 ;
 	       ttag +#1 ('red','green','blue') ;
 	    end
 	    macfloat 10 ; 
   else
       if ('do_palette')
           set micore 'score_poly[#no 0 ]' ; 
           goto SETTING_COLORS ; 
       else  
               set elsco   'maxi' + ('maxi' -'score_poly [#no 0 ]' ) ; 
     	      if ('elsco' < ( 'uncuarI') ) ; /*240,5,5 a  254,240,1 */ 
 		      set red   (254 - ( (254-240)  *  (( 'uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
 		      set green (240 - ( (240-5)  *   (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
 		      set blue  (1 +   ( (5-1)  *     (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )))    ;   ;   
 	      else
 		     if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) ) /* 254,240,1  a 46,182,44) */ 
 			set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
 			set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
 			set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
 		    else
 			 if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )  /*46,182,44 a 18,232,232*/
 				set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
 				set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
 				set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
 			 else   /*18,232,232 a 55,55,148*/
 				set red    ( 55  - ( (55-18)  *    (( 'maxiI' - 'elsco' ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
 				set green  ( 55  + ( (232-55)  *   (( 'maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
 				set blue   ( 148 + ( (232-148)  *  (('maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
 
 			  end
 		    end
 	     end
 	 
      end	     
      macfloat 2 ; 
   
      if (!'doing_EPA') 
          ttag +#1 ('red','green','blue'); 
      else
         macfloat 4 ; 
         set posy 1 - 'score_poly[#1 0 ]' ; 
         ttag +#1 ('red','green','blue') ;
       end
       macfloat 10 ; 
   end
   
   macfloat 10 ;
 stop
 
 
 
 
 
 if (root   > 50 )
    set larama 160 ; 
 else
    set larama 140 ; 
 end 
 if ('clade_anal')
   set choram 80 ; 
 else
   set choram 50 ; 
 end
 
 
 set red outgroup ; 
 set dientes deslist [0 root] ; 
 if ('dientes[0]' == 'red')
       set blue 'dientes[1]' ;
 else
     set blue 'dientes[0]' ;
 end
 set stri  $$ttag 'blue' ;  
 ttag <'red'; 
 ttag +'red' $stri  ;   
  
 ttag & $output_svg xysave eti bheight 'choram' legup 15 txtsep 20 bfontsize 20  tfontsize 35 blength 'larama' thickness 4  colors ; /* bheight 120 */
 
 
 
 
 loop=no 0 'nds'
 set nod #no ; 
   if ((#no == root) || (#no == 'tgtsp') || (!isintree [0 #no]) ) 
      continue ; 
   end 
   set red nodfork[  0 'nod' ] ; 
   if ( 'red' < 3 )   
          continue ; 
   end
   sil=all ; quote score_poly[#no 1 ] 'score_poly[#no 1 ]' ; 
   set ccc 'score_poly[#no 1 ]'-'mini' ; 
   if ('ccc' < 0.00001 )
 	    set micore 'mini' ;
 	    if ('do_palette')
 	            goto SETTING_COLORS ; 
 	    else
 	            set red 55 ; 
 	            set green 55 ;  
 	            set blue  148 ;  
 	     end  
 	     macfloat 2 ; 
 	     if (!'doing_EPA')
 	       set color_poly [#1 0] 'red'  ; 
 	       set color_poly [#1 1] 'green'; 
                set color_poly [#1 2] 'blue' ; 
 	    else
 	       macfloat 4 ;
 	       ttag +#1 ('red','green','blue') ;
 	    end
 	    macfloat 10 ; 
   else
       if ('do_palette')
           set micore 'score_poly[#no 1 ]' ; 
           goto SETTING_COLORS ; 
       else  
               set elsco   'maxi' + ('maxi' -'score_poly [#no 1 ]' ) ; 
     	      if ('elsco' < ( 'uncuarI') ) ; /*240,5,5 a  254,240,1 */ 
 		      set red   (254 - ( (254-240)  *  (( 'uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
 		      set green (240 - ( (240-5)  *   (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )) )   ; 
 		      set blue  (1 +   ( (5-1)  *     (('uncuarI' - 'elsco') / ( 'mitiI' - 'uncuarI') )))    ;     
 	      else
 		     if (( 'elsco' >= 'uncuarI' ) && ( 'elsco' < 'mitiI' ) ) /* 254,240,1  a 46,182,44) */ 
 			set red   (46 +   ( (254-46)  * (('mitiI' - 'elsco')  / ( 'mitiI' - 'uncuarI') ))) ;
 			set green (182 + ( (240-182)  *  (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ; 
 			set blue  (44  -  ( (44-1)  *    (('mitiI' - 'elsco') / ( 'mitiI' - 'uncuarI') ))) ;
 		    else
 			 if (( 'elsco' >= 'mitiI' ) && ( 'elsco' < 'trescuarI' ) )  /*46,182,44 a 18,232,232*/
 				set red   ( 18  + ( (46-18)    *  (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) ))  ;
 				set green ( 232 - ( (232-182)  * (('trescuarI'-'elsco') / ( 'trescuarI' - 'mitiI') ) ) );
 				set blue  ( 232 - ( (254-44)   * (('trescuarI'-'elsco' ) / ( 'trescuarI' - 'mitiI') ) )  ); 
 			 else   /*18,232,232 a 55,55,148*/
 				set red    ( 55  - ( (55-18)  *    (( 'maxiI' - 'elsco' ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
 				set green  ( 55  + ( (232-55)  *   (( 'maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
 				set blue   ( 148 + ( (232-148)  *  (('maxiI' - 'elsco'  ) / ( 'maxiI' - 'trescuarI' ) ) ))  ;
 
 			  end
 		    end
 	     end
 	 
      end	     
      macfloat 2 ; 
      if (!'doing_EPA') 
         set color_poly [#1 0] 'red'  ; 
         set color_poly [#1 1] 'green'; 
         set color_poly [#1 2] 'blue' ; 
         sil=all ; quote color_poly [#1 0]  'color_poly [#1 0]'  color_poly [#1 1]  'color_poly [#1 1]'  color_poly [#1 2]  'color_poly [#1 2]' ; 
       end
  
   end
   
   macfloat 10 ;
 stop
 
  
 
 set dist -99999 ; 
 
 set red outgroup ; 
 set dientes deslist [0 root] ; 
 if ('dientes[0]' == 'red')
       set blue 'dientes[1]' ;
 else
     set blue 'dientes[0]' ;
 end
 loop=no 0 'nds'
 	  set ndtran #no ; 
 	  ttag <#no ; 
 	  set nod #no ; 
 	  if ((#no == root)  || (#no == 'tgtsp') || (!isintree [0 #no]) ) /* saque q no haga el out */
 	     continue ; 
 	  end 
 	  set pos_x ('eti[#no 0]' - 'eti[anc[0 #no] 0]')/ 12 + 'eti[anc[0 #no] 0]' - 5  ; 
 	  set pos_y 'eti[#no 1]' - 8  ; 
 	  if ('mini' == 'maxi') 
 	    ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> Nd'nod'0 </text> &10 ; 
 	    continue ; 
 	  end
 	  if (#no == outgroup) 
 	    set ccc 'score_poly['blue' 0 ]' -'mini' ; 
 	  else 
 	     set ccc 'score_poly[#no 0 ]'-'mini' ;   /* set ccc 'core[ #no ]'-'mini' ; */
 	  end
 	 if ('ccc' <= 0.00001 )
 		     macfloat 2 ; 
 		     set pos_y 'pos_y' - 5 ; 
 		     if (!'doing_EPA')
 			ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'nod' &32 'mini' </text> &10 ;
 		     else
 		       macfloat 4  ;
 		       set blue 1 - 'mini' ; 
 		       ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'nod' 'blue' </text> &10 ;
 		    end
 		    macfloat 10 ; 
 	  else
 	     macfloat 2 ; 
 	     if (!'doing_EPA') 
 		ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'nod'+'ccc' </text> &10 ;
 	   else
 	       macfloat 4  ;
 	       set posy 1 - 'score_poly[#no 0 ]' ; 
 	       ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> N'nod' 'posy'  </text> &10 ;
 	      end
 	  macfloat 10 ; 
 	  end
 	  macfloat 10 ;
 stop
 
 
 
  
  
 loop=no 0 'nds'  
 	   set nod #no ; 
 	   if ((#no == root)  || (#no == 'tgtsp') || (!isintree [0 #no]) )  
 	       continue ; 
            end
            set red nodfork[  0 'nod' ] ; 
            if ( 'red' < 3 )   
 	      continue ; 
 	   end
 	   set ccc 'score_poly ['nod' 1 ]' - 'mini'  ; 
 	   sil=all ;quote score_poly ['nod' 1 ] 'score_poly ['nod' 1 ]'  ; sil=all; 
 	 
 	   ttag <'nod' ; 
 	   set pos_x ('eti[#no 0]' - 'eti[anc[0 #no] 0]')/ 12 + 'eti[anc[0 #no] 0]' - 5  ; 
 	   set pos_y 'eti[#no 1]' + 20  ; 
 	   if ('mini' == 'maxi') 
 	       ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> PolyN'nod'0 </text> &10 ; 
 	       continue ; 
 	   end
 	   if ('ccc' < 0.0001 )
 		     macfloat 2 ; 
 		     if (!'doing_EPA')
 		        set pos_y 'pos_y' + 9  ; 
 		 	ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> PolN'nod' &32 'mini' </text> &10 ;
 		     else
 		       macfloat 4  ;
 		       set blue 1 - 'mini' ; 
 		       ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> PolN'nod' 'blue' </text> &10 ;
 		    end
 		    macfloat 10 ; 
 	     else
 		macfloat 2 ; 
 		if (!'doing_EPA') 
 		set pos_y 'pos_y' + 9  ; 
 		  ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> PolN'nod'+'ccc' </text> &10 ;
 		else
 		  macfloat 4  ;
 		  set posy 1 - 'ccc' ; 
 		  ttag&+ write<text&32x=&34 'pos_x' &34 &32 y=&34 'pos_y' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34> PolN'nod' 'posy'  </text> &10 ;
 		 end
 	     macfloat 10 ; 
 	  end 
 	  goto DEFINE_POLY_HEIGH ; 
 	  set red 'color_poly[#1 0 ]' ; set green 'color_poly[ #1 1 ]' ; set blue 'color_poly[ #1 2 ]' ; 
 	  sil=all ; quote los valores que vamos a poner son 'red','green','blue' ; sil=all; 
 	  ttag&+ write<line&32x1=&34 'eti[#no 0]' &34 &32 y1=&34 'dde' &34 &32 x2=&34 'eti[#no 0]' &34 &32 y2=&34 'pos_y' &34 &32 stroke-width=&34 7&34&32 stroke=&34rgb('red','green','blue')&34 /> &10 ;  
 stop  
 
 
 
 loop 0 nnodes [ 0] 
  if ('eti [#1 1]' > 'dist')
    set dist 'eti [#1 1]' ; 
  end
 stop 
 set dist 'dist' + 120 ; 
 set posx 'dist' - 40 ; 
 lquote [ ; 
 ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Optimal</text>&10 ; 
 ttag&+ write <text&32x=&34 500 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > Suboptimal</text>&10 ; 
 
 set posx 'dist' -15 ; 
  
   set span 'maxi' - 'mini' ; 
   set shift 'mini' ; 
   set shoft 'maxi' ; 
   set mit ('span'/2) ; 
   set uncua ( 'span' / 4 ) ;
   set trescua ( (3 * 'span') / 4 ) ;
   macfloat 2 ; 
   ttag&+ write<text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34 > 0 </text>&10 ; 
   if (!'doing_EPA') 
     ttag&+ write<text&32x=&34 160 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+'uncua' </text> &10 ; 
   else
     ttag&+ write<text&32x=&34 160 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>-'uncua' </text> &10 ; 
   end
   ttag&+ write<rect x=&34 158&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
   if (!'doing_EPA') 
     ttag&+ write<text&32x=&34 310 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+'mit' </text> &10 ; 
   else
     ttag&+ write<text&32x=&34 310 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>-'mit' </text> &10 ; 
   end
   ttag&+ write<rect x=&34 308&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
   if (!'doing_EPA') 
    ttag&+ write<text&32x=&34 460 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+'trescua' </text> &10 ; 
   else
    ttag&+ write<text&32x=&34 460 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>-'trescua' </text> &10 ; 
   end
  ttag&+ write<rect x=&34 458&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
  if (!'doing_EPA') 
     ttag&+ write<text&32x=&34 610 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>+'span' </text> &10 ; 
   else
     ttag&+ write<text&32x=&34 610 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 20&34>-'span' </text> &10 ; 
   end  
   ttag&+ write<rect x=&34 608&34&32y=&34 'posx'&34&32width=&34 2&34&32height=&34 10&34&32style=&34fill:black&34 /> &10 ;
   macfloat 10; 
  
  set dist 'posx' + 10 ; 
 
 
 
 
 if (!'do_palette') 
 	 ttag&+ write <defs>&10<linearGradient&32id=&34graa&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
 	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
 	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(240,5,5).,stop-opacity:1&34></stop>&10; 
 	 ttag&+ write </linearGradient>&10; 
 	 ttag&+ write </defs>&10;
 	 ttag&+ write <rect x=&34 460&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35graa)&34 />&10 ;
 
 	 ttag&+ write <defs>&10<linearGradient&32id=&34grab&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
 	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
 	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(254,240,1).,stop-opacity:1&34></stop>&10; 
 	 ttag&+ write </linearGradient>&10; 
 	 ttag&+ write </defs>&10;
 	 ttag&+ write <rect x=&34 310&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grab)&34 />&10 ;
 
 	 ttag&+ write <defs>&10<linearGradient&32id=&34grac&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
 	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(18,232,232) .,stop-opacity:1&34></stop>&10; 
 	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(46,182,44).,stop-opacity:1&34></stop>&10; 
 	 ttag&+ write </linearGradient>&10; 
 	 ttag&+ write </defs>&10;
 	 ttag&+ write <rect x=&34 160&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grac)&34 />&10 ;
 
 	 ttag&+ write <defs>&10<linearGradient&32id=&34grad&34&32x1=&34 0&37&34&32y1=&34 0&37&34&32x2=&34 100&37&34&32y2=&34 0&37&34>&10 ; 
 	 ttag&+ write <stop offset=&34 0&37&34&32style=&34stop-color:rgb(55,55,148).,stop-opacity:1&34></stop>&10; 
 	 ttag&+ write <stop offset=&34 100&37&34&32style=&34stop-color:rgb(18,232,232).,stop-opacity:1&34></stop>&10; 
 	 ttag&+ write </linearGradient>&10; 
 	 ttag&+ write </defs>&10;
 	 ttag&+ write <rect x=&34 10&34 &32y=&34 'dist'&34 &32width=&34 150&34&32 height=&34 30&34&32 style=&34fill:url(&35grad)&34 />&10 ;
 else
    set tancia 10 ; 
    loop=uup 0 19
      ttag&+ write <rect x=&34 'tancia'&34 &32y=&34 'dist'&34 &32width=&34 30&34&32 height=&34 30&34&32 style=&34fill:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]')&59stroke:rgb('viridis[0 #uup]','viridis[1 #uup]','viridis[2 #uup]') &34 />&10 ;
      set tancia 'tancia' + 30 ; 
    stop   
    
 end
 
 
 set primero 0 ; 
 
 
 set span_err 100 ; 
 set miti_err ('span_err'/2) ; 
 set uncuar_err ( 'span_err' / 4 ) ;
 set trescuar_err ( (3 * 'span_err') / 4 );
  
 loop=nd 0 nnodes[0] 
 	 if ( (#1 == root) || (#1 == 'tgtsp') || (!isintree [0 #nd]) || (#1 == outgroup )) 
 	   continue ; 
 	 end 
 	 if ( ( #1 < root) && ( 'listax [#nd]' == 1 ) ) 
 	  continue ; 
 	 end
 	 set tancia ('eti [#1 0]' - 'eti [anc[0 #1] 0]' ) / 4 ; 
 	 set posx 'eti [anc[0 #1] 0]' + ('tancia' * 3 )  ;
 	 if ( ('score_poly[#1 0 ]' - 'mini') < 0.00001 ) /*New*/
 		   if (#1 == 'besnod' ) /*New*/
 		          ttag &+ write <circle cx=&34 'posx'&34 &32cy=&34 'eti [#1 1]'&34 &32r=&34 9&34&32 fill=&34black&34&32 stroke=&34black&34&32 /> &10 ;
 		   else
 		         ttag &+ write <circle cx=&34 'posx'&34 &32cy=&34 'eti [#1 1]'&34 &32r=&34 11&34&32 fill=&34black&34&32 stroke=&34black&34&32 /> &10 ;
 		   end
 	           set primero ++ ; 
 	 end
 stop 
 
 loop=nd 0 nnodes[0] 
 	 if ( (#1 == root) || (#1 == 'tgtsp') || (!isintree [0 #nd]) || (#1 == outgroup ) ) 
 	   continue ; 
 	 end 
 	 if ( ( #1 < root) && ( 'listax [#nd]' == 1 ) ) 
 	  continue ; 
 	 end
 	 if (('score_poly[#1 1 ]' - 'mini') < 0.00001 ) /*New*/
 		   if (#1 == 'besnod' ) /*New*/
 		          ttag &+ write <circle cx=&34 'eti [#1 0]'&34 &32cy=&34 'eti [#1 1]'&34 &32r=&34 9&34&32 fill=&34black&34&32 stroke=&34black&34&32 /> &10 ;
 		   else
 		         ttag &+ write <circle cx=&34  'eti [#1 0]'&34 &32cy=&34 'eti [#1 1]'&34 &32r=&34 11&34&32 fill=&34black&34&32 stroke=&34black&34&32 /> &10 ;
 		   end
 	           set primero ++ ; 
 	 end
 stop 
 
 set posx 'dist' +70 ; 
 set tgtname $$taxon 'tgtsp'; 
 ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Target Species=&32 $tgtname </text> &10 ; 
 
 if ('primero' > 1 ) 
  set posx 'dist' +100 ; 
  ttag &+ write <circle cx=&34 20&34 &32cy=&34 'posx' &34 &32r=&34 9&34&32 fill=&34black&34&32 stroke=&34black&34&32 /> &10 ;
  set posx 'dist' +105 ;
  ttag&+ write <text&32x=&34 50 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Optimal placements  </text>&10 ;
  set posx 'dist' +130 ; 
 else
  set posx 'dist' +97 ;
  ttag &+ write <circle cx=&34 25&34 &32cy=&34 'posx' &34 &32r=&34 9&34&32 fill=&34black&34&32 stroke=&34black&34&32 /> &10 ;
  set posx 'dist' +105 ;
  ttag&+ write <text&32x=&34 50 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Optimal placement </text>&10 ;
 end
 set posx 'dist' +135 ;
 if ( ( 'nopiwe' == 1 ) && ( 'dosensit' == 1 ) ) 
  ttag&+ write <text&32x=&34 20 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Running conditions selected by Leave-one-out validation approach </text>&10 ;
 end
 if ('clade_anal')
  set posx 'dist' +170 ;
  ttag&+ write <text&32x=&34 10 &34 &32 y=&34 'posx' &34 &32stroke-width=&34 1&34&32 font-size=&34 28&34 >Bars below branches represent In Subtree Error (ISE) </text>&10 ;
 end 
 
 ttag & ;
 
 

 

proc/; 